' Gambas module file

Public Function funSchaltjahr(j As Integer) As Boolean
Dim booErgebnis As Boolean
  If Frac((j - 1600) / 4) = 0 Then
      booErgebnis = True
  Else
      booErgebnis = False
  Endif
  Return booErgebnis
End

Function funLuftTemptoErdTemp(fltLuftTemp As Float) As Float
  Dim fltErdTemp As Float
  
  If fltLuftTemp > 0 Then
    fltErdTemp = 1.1744414 * fltLuftTemp - 0.4694585
  Else
    fltErdTemp = 0.26059699 * fltLuftTemp + 0.08115934  
  Endif
  Return fltErdTemp 
End


Public Function funRundenSTR(strIN As String, intStellen As Integer) As String
Dim strElement As String
Dim strGesplittet As String[]
Dim strZahl As New String[2]
Dim strNachkomma As String
Dim strZahl12 As String
Dim strTemp As String
Dim a, i, intGemerkt As Integer

  a = 0
  strGesplittet = Split(strIN, ".")    'es wird der gelesenen String (strZeile) in die durch "." getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
  For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
    strZahl[a] = Replace$(strElement, "\r", "")
    a = a + 1   'nächste Spalte
  Next    'nächstes Element in strGesplittet
  
  If Len(strZahl[1]) < intStellen Then
      strNachkomma = strZahl[1]
      For i = Len(strZahl[1]) + 1 To intStellen
        strNachkomma &= "0"
      Next
  Endif
   
  If Len(strZahl[1]) = intStellen Then
      strNachkomma = strZahl[1]
  Endif
  
  If Len(strZahl[1]) > intStellen
    'Runden auf STELLEN
    If CInt(Mid$(strZahl[1], intStellen + 1, 1)) < 5 Then
      strNachkomma = Left$(strZahl[1], intStellen)
    Else ' wenn die Stelle danach größer 4
      intGemerkt = 1
      strZahl12 = strZahl[0] & Left$(strZahl[1], intStellen)
      
      For i = Len(StrZahl12) To 1 Step -1
        If CInt(Mid$(strZahl12, i, 1)) + intGemerkt > 9 Then
          strZahl12 = Mid$(strZahl12, 1, i - 1) & "0" & Mid$(strZahl12, i + 1, Len(strZahl12) - i)
          'Mid$(strZahl12, i, 1) = "0"
          intGemerkt = 1
        Else
          strTemp = CStr(CInt(Mid$(strZahl12, i, 1)) + intGemerkt)
          strZahl12 = Mid$(strZahl12, 1, i - 1) & strTemp & Mid$(strZahl12, i + 1, Len(strZahl12) - i)
          intGemerkt = 0
        Endif
      Next
      
      strZahl[0] = Left$(strZahl12, -intStellen)
      strNachkomma = Right$(strZahl12, intStellen)
    Endif
  End If

  Return strZahl[0] & "." & strNachkomma
End


Public Function funTestNumerisch(strVariable As String) As Boolean
  Dim i As Integer
  Dim booOK As Boolean
  booOK = True
  For i = 1 To Len(strVariable)
    If Asc(Mid$(strVariable, i, 1)) < 48 Or Asc(Mid$(strVariable, i, 1)) > 57 Then booOK = False
  Next
  Return booOK
End


Public Function funGaussWT(d As Integer, m As Integer, c As Integer, y As Integer) As Integer
Dim intMOD As Integer
    If m < 3 Then
      If y = 0 Then
        c -= 1
        y = 99
      Else
        y -= 1
      Endif
    Endif
    m -= 2
    If m < 1 Then m += 12
    intMOD = CInt((d + CInt(2.6 * m - 0.2) + y + CInt(y / 4) + CInt(c / 4) - 2 * c) Mod 7)
    If intMOD < 0 Then intMOD += 7
    If intMOD = 0 Then intMOD = 7
    Return intMOD
    'Montag = 1
End
 
Public Function funSigmoid(A As Float, B As Float, C As Float, D As Float, mH As Float, bH As Float, mW As Float, bW As Float, V As Float, V0 As Float) As Float
  Dim fltErgebnis As Float
  fltErgebnis = (A / (1 + ((B / (V - V0)) ^ C))) + D + Max((mH * V + bH), (mW * V + bW))
  If fltErgebnis > 0 Then
    Return fltErgebnis
  Else
    Return 0.00
  Endif
End



Public Function funDaemmstaerke(strDatensatzRohre As String[], R2 As Float) As Float
  Dim intKlasse As Integer
  Dim i As Integer
  Dim Ergebnis As Float
  intKlasse = Global.intDaemmklasse
  Ergebnis = 0
  For i = 0 To Global.conMaxRohre - 1
    If strDatensatzRohre[1, i] = CStr(2 * R2) Then
      Ergebnis = (CFloat(strDatensatzRohre[intKlasse + 3, i]) - CFloat(strDatensatzRohre[2, i])) / 2
    Endif
  Next
  'IF Ergebnis = 0 THEN Message("Durchmesser: " & CStr(2 * R2) & " nicht in Datenbank!")
  Return Ergebnis
End



Public Function funLambda(strDatensatzRohre As String[], R2 As Float) As Float
  Dim i As Integer
  Dim Ergebnis As Float
  Ergebnis = 0
  For i = 0 To Global.conMaxRohre - 1
    If strDatensatzRohre[1, i] = CStr(2 * R2) Then
      Ergebnis = CFloat(strDatensatzRohre[7, i])
    Endif
  Next
  'IF Ergebnis = 0 THEN Message("Durchmesser: " & CStr(2 * R2) & " nicht in Datenbank!")
  Return Ergebnis
End



Public Function funTemperatur(Temp1 As Float, TempU As Float, Laenge As Float, Lambda As Float, R2 As Float, R3 As Float, Massenstrom As Float) As Float
  Dim k As Float
  R2 /= 1000
  R3 /= 1000
  If R2 > 0 And R3 > 0 And R3 - R2 > 0 Then
    k = 1 / ((R3 - R2) / (Lambda * (2 * Pi() * (R3 - R2) / Log(R3 / R2))))
  Endif
  If Massenstrom > 0 And R2 > 0 And R3 > 0 And R3 - R2 > 0 Then
    Return (TempU + ((Temp1 - TempU) * Exp((-k * Laenge) / (Massenstrom * Global.cp * 1000))))
  Else
    Return TempU
  Endif
End



Public Function funDruckverlust(RHO As Float, k As Float, alpha As Float, ms As Float, l As Float, di As Float) As Float
  'nach Stefan Gnüchtel TU Dresden Anwenderhandbuch Seite 8, Formel 5  
  Return ((0.88 / (RHO * (Pi() ^ 2))) * (k ^ 0.25) * (alpha + 1) * (ms ^ 2) * (l / ((di / 1000) ^ 5.25)) / 1000000)
End


Public Function funLaenge(x1 As Float, y1 As Float, x2 As Float, y2 As Float) As Float
  Dim dx, dy As Float
  dx = Sqr((x2 - x1) ^ 2)
  dy = Sqr((y2 - y1) ^ 2)
  Return (Sqr((dx ^ 2) + (dy ^ 2)))
End


Public Function funTesteDatei(strDateiname As String) As Boolean
Dim hsDatei As Stream
  hsDatei = Open strDateiname
  Return True
Catch
  Return False
End



Public Function funTesteTRY04() As Boolean
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim i As Integer
  
  'KlimaTag
  i = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameKlimaTagKW & ".csv" For Input 'öffnen der Datei rfKlimaTag.csv

  Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen

  strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe

  If strGesplittet[3] = "4" Then
      Close #hsDatei
      Return True       
  Endif
  
   If strGesplittet[3] <> "4" Then
      Close #hsDatei
      Return False       
  Endif
'Catch
 ' Return False
End



Public Function funStringStelleLeer01(strDaten As String) As Integer
  Return InStr(StrDaten, " ") + 1
End


Public Function funStringStelleLeer02(strDaten As String) As Integer
Dim a As Integer
  a = InStr(StrDaten, " ")
  Return InStr(Right$(StrDaten, -a), " ") + a + 1
End


Public Function funStringStelleLeer03(strDaten As String) As Integer
Dim a As Integer
  a = InStr(StrDaten, " ")
  a = InStr(Right$(StrDaten, -a), " ") + a + 1
  Return InStr(Right$(StrDaten, -a), " ") + a + 1
End


Public Function funStringStelleLeer04(strDaten As String) As Integer
Dim a As Integer
  a = InStr(StrDaten, " ")
  a = InStr(Right$(StrDaten, -a), " ") + a + 1
  a = InStr(Right$(StrDaten, -a), " ") + a + 1
  Return InStr(Right$(StrDaten, -a), " ") + a + 1
End


Public Function funAuslegungstemperatur() As Float

Dim b As Integer
Dim AusLegTemp As Float
  AusLegTemp = 1000
  Programmcode.lese_Klima_Tag()
  For b = 1 To Global.strDatensatzKlimaTag[0, 0]
    If CFloat(Global.strDatensatzKlimaTag[0, b]) < AusLegTemp Then
      AusLegTemp = CFloat(Global.strDatensatzKlimaTag[0, b])
    Endif
  Next
  Return AusLegTemp
End

Public Function funErdreichtemp(intStunde As Integer) As Float
  'Formel nach Schriftenreihe: Berichte aus Praxis und Forschung des Fachgebietes Bauphysik / Technische Gebaeudeausr üstung / Baulicher Brandschutz
  'Herausgeber: Prof.Dr.Hermann Heinrich
  'Copyright: Fachgebiet Bauphysik / Technische Gebaeudeausruestung / Baulicher Brandschutz
  'Universitaet Kaiserslautern Band 1: Der Einfluss des Grundwassers auf den Waermeverlust erdreichberuehrter Bauteile
  'Autor: Karl - Heinz Dahlem
  'November 2000
  'ISSN 1616 - 5039
  'ISBN 3 – 925178 – 49 - X
  Dim fltV0 As Float 'jaehrliche mittlere Erdreichoberflaechentemperatur °C
  Dim conG As Float = 0.03 'geothermischer Gradient K/m
  Dim conz As Float = 1.25 'Tiefe im Erdreich m
  Dim fltV1 As Float  'Amplitude der Erdreichoberflächentemperatur K
  Dim cona As Float = 0.00000125 'Temperaturleitfähigkeit des Erdreichs m2/s
  Dim cont0 As Integer = 365 'Periode der Cosinusfunktion d
  Dim fltTemp As Float
  
  
  fltV1 = CFloat(Global.strDatensatzKlimaTag[3, 0]) - CFloat(Global.strDatensatzKlimaTag[2, 0])
  fltV0 = CFloat(Global.strDatensatzKlimaTag[3, 0])
  fltTemp = fltV0 + conG * conz + fltV1 * Exp(-conz * Sqr(Pi() / (60 * 60 * 24 * cona * cont0))) * Cos(conz * Sqr(Pi() / (60 * 60 * 24 * cona * cont0)) - 2 * Pi() * (180 + intStunde / 24) / cont0)
   
  Return Round(fltTemp, -2)
  
End



Public Function funQStd(KW As Float, TYP As String, intStunde As Integer) As Float
  Dim hV As Float
  Dim V, V1, V2 As Float
  Dim F As Float
  Dim SF As Float
  Dim intGebLP As Integer
  Dim intAuspraegung As Integer
  Dim A, B, C, D, mH, bH, mW, bW As Float
  Dim WT, da, mo, ce, ye As Integer
  Dim intJahr As Integer
  Dim SV1, SV2 As Float
  
  
  intJahr = CInt(Global.strTagStart[2])
  
  Select Case TYP
    Case "EFH"
      intGebLP = 0
      intAuspraegung = 2
    Case "DHH"
      intGebLP = 0
      intAuspraegung = 2
    Case "RH"
      intGebLP = 0
      intAuspraegung = 2
    Case "MFH"
      intGebLP = 1
      intAuspraegung = 2
    Case "MFH2"
      intGebLP = 1
      intAuspraegung = 2
    Case "HEF"
      intGebLP = 0
      intAuspraegung = 2
    Case "HMF"
      intGebLP = 1
      intAuspraegung = 2
    Case "GKO"
      intGebLP = 2
      intAuspraegung = 2
    Case "GHA"
      intGebLP = 3
      intAuspraegung = 2
    Case "GMK"
      intGebLP = 4
      intAuspraegung = 2
    Case "GBD"
      intGebLP = 5
      intAuspraegung = 2
    Case "GGA"
      intGebLP = 6
      intAuspraegung = 2
    Case "GBH"
      intGebLP = 7
      intAuspraegung = 2
    Case "GBA"
      intGebLP = 8
      intAuspraegung = 2
    Case "GWA"
      intGebLP = 9
      intAuspraegung = 2
    Case "GGB"
      intGebLP = 10
      intAuspraegung = 2
    Case "GPD"
      intGebLP = 11
      intAuspraegung = 2
    Case "GMF"
      intGebLP = 12
      intAuspraegung = 2
    Case "GHD"
      intGebLP = 13
      intAuspraegung = 2
    Case "HEF33"
      intGebLP = 0
      intAuspraegung = 2
    Case "HMF33"
      intGebLP = 1
      intAuspraegung = 2
    Case "GKO33"
      intGebLP = 2
      intAuspraegung = 2
    Case "GHA33"
      intGebLP = 3
      intAuspraegung = 2
    Case "GMK33"
      intGebLP = 4
      intAuspraegung = 2
    Case "GBD33"
      intGebLP = 5
      intAuspraegung = 2
    Case "GGA33"
      intGebLP = 6
      intAuspraegung = 2
    Case "GBH33"
      intGebLP = 7
      intAuspraegung = 2
    Case "GBA33"
      intGebLP = 8
      intAuspraegung = 2
    Case "GWA33"
      intGebLP = 9
      intAuspraegung = 2
    Case "GGB33"
      intGebLP = 10
      intAuspraegung = 2
    Case "GPD33"
      intGebLP = 11
      intAuspraegung = 2
    Case "GMF33"
      intGebLP = 12
      intAuspraegung = 2
    Case "GHD33"
      intGebLP = 13
      intAuspraegung = 2
    Case "HEF34"
      intGebLP = 0
      intAuspraegung = 3
    Case "HMF34"
      intGebLP = 1
      intAuspraegung = 3
    Case "GKO34"
      intGebLP = 2
      intAuspraegung = 3
    Case "GHA34"
      intGebLP = 3
      intAuspraegung = 3
    Case "GMK34"
      intGebLP = 4
      intAuspraegung = 3
    Case "GBD34"
      intGebLP = 5
      intAuspraegung = 3
    Case "GGA34"
      intGebLP = 6
      intAuspraegung = 3
    Case "GBH34"
      intGebLP = 7
      intAuspraegung = 3
    Case "GBA34"
      intGebLP = 8
      intAuspraegung = 3
    Case "GWA34"
      intGebLP = 9
      intAuspraegung = 3
    Case "GGB34"
      intGebLP = 10
      intAuspraegung = 3
    Case "GPD34"
       intGebLP = 11
       intAuspraegung = 3
     Case "GMF34"
       intGebLP = 12
       intAuspraegung = 3
     Case "GHD34"
       intGebLP = 13
       intAuspraegung = 3
     Case Else
       intGebLP = 1
       intAuspraegung = 2
  End Select
  
  
    A = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 0]
    B = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 1]
    C = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 2]
    D = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 3]
    mH = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 4]
    bH = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 5]
    mW = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 6]
    bW = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 7]
        
    'DS = D * fltVersorgungsgrad
    
    V = CFloat(global.strDatensatzKlimaTag[0, Int(intStunde / 24) + 1])

  
    hV = funSigmoid(A, B, C, D, mH, bH, mW, bW, V, 40)
    
  
  da = CFloat(global.strDatensatzKlimaTag[1, Int(intStunde / 24) + 1])
  mo = CFloat(global.strDatensatzKlimaTag[2, Int(intStunde / 24) + 1])
  ce = Left$(CStr(intJahr), 2)
  ye = Right$(CStr(intJahr), 2)
    
  WT = funGaussWT(da, mo, ce, ye) 'Montag = 1
  
    F = Global.fltLastprofileWTFaktor[intGebLP, WT - 1]

'STATIC PUBLIC fltLastprofilehVerteilung AS NEW Float[14, 7, 10, 24] '[Profil, Wochentag, Stütztemp, Stunde]
  'TEMPERATUR
  'global.strDatensatzKlimaStunde[0, intStunde]
  'global.strDatensatzKlimaTag[0, int(intStunde/24)+1]
  'STUNDE AM TAG (1 - 24)-1
  'CInt(global.strDatensatzKlimaStunde[1, intStunde]) - 1
  '(frac(intStunde+1)*24)-1
  
  Select Case CFloat(global.strDatensatzKlimaTag[0, Int(intStunde / 24) + 1])
    Case -1000 To -17.5
      SF = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 0, (Frac((intStunde) / 24) * 24)] / 100
    Case -17.5 To -12.5
      V1 = -17.5
      V2 = -12.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 0, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 1, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case -12.5 To -7.5
      V1 = -12.5
      V2 = -7.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 1, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 2, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case -7.5 To -2.5
      V1 = -7.5
      V2 = -2.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 2, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 3, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case -2.5 To 2.5
      V1 = -2.5
      V2 = 2.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 3, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 4, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 2.5 To 7.5
      V1 = 2.5
      V2 = 7.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 4, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 5, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 7.5 To 12.5
      V1 = 7.5
      V2 = 12.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 5, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 6, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 12.5 To 17.5
      V1 = 12.5
      V2 = 17.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 6, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 7, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 17.5 To 22.5
      V1 = 17.5
      V2 = 22.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 7, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 8, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 22.5 To 27.5
      V1 = 22.5
      V2 = 27.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 8, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 9, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 27.5 To 1000
      SF = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 9, (Frac((intStunde) / 24) * 24)] / 100
  End Select
  'Ausgabe mit mindestens 0,50 Watt
  If KW * hV * F * SF < 0.0005 Then
    Return 0.0005
  Else
    Return KW * hV * F * SF
  Endif
End


Public Function funQStd_Heizgrenze(KW As Float, TYP As String, intStunde As Integer) As Float
  Dim hV As Float
  Dim V, V1, V2 As Float
  Dim F As Float
  Dim SF As Float
  Dim intGebLP As Integer
  Dim intAuspraegung As Integer
  Dim A, B, C, D, mH, bH, mW, bW As Float
  Dim WT, da, mo, ce, ye As Integer
  Dim intJahr As Integer
  Dim SV1, SV2 As Float
  
  
  intJahr = CInt(Global.strTagStart[2])
  
  Select Case TYP
    Case "EFH"
      intGebLP = 0
      intAuspraegung = 2
    Case "DHH"
      intGebLP = 0
      intAuspraegung = 2
    Case "RH"
      intGebLP = 0
      intAuspraegung = 2
    Case "MFH"
      intGebLP = 1
      intAuspraegung = 2
    Case "MFH2"
      intGebLP = 1
      intAuspraegung = 2
    Case "HEF"
      intGebLP = 0
      intAuspraegung = 2
    Case "HMF"
      intGebLP = 1
      intAuspraegung = 2
    Case "GKO"
      intGebLP = 2
      intAuspraegung = 2
    Case "GHA"
      intGebLP = 3
      intAuspraegung = 2
    Case "GMK"
      intGebLP = 4
      intAuspraegung = 2
    Case "GBD"
      intGebLP = 5
      intAuspraegung = 2
    Case "GGA"
      intGebLP = 6
      intAuspraegung = 2
    Case "GBH"
      intGebLP = 7
      intAuspraegung = 2
    Case "GBA"
      intGebLP = 8
      intAuspraegung = 2
    Case "GWA"
      intGebLP = 9
      intAuspraegung = 2
    Case "GGB"
      intGebLP = 10
      intAuspraegung = 2
    Case "GPD"
      intGebLP = 11
      intAuspraegung = 2
    Case "GMF"
      intGebLP = 12
      intAuspraegung = 2
    Case "GHD"
      intGebLP = 13
      intAuspraegung = 2
    Case "HEF33"
      intGebLP = 0
      intAuspraegung = 2
    Case "HMF33"
      intGebLP = 1
      intAuspraegung = 2
    Case "GKO33"
      intGebLP = 2
      intAuspraegung = 2
    Case "GHA33"
      intGebLP = 3
      intAuspraegung = 2
    Case "GMK33"
      intGebLP = 4
      intAuspraegung = 2
    Case "GBD33"
      intGebLP = 5
      intAuspraegung = 2
    Case "GGA33"
      intGebLP = 6
      intAuspraegung = 2
    Case "GBH33"
      intGebLP = 7
      intAuspraegung = 2
    Case "GBA33"
      intGebLP = 8
      intAuspraegung = 2
    Case "GWA33"
      intGebLP = 9
      intAuspraegung = 2
    Case "GGB33"
      intGebLP = 10
      intAuspraegung = 2
    Case "GPD33"
      intGebLP = 11
      intAuspraegung = 2
    Case "GMF33"
      intGebLP = 12
      intAuspraegung = 2
    Case "GHD33"
      intGebLP = 13
      intAuspraegung = 2
    Case "HEF34"
      intGebLP = 0
      intAuspraegung = 3
    Case "HMF34"
      intGebLP = 1
      intAuspraegung = 3
    Case "GKO34"
      intGebLP = 2
      intAuspraegung = 3
    Case "GHA34"
      intGebLP = 3
      intAuspraegung = 3
    Case "GMK34"
      intGebLP = 4
      intAuspraegung = 3
    Case "GBD34"
      intGebLP = 5
      intAuspraegung = 3
    Case "GGA34"
      intGebLP = 6
      intAuspraegung = 3
    Case "GBH34"
      intGebLP = 7
      intAuspraegung = 3
    Case "GBA34"
      intGebLP = 8
      intAuspraegung = 3
    Case "GWA34"
      intGebLP = 9
      intAuspraegung = 3
    Case "GGB34"
      intGebLP = 10
      intAuspraegung = 3
    Case "GPD34"
       intGebLP = 11
       intAuspraegung = 3
     Case "GMF34"
       intGebLP = 12
       intAuspraegung = 3
     Case "GHD34"
       intGebLP = 13
       intAuspraegung = 3
     Case Else
       intGebLP = 1
       intAuspraegung = 2
  End Select
  
  
 A = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 0]
    B = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 1]
    C = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 2]
    D = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 3]
    mH = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 4]
    bH = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 5]
    mW = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 6]
    bW = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 7]
        
    'DS = D * fltVersorgungsgrad
    
    V = Global.conHeizGrenzTemperaturTWW
  
    hV = funSigmoid(A, B, C, D, mH, bH, mW, bW, V, 40)
    
  'global.strDatensatzKlimaTag[1, Int(intStunde / 24)+1]
  'global.strDatensatzKlimaTag[1, Int(intStunde / 24)+1]  
  
  da = CFloat(global.strDatensatzKlimaTag[1, Int(intStunde / 24) + 1])
  mo = CFloat(global.strDatensatzKlimaTag[2, Int(intStunde / 24) + 1])
  ce = Left$(CStr(intJahr), 2)
  ye = Right$(CStr(intJahr), 2)
    
  WT = funGaussWT(da, mo, ce, ye) 'Montag = 1
  
    F = Global.fltLastprofileWTFaktor[intGebLP, WT - 1]

'STATIC PUBLIC fltLastprofilehVerteilung AS NEW Float[14, 7, 10, 24] '[Profil, Wochentag, Stütztemp, Stunde]
  Select Case CFloat(global.strDatensatzKlimaTag[0, Int(intStunde / 24) + 1])
    Case -1000 To -17.5
      SF = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 0, (Frac((intStunde) / 24) * 24)] / 100
    Case -17.5 To -12.5
      V1 = -17.5
      V2 = -12.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 0, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 1, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case -12.5 To -7.5
      V1 = -12.5
      V2 = -7.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 1, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 2, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case -7.5 To -2.5
      V1 = -7.5
      V2 = -2.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 2, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 3, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case -2.5 To 2.5
      V1 = -2.5
      V2 = 2.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 3, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 4, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 2.5 To 7.5
      V1 = 2.5
      V2 = 7.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 4, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 5, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 7.5 To 12.5
      V1 = 7.5
      V2 = 12.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 5, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 6, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 12.5 To 17.5
      V1 = 12.5
      V2 = 17.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 6, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 7, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 17.5 To 22.5
      V1 = 17.5
      V2 = 22.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 7, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 8, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 22.5 To 27.5
      V1 = 22.5
      V2 = 27.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 8, (Frac((intStunde) / 24) * 24)] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 9, (Frac((intStunde) / 24) * 24)] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 27.5 To 1000
      SF = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 9, (Frac((intStunde) / 24) * 24)] / 100
  End Select
  'Ausgabe mit mindestens 0,50 Watt
  If KW * hV * F * SF < 0.0005 Then
    Return 0.0005
  Else
    Return KW * hV * F * SF
  Endif
End


Public Function funQStd_Dimensionierung(KW As Float, TYP As String, V As Float) As Float
  Dim hV As Float
  Dim V1, V2 As Float
  Dim F As Float
  Dim SF As Float
  Dim intGebLP As Integer
  Dim intAuspraegung As Integer
  Dim A, B, C, D, mH, bH, mW, bW As Float
  Dim WT As Integer
 
  Dim SV1, SV2 As Float
  
  Select Case TYP
    Case "EFH"
      intGebLP = 0
      intAuspraegung = 2
    Case "DHH"
      intGebLP = 0
      intAuspraegung = 2
    Case "RH"
      intGebLP = 0
      intAuspraegung = 2
    Case "MFH"
      intGebLP = 1
      intAuspraegung = 2
    Case "MFH2"
      intGebLP = 1
      intAuspraegung = 2
    Case "HEF"
      intGebLP = 0
      intAuspraegung = 2
    Case "HMF"
      intGebLP = 1
      intAuspraegung = 2
    Case "GKO"
      intGebLP = 2
      intAuspraegung = 2
    Case "GHA"
      intGebLP = 3
      intAuspraegung = 2
    Case "GMK"
      intGebLP = 4
      intAuspraegung = 2
    Case "GBD"
      intGebLP = 5
      intAuspraegung = 2
    Case "GGA"
      intGebLP = 6
      intAuspraegung = 2
    Case "GBH"
      intGebLP = 7
      intAuspraegung = 2
    Case "GBA"
      intGebLP = 8
      intAuspraegung = 2
    Case "GWA"
      intGebLP = 9
      intAuspraegung = 2
    Case "GGB"
      intGebLP = 10
      intAuspraegung = 2
    Case "GPD"
      intGebLP = 11
      intAuspraegung = 2
    Case "GMF"
      intGebLP = 12
      intAuspraegung = 2
    Case "GHD"
      intGebLP = 13
      intAuspraegung = 2
    Case "HEF33"
      intGebLP = 0
      intAuspraegung = 2
    Case "HMF33"
      intGebLP = 1
      intAuspraegung = 2
    Case "GKO33"
      intGebLP = 2
      intAuspraegung = 2
    Case "GHA33"
      intGebLP = 3
      intAuspraegung = 2
    Case "GMK33"
      intGebLP = 4
      intAuspraegung = 2
    Case "GBD33"
      intGebLP = 5
      intAuspraegung = 2
    Case "GGA33"
      intGebLP = 6
      intAuspraegung = 2
    Case "GBH33"
      intGebLP = 7
      intAuspraegung = 2
    Case "GBA33"
      intGebLP = 8
      intAuspraegung = 2
    Case "GWA33"
      intGebLP = 9
      intAuspraegung = 2
    Case "GGB33"
      intGebLP = 10
      intAuspraegung = 2
    Case "GPD33"
      intGebLP = 11
      intAuspraegung = 2
    Case "GMF33"
      intGebLP = 12
      intAuspraegung = 2
    Case "GHD33"
      intGebLP = 13
      intAuspraegung = 2
    Case "HEF34"
      intGebLP = 0
      intAuspraegung = 3
    Case "HMF34"
      intGebLP = 1
      intAuspraegung = 3
    Case "GKO34"
      intGebLP = 2
      intAuspraegung = 3
    Case "GHA34"
      intGebLP = 3
      intAuspraegung = 3
    Case "GMK34"
      intGebLP = 4
      intAuspraegung = 3
    Case "GBD34"
      intGebLP = 5
      intAuspraegung = 3
    Case "GGA34"
      intGebLP = 6
      intAuspraegung = 3
    Case "GBH34"
      intGebLP = 7
      intAuspraegung = 3
    Case "GBA34"
      intGebLP = 8
      intAuspraegung = 3
    Case "GWA34"
      intGebLP = 9
      intAuspraegung = 3
    Case "GGB34"
      intGebLP = 10
      intAuspraegung = 3
    Case "GPD34"
       intGebLP = 11
       intAuspraegung = 3
     Case "GMF34"
       intGebLP = 12
       intAuspraegung = 3
     Case "GHD34"
       intGebLP = 13
       intAuspraegung = 3
     Case Else
       intGebLP = 1
       intAuspraegung = 2
  End Select
  
    A = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 0]
    B = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 1]
    C = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 2]
    D = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 3]
    mH = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 4]
    bH = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 5]
    mW = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 6]
    bW = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 7]
        
    'DS = D * fltVersorgungsgrad
  
  
    hV = funSigmoid(A, B, C, D, mH, bH, mW, bW, V, 40)
        
  WT = 1 'Montag = 1
  
    F = Global.fltLastprofileWTFaktor[intGebLP, WT - 1]

'STATIC PUBLIC fltLastprofilehVerteilung AS NEW Float[14, 7, 10, 24] '[Profil, Wochentag, Stütztemp, Stunde]
  Select Case V
    Case -1000 To -17.5
      SF = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 0, 7] / 100 'Stunde 6
    Case -17.5 To -12.5
      V1 = -17.5
      V2 = -12.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 0, 7] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 1, 7] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case -12.5 To -7.5
      V1 = -12.5
      V2 = -7.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 1, 7] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 2, 7] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case -7.5 To -2.5
      V1 = -7.5
      V2 = -2.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 2, 7] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 3, 7] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case -2.5 To 2.5
      V1 = -2.5
      V2 = 2.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 3, 7] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 4, 7] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 2.5 To 7.5
      V1 = 2.5
      V2 = 7.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 4, 7] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 5, 7] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 7.5 To 12.5
      V1 = 7.5
      V2 = 12.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 5, 7] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 6, 7] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 12.5 To 17.5
      V1 = 12.5
      V2 = 17.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 6, 7] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 7, 7] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 17.5 To 22.5
      V1 = 17.5
      V2 = 22.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 7, 7] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 8, 7] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 22.5 To 27.5
      V1 = 22.5
      V2 = 27.5
      SV1 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 8, 7] / 100
      SV2 = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 9, 7] / 100
      SF = SV1 + (SV2 - SV1) * ((V - V1) / (V2 - V1))
    Case 27.5 To 1000
      SF = Global.fltLastprofilehVerteilung[intGebLP, WT - 1, 9, 7] / 100
  End Select
  'Ausgabe mit mindestens 0,50 Watt
  If (Global.fltAuslegungsfaktor / 100) * KW * hV * F * SF < 0.0005 Then
    Return 0.0005
  Else
    Return (Global.fltAuslegungsfaktor / 100) * KW * hV * F * SF
  Endif
End




Public Function funInterpolation(fltIn1 As Float, fltIn2 As Float, fltOut1 As Float, fltOut2 As Float, fltWert As Float) As Float
  Dim Ergebnis As Float
  Dim fltIn3, fltIn4, fltWert2 As Float
  If fltIn2 = fltIn1 Then
    Ergebnis = fltIn1
  Else
  fltIn3 = funSigmoid(3.047, -37.2, 5.67, 0.0962, fltIn1, 40)
  fltIn4 = funSigmoid(3.047, -37.2, 5.67, 0.0962, fltIn2, 40)
  fltWert2 = funSigmoid(3.047, -37.2, 5.67, 0.0962, fltWert, 40)
  'Ergebnis = (fltWert2 / fltIn4) * fltOut2 
  Ergebnis = fltOut1 + ((fltOut2 - fltOut1) * ((fltWert2 - fltIn3) / (fltIn4 - fltIn3)))
  Endif
  Return Ergebnis
End



Public Sub Erzeuge_NetzTrasse()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strDatensatzNetzTrasse As New String[Global.conSpaltenTrasse, Global.conMaxDatensaetze]
Dim strDatensatzNetzTrasseMIF As New String[Global.conMaxDatensaetze * 3 + 5 + Global.conSpaltenTrasse]
Dim strDatensatzNetzTrasseMIFtemp As New String[Global.conMaxDatensaetze * 3 + 5 + Global.conSpaltenTrasse]
Dim intZeilenNetzTrasse, intZeilenNetzTrasseMIF, intZeilenNetzTrasseMIFtemp As Integer
Dim a, b, c, d, i, j, z As Integer


'--------------------DATEN EINLESEN---------------------------------  
  b = 0
  hsDatei = Open Global.strPfadTrassendatei For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzNetzTrasseMIFtemp[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenNetzTrasseMIFtemp = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF
'--------------------DATEN EINLESEN ENDE---------------------------------



'-----------------Erzeuge strNetzTrasseMIF als NetzTrasse.MIF----------------
  strDatensatzNetzTrasseMIF[0] = "Version 300"
  strDatensatzNetzTrasseMIF[1] = "Charset" & Chr(34) & "WindowsLatin1" & Chr(34)
  strDatensatzNetzTrasseMIF[2] = "Columns " & CStr(Global.conSpaltenTrasse)
  strDatensatzNetzTrasseMIF[3] = "  AK integer"
  strDatensatzNetzTrasseMIF[4] = "  EK integer"
  strDatensatzNetzTrasseMIF[5] = "  L float"
  strDatensatzNetzTrasseMIF[6] = "  DU float"
  strDatensatzNetzTrasseMIF[7] = "  MS float"
  strDatensatzNetzTrasseMIF[8] = "  DELPO float"
  strDatensatzNetzTrasseMIF[9] = "  KO float"
  strDatensatzNetzTrasseMIF[10] = "  DiffDruck float"
  strDatensatzNetzTrasseMIF[11] = "  Mitteltemperatur_VL float"
  strDatensatzNetzTrasseMIF[12] = "  Mitteltemperatur_RL float"
  strDatensatzNetzTrasseMIF[13] = "  QWaermeabs_VL float"
  strDatensatzNetzTrasseMIF[14] = "  QWaermeabs_RL float"
  strDatensatzNetzTrasseMIF[15] = "  QWaermespez_VL float"
  strDatensatzNetzTrasseMIF[16] = "  QWaermespez_RL float"
  strDatensatzNetzTrasseMIF[17] = "  DU2a float"
  strDatensatzNetzTrasseMIF[18] = "  MS2a float"
  strDatensatzNetzTrasseMIF[19] = "  DELPO2a float"
  strDatensatzNetzTrasseMIF[20] = "  KO2a float"
  strDatensatzNetzTrasseMIF[21] = "  DiffDruck2a float"
  strDatensatzNetzTrasseMIF[22] = "  Mitteltemperatur_VL2a float"
  strDatensatzNetzTrasseMIF[23] = "  Mitteltemperatur_RL2a float"
  strDatensatzNetzTrasseMIF[24] = "  QWaermeabs_VL2a float"
  strDatensatzNetzTrasseMIF[25] = "  QWaermeabs_RL2a float"
  strDatensatzNetzTrasseMIF[26] = "  QWaermespez_VL2a float"
  strDatensatzNetzTrasseMIF[27] = "  QWaermespez_RL2a float"
  strDatensatzNetzTrasseMIF[28] = "  DU2b float"
  strDatensatzNetzTrasseMIF[29] = "  MS2b float"
  strDatensatzNetzTrasseMIF[30] = "  DELPO2b float"
  strDatensatzNetzTrasseMIF[31] = "  KO2b float"
  strDatensatzNetzTrasseMIF[32] = "  DiffDruck2b float"
  strDatensatzNetzTrasseMIF[33] = "  Mitteltemperatur_VL2b float"
  strDatensatzNetzTrasseMIF[34] = "  Mitteltemperatur_RL2b float"
  strDatensatzNetzTrasseMIF[35] = "  QWaermeabs_VL2b float"
  strDatensatzNetzTrasseMIF[36] = "  QWaermeabs_RL2b float"
  strDatensatzNetzTrasseMIF[37] = "  QWaermespez_VL2b float"
  strDatensatzNetzTrasseMIF[38] = "  QWaermespez_RL2b float"
  strDatensatzNetzTrasseMIF[39] = "  VorDim integer"
  strDatensatzNetzTrasseMIF[40] = "  leer float"
  strDatensatzNetzTrasseMIF[41] = "  leer float"
  strDatensatzNetzTrasseMIF[42] = "  leer float"
  strDatensatzNetzTrasseMIF[43] = ""
  strDatensatzNetzTrasseMIF[44] = "DATA"
  
  z = 0
  j = Global.conSpaltenTrasse + 5
  For i = 0 To intZeilenNetzTrasseMIFtemp - 1
    'wenn Line
    If Left$(strDatensatzNetzTrasseMIFtemp[i], 4) = "Line" Or Left$(strDatensatzNetzTrasseMIFtemp[i], 4) = "LINE" Then
      a = funStringStelleLeer01(strDatensatzNetzTrasseMIFtemp[i])
      b = funStringStelleLeer02(strDatensatzNetzTrasseMIFtemp[i])
      c = funStringStelleLeer03(strDatensatzNetzTrasseMIFtemp[i])
      d = funStringStelleLeer04(strDatensatzNetzTrasseMIFtemp[i])
          
      strDatensatzNetzTrasseMIF[j] = "PLINE   2"
      j += 1
      strDatensatzNetzTrasseMIF[j] = funRundenSTR(CStr(CFloat(Mid$(strDatensatzNetzTrasseMIFtemp[i], a, b - a - 1))), Global.conROUND) & " " & funRundenSTR(CStr(CFloat(Mid$(strDatensatzNetzTrasseMIFtemp[i], b, c - b - 1))), Global.conROUND)
      j += 1
      strDatensatzNetzTrasseMIF[j] = funRundenSTR(CStr(CFloat(Mid$(strDatensatzNetzTrasseMIFtemp[i], c, d - c - 1))), Global.conROUND) & " " & funRundenSTR(CStr(CFloat(Right$(strDatensatzNetzTrasseMIFtemp[i], -d + 1))), Global.conROUND)
      j += 1
    Endif
    
    'wenn Pline
    'z zählt die Anzahl Punkte herunter
    If z > 0 Then
      a = funStringStelleLeer01(strDatensatzNetzTrasseMIFtemp[i])
      strDatensatzNetzTrasseMIF[j] = funRundenSTR(Left$(strDatensatzNetzTrasseMIFtemp[i], a - 2), Global.conROUND) & " " & funRundenSTR(Right$(strDatensatzNetzTrasseMIFtemp[i], -(a - 1)), Global.conROUND)
      z -= 1
      j += 1
    Endif
     
    If Left$(strDatensatzNetzTrasseMIFtemp[i], 5) = "Pline" Or Left$(strDatensatzNetzTrasseMIFtemp[i], 5) = "PLINE" Then
      z = CInt(Right$(strDatensatzNetzTrasseMIFtemp[i], -6))
      strDatensatzNetzTrasseMIF[j] = "PLINE   " & CStr(z)
      j += 1
    Endif
    
  Next
  intZeilenNetzTrasseMIF = j

  a = 0
  For j = 0 To intZeilenNetzTrasse - 1
    If Left$(strDatensatzNetzTrasseMIF[j], 5) = "PLINE" Then a += 1
  Next
  intZeilenNetzTrasse = a - 1
'-----------------Erzeuge strNetzTrasseMIF als NetzTrasse.MIF ENDE----------------




'-----------------Erzeuge strNetzTrasse als NetzTrasse.MID----------------
  a = 0
  For i = 0 To intZeilenNetzTrasseMIF - 1
    If Left$(strDatensatzNetzTrasseMIF[i], 5) = "PLINE" Then
      For j = 0 To Global.conSpaltenTrasse - 1
        strDatensatzNetzTrasse[j, a] = "0"
      Next
      a += 1
    Endif
  Next
  intZeilenNetzTrasse = a
'-----------------Erzeuge strNetzTrasse als NetzTrasse.MID ENDE----------------  


  
'-------Schreibe Dateien zurück------------------------------------------
  'Schreibe NetzTrasse.MIF
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MIF" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenNetzTrasseMIF - 1 'intZeilenNetzTrasseMIF
    strZeile = strDatensatzNetzTrasseMIF[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  
  'Schreibe NetzTrasse.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenNetzTrasse - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenTrasse - 2
      strZeile &= strDatensatzNetzTrasse[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzNetzTrasse[Global.conSpaltenTrasse - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
'-------Schreibe Dateien zurück ENDE------------------------------------------
End


Public Sub Erzeuge_NetzTrasseSimulationsErgebnis(strDatei As String)
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strDatensatzNetzTrasseSimulationsErgebnisMIF As New String[Global.conMaxDatensaetze * 3 + 5 + Global.conSpaltenTrasseSimulationsErgebnis]
Dim intZeilenNetzTrasseSimulationsErgebnisMIF As Integer
Dim i, j As Integer
Dim intDifferenz As Integer

'Wichtig ist, dass nun die globale Variable Global.strDatensatzNetzTrasseMIF bereits eingelesen wurde!!!!!

intZeilenNetzTrasseSimulationsErgebnisMIF = 32

'-----------------Erzeuge strDatensatzNetzTrasseSimulationsErgebnisMIF----------------
  strDatensatzNetzTrasseSimulationsErgebnisMIF[0] = "Version 300"
  strDatensatzNetzTrasseSimulationsErgebnisMIF[1] = "Charset" & Chr(34) & "WindowsLatin1" & Chr(34)
  strDatensatzNetzTrasseSimulationsErgebnisMIF[2] = "Columns " & CStr(Global.conSpaltenTrasseSimulationsErgebnis)
  strDatensatzNetzTrasseSimulationsErgebnisMIF[3] = "  AK integer"        '00
  strDatensatzNetzTrasseSimulationsErgebnisMIF[4] = "  EK integer"        '01
  strDatensatzNetzTrasseSimulationsErgebnisMIF[5] = "  L float"           '02
  strDatensatzNetzTrasseSimulationsErgebnisMIF[6] = "  DU float"          '03
  strDatensatzNetzTrasseSimulationsErgebnisMIF[7] = "  QTrAbsSum float"   '04
  strDatensatzNetzTrasseSimulationsErgebnisMIF[8] = "  QTrSpeSum float"   '05
  strDatensatzNetzTrasseSimulationsErgebnisMIF[9] = "  QVeAbsSum float"   '06
  strDatensatzNetzTrasseSimulationsErgebnisMIF[10] = "  QVeAbsVL float"   '07
  strDatensatzNetzTrasseSimulationsErgebnisMIF[11] = "  QVeAbsRL float"   '08
  strDatensatzNetzTrasseSimulationsErgebnisMIF[12] = "  QVeSpeSum float"  '09
  strDatensatzNetzTrasseSimulationsErgebnisMIF[13] = "  DU2a float"         '10
  strDatensatzNetzTrasseSimulationsErgebnisMIF[14] = "  QTrAbsSum2a float"  '11
  strDatensatzNetzTrasseSimulationsErgebnisMIF[15] = "  QTrSpeSum2a float"  '12
  strDatensatzNetzTrasseSimulationsErgebnisMIF[16] = "  QVeAbsSum2a float"  '13
  strDatensatzNetzTrasseSimulationsErgebnisMIF[17] = "  QVeAbsVL2a float"   '14
  strDatensatzNetzTrasseSimulationsErgebnisMIF[18] = "  QVeAbsRL2a float"   '15
  strDatensatzNetzTrasseSimulationsErgebnisMIF[19] = "  QVeSpeSum2a float"  '16
  strDatensatzNetzTrasseSimulationsErgebnisMIF[20] = "  DU2b float"         '17
  strDatensatzNetzTrasseSimulationsErgebnisMIF[21] = "  QTrAbsSum2b float"  '18 (11)
  strDatensatzNetzTrasseSimulationsErgebnisMIF[22] = "  QTrSpeSum2b float"  '19 (12)
  strDatensatzNetzTrasseSimulationsErgebnisMIF[23] = "  QVeAbsSum2b float"  '20 (13)
  strDatensatzNetzTrasseSimulationsErgebnisMIF[24] = "  QVeAbsVL2b float"   '21 (14)
  strDatensatzNetzTrasseSimulationsErgebnisMIF[25] = "  QVeAbsRL2b float"   '22 (15)
  strDatensatzNetzTrasseSimulationsErgebnisMIF[26] = "  QVeSpeSum2a float"  '23 (16)
  strDatensatzNetzTrasseSimulationsErgebnisMIF[27] = "  QVeProzent float"   '24
  strDatensatzNetzTrasseSimulationsErgebnisMIF[28] = "  QVeProzent2a float" '25
  strDatensatzNetzTrasseSimulationsErgebnisMIF[29] = "  QVeProzent2b float" '26
  strDatensatzNetzTrasseSimulationsErgebnisMIF[30] = ""
  strDatensatzNetzTrasseSimulationsErgebnisMIF[31] = "DATA"
  
  intDifferenz = Global.conSpaltenTrasse - Global.conSpaltenTrasseSimulationsErgebnis
  
  For i = 32 To 32 + intDifferenz + Global.intZeilenNetzTrasse * 3
    strDatensatzNetzTrasseSimulationsErgebnisMIF[i] = Global.strDatensatzNetzTrasseMIF[i + intDifferenz]
    intZeilenNetzTrasseSimulationsErgebnisMIF += 1
  Next
  

  
'-------Schreibe Dateien zurück------------------------------------------
  'Schreibe NetzTrasse.MIF
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasseSimulationsErgebnis & "_" & strDatei & ".MIF" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenNetzTrasseSimulationsErgebnisMIF - 1 'intZeilenNetzTrasseSimErMIF
    strZeile = strDatensatzNetzTrasseSimulationsErgebnisMIF[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  
  'Schreibe NetzTrasse.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasseSimulationsErgebnis & "_" & strDatei & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To Global.intZeilenNetzTrasse - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenTrasseSimulationsErgebnis - 2
      strZeile &= Global.strDatensatzNetzTrasseSimulationsErgebnis[j, i] & Chr$(9)
    Next
    strZeile &= Global.strDatensatzNetzTrasseSimulationsErgebnis[Global.conSpaltenTrasseSimulationsErgebnis - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
'-------Schreibe Dateien zurück ENDE------------------------------------------
End

Public Sub schreibeSimTempCSV(intStart As Integer, intEnde As Integer)
  Dim hsDatei As Stream
  Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen  
  Dim i As Integer
  
  'Schreibe Temperaturen
  hsDatei = Open Global.strtxbPfad & "TempVL-RL.CSV" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To (intEnde - intStart) 'Stunden im Jahr
    strZeile = CStr(global.fltSimVLTemp[i]) & ";" & CStr(global.fltSimRLTemp[i])
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
End


Public Sub Bereinige_AbnehmerMIF()  'delimiter aus ogr2ogr Umwandlung löschen
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strDatensatzAbnehmerMIFtemp As New String[Global.conMaxDatensaetze * 3 + 13]
Dim intZeilenAbnehmerMIFtemp As Integer
Dim b, i As Integer


'--------------------DATEN EINLESEN---------------------------------  
  b = 0
  hsDatei = Open Global.strPfadAbnehmerdatei For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    If Left$(strZeile, 5) <> "Delim" Then
      strDatensatzAbnehmerMIFtemp[b] = Replace$(strZeile, "\r", "")
      b = b + 1   'die Zeilennummer wird um 1 erhöht
    Endif
  Wend
  intZeilenAbnehmerMIFtemp = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF
'--------------------DATEN EINLESEN ENDE---------------------------------

  
'-------Schreibe Dateien zurück------------------------------------------
  'Schreibe Abnehmer.MIF
  hsDatei = Open Global.strPfadAbnehmerdatei For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenAbnehmerMIFtemp - 1 'intZeilenNetzTrasseMIF
    strZeile = strDatensatzAbnehmerMIFtemp[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
'-------Schreibe Dateien zurück ENDE------------------------------------------
End



Public Sub Erzeuge_AbnehmerMIF()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strDatensatzAbnehmerMIF As New String[Global.conMaxDatensaetze * 3 + 13]
Dim strDatensatzAbnehmerMIFtemp As New String[Global.conMaxDatensaetze * 3 + 13]
Dim intZeilenAbnehmerMIF, intZeilenAbnehmerMIFtemp As Integer
Dim a, b, i, j, z As Integer


'--------------------DATEN EINLESEN---------------------------------  
  b = 0
  hsDatei = Open Global.strPfadAbnehmerdatei For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzAbnehmerMIFtemp[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenAbnehmerMIFtemp = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF
'--------------------DATEN EINLESEN ENDE---------------------------------



'-----------------Erzeuge strNetzTrasseMIF als NetzTrasse.MIF----------------
  strDatensatzAbnehmerMIF[0] = "Version 300"
  strDatensatzAbnehmerMIF[1] = "Charset" & Chr(34) & "WindowsLatin1" & Chr(34)
  strDatensatzAbnehmerMIF[2] = "Columns 8"
  strDatensatzAbnehmerMIF[3] = "  PMAX float"
  strDatensatzAbnehmerMIF[4] = "  Q float"
  strDatensatzAbnehmerMIF[5] = "  TYP char (10)"
  strDatensatzAbnehmerMIF[6] = "  RESERVE float"
  strDatensatzAbnehmerMIF[7] = "  RESERVE float"
  strDatensatzAbnehmerMIF[8] = "  RESERVE float"
  strDatensatzAbnehmerMIF[9] = "  RESERVE float"
  strDatensatzAbnehmerMIF[10] = "  RESERVE float"
  strDatensatzAbnehmerMIF[11] = ""
  strDatensatzAbnehmerMIF[12] = "DATA"
  
  z = 0
  j = 13
  For i = 0 To intZeilenAbnehmerMIFtemp - 1
    'wenn Line
    If Left$(strDatensatzAbnehmerMIFtemp[i], 5) = "Point" Then
      'ersetze Point durch POINT
      strDatensatzAbnehmerMIFtemp[i] = Replace$(strDatensatzAbnehmerMIFtemp[i], "Point", "POINT")
     
    Endif
    If Left$(strDatensatzAbnehmerMIFtemp[i], 5) = "POINT" Then
      
      a = funStringStelleLeer01(strDatensatzAbnehmerMIFtemp[i])
      b = funStringStelleLeer02(strDatensatzAbnehmerMIFtemp[i])
     
      strDatensatzAbnehmerMIF[j] = "POINT" & " " & funRundenSTR(CStr(CFloat(Mid$(strDatensatzAbnehmerMIFtemp[i], a, b - a - 1))), Global.conROUND) & " " & funRundenSTR(CStr(CFloat(Mid$(strDatensatzAbnehmerMIFtemp[i], b, Len(strDatensatzAbnehmerMIFtemp[i]) - b + 1))), Global.conROUND)
      
      'strDatensatzAbnehmerMIF[j] = strDatensatzAbnehmerMIFtemp[i]
      j += 1
    Endif
  Next
  intZeilenAbnehmerMIF = j
'-----------------Erzeuge strNetzTrasseMIF als NetzTrasse.MIF ENDE----------------


  
'-------Schreibe Dateien zurück------------------------------------------
  'Schreibe Abnehmer.MIF
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameAbnehmer & ".MIF" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenAbnehmerMIF - 1 'intZeilenNetzTrasseMIF
    strZeile = strDatensatzAbnehmerMIF[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  
'-------Schreibe Dateien zurück ENDE------------------------------------------
End



Public Sub Erzeuge_Einspeiser()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strDatensatzEinspeiserMIF As New String[Global.conMaxDatensaetze * 3 + 6]
Dim strDatensatzEinspeiserMIFtemp As New String[Global.conMaxDatensaetze * 3 + 6]
Dim intZeilenEinspeiser, intZeilenEinspeiserMIF, intZeilenEinspeiserMIFtemp As Integer
Dim a, b, i, j, z As Integer


'--------------------DATEN EINLESEN---------------------------------  
  b = 0
  hsDatei = Open Global.strPfadEinspeiserdatei For Input 'öffnen der Datei rfEinspeiser.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzEinspeiserMIFtemp[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenEinspeiserMIFtemp = b
  Close #hsDatei  'schließe Datei rfEinspeiser.MIF
'--------------------DATEN EINLESEN ENDE---------------------------------



'-----------------Erzeuge strNetzTrasseMIF als NetzTrasse.MIF----------------
  strDatensatzEinspeiserMIF[0] = "Version 300"
  strDatensatzEinspeiserMIF[1] = "Charset" & Chr(34) & "WindowsLatin1" & Chr(34)
  strDatensatzEinspeiserMIF[2] = "Columns 1"
  strDatensatzEinspeiserMIF[3] = "  RESERVE float"
  strDatensatzEinspeiserMIF[4] = ""
  strDatensatzEinspeiserMIF[5] = "DATA"
    
  z = 0
  j = 6
  For i = 0 To intZeilenEinspeiserMIFtemp - 1
    'wenn Line
    If Left$(strDatensatzEinspeiserMIFtemp[i], 5) = "Point" Then
      'ersetze Point durch POINT
      strDatensatzEinspeiserMIFtemp[i] = Replace$(strDatensatzEinspeiserMIFtemp[i], "Point", "POINT")
     
    Endif
    If Left$(strDatensatzEinspeiserMIFtemp[i], 5) = "POINT" Then
      
      a = funStringStelleLeer01(strDatensatzEinspeiserMIFtemp[i])
      b = funStringStelleLeer02(strDatensatzEinspeiserMIFtemp[i])
     
      strDatensatzEinspeiserMIF[j] = "POINT" & " " & funRundenSTR(CStr(CFloat(Mid$(strDatensatzEinspeiserMIFtemp[i], a, b - a - 1))), Global.conROUND) & " " & funRundenSTR(CStr(CFloat(Mid$(strDatensatzEinspeiserMIFtemp[i], b, Len(strDatensatzEinspeiserMIFtemp[i]) - b + 1))), Global.conROUND)
    
      'strDatensatzEinspeiserMIF[j] = strDatensatzEinspeiserMIFtemp[i]
      j += 1
    Endif
  Next
  intZeilenEinspeiserMIF = j

  a = 0
  For j = 0 To intZeilenEinspeiserMIF - 1
    If Left$(strDatensatzEinspeiserMIF[j], 5) = "POINT" Then
      a += 1
    Endif
  Next
  intZeilenEinspeiser = a
'-----------------Erzeuge strNetzTrasseMIF als NetzTrasse.MIF ENDE----------------


  
'-------Schreibe Dateien zurück------------------------------------------
  'Schreibe Abnehmer.MIF
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameEinspeiser & ".MIF" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenEinspeiserMIF - 1
    strZeile = strDatensatzEinspeiserMIF[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  
  'Schreibe Einspeiser.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameEinspeiser & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenEinspeiser - 1
    strZeile = "0"
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
'-------Schreibe Dateien zurück ENDE------------------------------------------
End


Public Sub KonvertiereMIFDatei()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim strDatei As String
Dim strLineElemente As New String[5]
Dim strDatensatzMIF As New String[Global.conMaxDatensaetze]
Dim strDatensatzMIFtemp As New String[Global.conMaxDatensaetze]
Dim strDatensatzMID As New String[Global.conMaxDatensaetze]
Dim strDatensatzMIDtemp As New String[Global.conMaxDatensaetze]
Dim booOK, booLINE As Boolean
Dim intZeilenMIFtemp, intZeilenMIF, intZeilenMIDtemp, intZeilenMID As Integer
Dim a, b, i, j As Integer


'--------------------DATEN EINLESEN---------------------------------  
  'Öffne MIF Datei
  b = 0
  hsDatei = Open Global.strPfadMIFdatei For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzMIFtemp[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenMIFtemp = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF


  'suche richtigen MID Dateinamen
  If Programmcode.funTesteDatei(Left$(Global.strPfadMIFdatei, -4) & ".mid") = True Then
    strDatei = Left$(Global.strPfadMIFdatei, -4) & ".mid"
  Else
    strDatei = Left$(Global.strPfadMIFdatei, -4) & ".MID"
  Endif
  
  'Öffne MID Datei
  b = 0
  hsDatei = Open strDatei For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzMIDtemp[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenMIDtemp = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF
'--------------------DATEN EINLESEN ENDE---------------------------------
 
 '---------------Bearbeitung MIF--------------------------------------
 
  j = 0
  For i = 0 To intZeilenMIFtemp - 1
    booOK = True
    booLINE = False
    'Charset ändern
    If InStr(strDatensatzMIFtemp[i], "Neutral") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Neutral", "WindowsLatin1")
    Endif
    
    'Delimiter löschen
    If InStr(strDatensatzMIFtemp[i], "Delimiter") > 0 Then
      booOK = False
    Endif
    
    'CoordSys Earth Projection löschen
    If InStr(strDatensatzMIFtemp[i], "CoordSys") > 0 Then
      booOK = False
    Endif
    
    'abgekuerzte Attributbezeichnung ändern
    If InStr(strDatensatzMIFtemp[i], "Decimal(10,0)") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Decimal(10,0)", "integer")
    Endif

    'abgekuerzte Attributbezeichnung ändern
    If InStr(strDatensatzMIFtemp[i], "Decimal(20,15)") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Decimal(20,15)", "float")
    Endif
    
    'abgekuerzte Attributbezeichnung ändern
    If InStr(strDatensatzMIFtemp[i], "Mitteltemp ") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Mitteltemp ", "Mitteltemperatur_VL ")
    Endif

    'abgekuerzte Attributbezeichnung ändern
    If InStr(strDatensatzMIFtemp[i], "Mittelte_1 ") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Mittelte_1 ", "Mitteltemperatur_RL ")
    Endif
  
   'abgekuerzte Attributbezeichnung ändern
    If InStr(strDatensatzMIFtemp[i], "QWaermeabs ") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "QWaermeabs ", "QWaermeabs_VL ")
    Endif  'abgekuerzte Attributbezeichnung ändern
    
    If InStr(strDatensatzMIFtemp[i], "QWaermea_1 ") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "QWaermea_1 ", "QWaermeabs_RL ")
    Endif  'abgekuerzte Attributbezeichnung ändern
    
    If InStr(strDatensatzMIFtemp[i], "QWaermespe ") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "QWaermespe ", "QWaermespez_VL ")
    Endif  'abgekuerzte Attributbezeichnung ändern
    
    If InStr(strDatensatzMIFtemp[i], "QWaermes_1 ") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "QWaermes_1 ", "QWaermespez_RL ")
    Endif  'abgekuerzte Attributbezeichnung ändern
    
    If InStr(strDatensatzMIFtemp[i], "leer_1") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "leer_1", "leer")
    Endif

    If InStr(strDatensatzMIFtemp[i], "leer_2") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "leer_2", "leer")
    Endif 
 
 
 
 
 
    'Float ändern
    If InStr(strDatensatzMIFtemp[i], "Float") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Float", "float")
    Endif
    
    'Integer ändern
    If InStr(strDatensatzMIFtemp[i], "Integer") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Integer", "integer")
    Endif
    
    'Char ändern
    If InStr(strDatensatzMIFtemp[i], "Char(") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Char(", "char (")
    Endif
    
    'Data ändern
    If InStr(strDatensatzMIFtemp[i], "Data") > 0 And strDatensatzMIFtemp[i + 1] = "" Then
      strDatensatzMIFtemp[i] = ""
      strDatensatzMIFtemp[i + 1] = "DATA"
    Endif
    
    'Point ändern
    If InStr(strDatensatzMIFtemp[i], "Point") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Point", "POINT")
    Endif
    
    'Pline ändern
    If InStr(strDatensatzMIFtemp[i], "Pline ") > 0 Then
      strDatensatzMIFtemp[i] = Replace$(strDatensatzMIFtemp[i], "Pline ", "PLINE     ")
    Endif

    'Line in PLINE ändern
    If InStr(strDatensatzMIFtemp[i], "Line") > 0 Then
      booLINE = True
      a = 0
      strGesplittet = Split(strDatensatzMIFtemp[i], " ")
      For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
        strLineElemente[a] = Replace$(strElement, "\r", "")
        a = a + 1   'nächste Spalte
      Next    'nächstes Element in strGesplittet
    Endif
    
    'Symbol löschen
    If InStr(strDatensatzMIFtemp[i], "Symbol") > 0 Then
      booOK = False
    Endif
        
    'Pen löschen
    If InStr(strDatensatzMIFtemp[i], "Pen") > 0 Then
      booOK = False
    Endif
    
    'wenn keine Änderungen erfolgt sind
    If booOK And booLINE Then
      strDatensatzMIF[j] = "PLINE   2"
      j += 1
      strDatensatzMIF[j] = strLineElemente[1] & " " & strLineElemente[2]
      j += 1
      strDatensatzMIF[j] = strLineElemente[3] & " " & strLineElemente[4]
      j += 1
    Endif
    
    If booOK And booLINE = False Then
      strDatensatzMIF[j] = strDatensatzMIFtemp[i]
      j += 1
    Endif
    
  Next
  intZeilenMIF = j
  
  
  
  'runde die Koordinaten bei PLINE
  j = 0
  For i = 0 To intZeilenMIF - 1
    If j > 0 Then
      a = funStringStelleLeer01(strDatensatzMIF[i])
      strDatensatzMIF[i] = funRundenSTR(Left$(strDatensatzMIF[i], a - 2), Global.conROUND) & " " & funRundenSTR(Right$(strDatensatzMIF[i], -(a - 1)), Global.conROUND)
      j -= 1
    Endif
    If Left$(strDatensatzMIF[i], 5) = "PLINE" Then
      j = 2
    Endif
  Next

  'runde die Koordinaten bei POINT
  For i = 0 To intZeilenMIF - 1
    If Left$(strDatensatzMIF[i], 5) = "POINT" Then
      a = funStringStelleLeer01(strDatensatzMIF[i])
      b = funStringStelleLeer02(strDatensatzMIF[i])
     
      strDatensatzMIF[i] = "POINT" & " " & funRundenSTR(CStr(CFloat(Mid$(strDatensatzMIF[i], a, b - a - 1))), Global.conROUND) & " " & funRundenSTR(CStr(CFloat(Mid$(strDatensatzMIF[i], b, Len(strDatensatzMIF[i]) - b + 1))), Global.conROUND)
    Endif
  Next
  
  '---------------Berabeitung-MIF ENDE-------------------------------------
  
  '---------------Bearbeitung MID--------------------------------------
  For i = 0 To intZeilenMIDtemp - 1
    booOK = True
    
    If InStr(strDatensatzMIDtemp[i], ",") > 0 Then
      strDatensatzMIDtemp[i] = Replace$(strDatensatzMIDtemp[i], ",", Chr$(9))
    Endif
    
    If InStr(strDatensatzMIDtemp[i], Chr$(34)) > 0 Then
      strDatensatzMIDtemp[i] = Replace$(strDatensatzMIDtemp[i], Chr$(34), "")
    Endif
    
    strDatensatzMID[i] = strDatensatzMIDtemp[i]
  Next
  intZeilenMID = intZeilenMIDtemp
  '---------------Bearbeitung MID Ende--------------------------------------
  
  
   
  
  '---------------Datei speichern---------------------
  'Schreibe Abnehmer.MIF
  hsDatei = Open Left$(Global.strPfadMIFdatei, -4) & ".MIF" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For j = 0 To intZeilenMIF - 1
    strZeile = strDatensatzMIF[j]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
 
 'Schreibe Abnehmer.MID
  hsDatei = Open Left$(Global.strPfadMIFdatei, -4) & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For j = 0 To intZeilenMID - 1
    strZeile = strDatensatzMID[j]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
End


Public Sub Initialisierung()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim strDatensatzAbnehmer As New String[Global.conSpaltenAbnehmer, Global.conMaxDatensaetze]
Dim strDatensatzAbnehmerMIF As New String[Global.conMaxDatensaetze * 2 + 6]
Dim strDatensatzAbnehmerMIFKoord As New String[2, Global.conMaxDatensaetze]
Dim strDatensatzEinspeiserMIF As New String[10]
Dim strDatensatzEinspeiserMIFKoord As New String[2]
Dim strDatensatzPunkte As New String[Global.conSpaltenPunkte, Global.conMaxDatensaetze]
Dim strDatensatzPunkteMIF As New String[Global.conMaxDatensaetze * 3 + 5 + Global.conSpaltenPunkte]
Dim strDatensatzNetzTrasse As New String[Global.conSpaltenTrasse, Global.conMaxDatensaetze]
Dim strDatensatzNetzTrassetemp As New String[Global.conSpaltenTrasse, Global.conMaxDatensaetze]
Dim strDatensatzNetzTrasseMIF As New String[Global.conMaxDatensaetze * 3 + 5 + Global.conSpaltenTrasse]
Dim strDatensatzNetzTrasseMIFtemp As New String[Global.conMaxDatensaetze * 3 + 5 + Global.conSpaltenTrasse]
Dim strDatensatzNetzTrasseMIFtemp2 As New String[2, Global.conMaxDatensaetze]
Dim strDatensatzNetzTrasseKoord As New String[4, Global.conMaxDatensaetze * 3 + 5 + Global.conSpaltenTrasse]
Dim strDatensatzTrassenWegPunkte As New String[Global.conMaxDatensaetze, Global.conMaxDatensaetze]
Dim strDatensatzTrassenWegStrecken As New String[Global.conMaxDatensaetze, Global.conMaxDatensaetze]
Dim strDatensatzPunktAktuell As New String[3]
Dim strDatensatzPunktMax As New String[3]
Dim intZeilenTrassenWegPunkte As New String[Global.conMaxDatensaetze]
Dim intZeilenTrassenWegStrecken As New String[Global.conMaxDatensaetze]
Dim intSpaltenTrassenWeg As Integer
Dim intZeilenNetzTrasse, intZeilenPunkte, intZeilenNetzTrasseMIF, intZeilenEinspeiserMIF, intZeilenNetzTrasseMIFtemp2, intZeilenAbnehmerMIF, intZeilenAbnehmer As Integer
Dim intNetzTrasseSpaltenzahl, intAbnehmerSpaltenzahl As Integer
Dim intPunktVorher As Integer
Dim a, b, c, i, j, x, z As Integer
Dim booPunkteOK As Boolean
Dim x1, x2, y1, y2 As Float

  
'--------------------DATEN EINLESEN---------------------------------  
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MID" For Input 'öffnen der Datei NetzTrasse.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
  
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzNetzTrasse[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    intNetzTrasseSpaltenzahl = a
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenNetzTrasse = b
  Close #hsDatei  'schließe Datei NetzTrasse.MID
  

  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MIF" For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzNetzTrasseMIF[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenNetzTrasseMIF = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF
  
  
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameEinspeiser & ".MIF" For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzEinspeiserMIF[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenEinspeiserMIF = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF


  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameAbnehmer & ".MID" For Input 'öffnen der Datei Abnehmer.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzAbnehmer[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    intAbnehmerSpaltenzahl = a
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenAbnehmer = b
  Close #hsDatei  'schließe Datei Abnehmer.MID
  

  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameAbnehmer & ".MIF" For Input 'öffnen der Datei Abnehmer.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzAbnehmerMIF[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenAbnehmerMIF = b
  Close #hsDatei  'schließe Datei Abnehmer.MIF
  
  
  'übertrage X, Y Koordinaten in strDatensatzAbnehmerMIFKoord
  x = 0
  z = 0
  b = 0
  For i = 0 To intZeilenAbnehmerMIF
    strGesplittet = Split(strDatensatzAbnehmerMIF[i], " ")    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      If x = 1 And b < 2 Then
        strDatensatzAbnehmerMIFKoord[b, z] = Replace$(strElement, "\r", "")
        b = b + 1
        If b = 2 Then
          x = 0
          z = z + 1
        Endif
      Endif
      If strElement = "POINT" Then x = 1
    Next    'nächstes Element in strGesplittet
    b = 0
  Next
'--------------------DATEN EINLESEN---------------------------------
  

  
'-----------------HAUPTTEIL----------------------------------------------
 'PLINE cracken
  'erzeuge strDatensatzNetzTrasseMIFtemp2
  a = 0
  For i = intNetzTrasseSpaltenzahl + 5 To intZeilenNetzTrasseMIF   'Schleife über die alle PLINE Teile in strDatensatzNetzTrasseMIF um diese in strDatensatzNetzTrasseMIFtemp2 zu übertragen
    If Left$(strDatensatzNetzTrasseMIF[i], 5) = "PLINE" Then 'wenn PLINE zu Zeilenbegin
      strDatensatzNetzTrasseMIFtemp2[0, a] = CStr(i)        'Übertrage die Position auf die Stelle 0
      strDatensatzNetzTrasseMIFtemp2[1, a] = CStr(CFloat(Right$(strDatensatzNetzTrasseMIF[i], -5))) ' übertrage die Anzahl Koordinatenpunkte auf die Stelle 1
      a = a + 1 'Zähle die Position in strDatensatzNetzTrasseMIFtemp2 weiter
    Endif
  Next
  intZeilenNetzTrasseMIFtemp2 = a 'sichere die Anzahl Einträge in strDatensatzNetzTrasseMIFtemp2
  
  'Erzeuge neue strDatensatzNetzTrasseMIFtemp in gecrackter Version
  strElement = "PLINE   2"
  a = 0
  b = 0
  c = 0
  
  'MIF Kopfdaten übertragen
  For i = 0 To intNetzTrasseSpaltenzahl + 4
    strDatensatzNetzTrasseMIFtemp[i] = strDatensatzNetzTrasseMIF[i]
    a = a + 1
  Next
  
  'MIF/MID Haupteil 
  For i = 0 To intZeilenNetzTrasseMIFtemp2 - 1
    'MID Teil
    If CFloat(strDatensatzNetzTrasseMIFtemp2[1, i]) = 2 Then   'wenn PLINE 2 dann
      For x = 0 To Global.conSpaltenTrasse - 1                                       'Schleife über die MID Einträge
        strDatensatzNetzTrassetemp[x, b] = strDatensatzNetzTrasse[x, c]   'b, c Zeilenvariablen
      Next
    c = c + 1
    b = b + 1
    Endif
    
    If CFloat(strDatensatzNetzTrasseMIFtemp2[1, i]) > 2 Then    'wenn PLINE > 2
      For z = 1 To CFloat(strDatensatzNetzTrasseMIFtemp2[1, i]) - 1    'Schleife über Anzahl PLINE -1
        For x = 0 To Global.conSpaltenTrasse - 1       'Schleife über die MID Einträge
          strDatensatzNetzTrassetemp[x, b] = strDatensatzNetzTrasse[x, c]
        Next
       b = b + 1
      Next
      c = c + 1
    Endif
        
    'MIF Teil
    For j = 1 To CFloat(strDatensatzNetzTrasseMIFtemp2[1, i]) - 1 'Schleife über Anzahl PLINE -1
        strDatensatzNetzTrasseMIFtemp[a] = Replace$(strElement, "\r", "") 'übertrage Titelzeile "PLINE   2"
        a = a + 1
        strDatensatzNetzTrasseMIFtemp[a] = strDatensatzNetzTrasseMIF[CFloat(strDatensatzNetzTrasseMIFtemp2[0, i]) + j]   'übertrage Koordinatenzeile 1 AK
        a = a + 1
        strDatensatzNetzTrasseMIFtemp[a] = strDatensatzNetzTrasseMIF[CFloat(strDatensatzNetzTrasseMIFtemp2[0, i]) + j + 1]    'übertrage Koordinatenzeile 2 EK
        a = a + 1
    Next
  Next
  intZeilenNetzTrasse = b
  intZeilenNetzTrasseMIF = a

  'Übertrage Daten auf Trasse MID/MIF ohne MIFMIDtemp
  For i = 0 To intZeilenNetzTrasseMIF - 1
    strDatensatzNetzTrasseMIF[i] = strDatensatzNetzTrasseMIFtemp[i]
  Next
  For i = 0 To intZeilenNetzTrasse - 1
    For j = 0 To Global.conSpaltenTrasse - 1
      strDatensatzNetzTrasse[j, i] = strDatensatzNetzTrassetemp[j, i]
    Next
  Next
  
    
  'Lese Koordinaten aus NetzTrasse.MIF in NetzTrasse Koord[Spalten(X1,Y1,X2,Y2) , Zeilen] 
  b = 0
  a = 0
  For i = intNetzTrasseSpaltenzahl + 5 To intZeilenNetzTrasseMIF
    Select Case a
    
      Case 1
        strDatensatzNetzTrasseMIF[i] = LTrim$(strDatensatzNetzTrasseMIF[i])
        strGesplittet = Split(strDatensatzNetzTrasseMIF[i], " ")    'es wird der gelesenen String (strZeile) in die durch " " getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
          j = 0
        For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
          strDatensatzNetzTrasseKoord[j, b] = Replace$(strElement, "\r", "")
          j = j + 1   'nächste Spalte
        Next    'nächstes Element in strGesplittet
      Case 2
        strDatensatzNetzTrasseMIF[i] = LTrim$(strDatensatzNetzTrasseMIF[i])
        strGesplittet = Split(strDatensatzNetzTrasseMIF[i], " ")    'es wird der gelesenen String (strZeile) in die durch " " getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
          j = 2
        For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
          strDatensatzNetzTrasseKoord[j, b] = Replace$(strElement, "\r", "")
          j = j + 1   'nächste Spalte
        Next    'nächstes Element in strGesplittet
        b = b + 1
    End Select
    a = a + 1
    If a = 3 Then a = 0
  Next
  
  
  'Suche Startpunkt Einspeiser
  'übertrage X, Y Koordinaten in strDatensatzEinspeiserMIFKoord
  z = 0
  x = 0
  b = 0
  For i = 0 To intZeilenEinspeiserMIF
    strGesplittet = Split(strDatensatzEinspeiserMIF[i], " ")    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      If x = 1 And b < 2 Then
        strDatensatzEinspeiserMIFKoord[b] = Replace$(strElement, "\r", "")
        z = z + 1
        b = b + 1
        If b = 2 Then x = 0
      Endif
      If strElement = "POINT" Then x = 1
    Next    'nächstes Element in strGesplittet
    b = 0
    If z > 2 Then Message("Es wurden " & z / 2 & "Einspeiser gefunden! Es ist nur einer zulässig!")
  Next


  'Nullsetzen der Punktnummern in strDatensatzNetzTrasse
  For i = 0 To intZeilenNetzTrasse - 1
    strDatensatzNetzTrasse[0, i] = "0"
    strDatensatzNetzTrasse[1, i] = "0"
  Next
  
  'Belege NetzTrasse mit AK EK
  'Suche Einspeisepunkt
  For i = 0 To intZeilenNetzTrasse
    If CFloat(strDatensatzNetzTrasseKoord[0, i]) = CFloat(strDatensatzEinspeiserMIFKoord[0]) And CFloat(strDatensatzNetzTrasseKoord[1, i]) = CFloat(strDatensatzEinspeiserMIFKoord[1]) Then
      'übertrage Einspeiserdaten
      strDatensatzNetzTrasse[0, i] = "1"
      strDatensatzPunkte[0, 0] = "1"
      strDatensatzPunkte[1, 0] = strDatensatzNetzTrasseKoord[0, i]
      strDatensatzPunkte[2, 0] = strDatensatzNetzTrasseKoord[1, i]
      For j = 3 To global.conSpaltenPunkte - 1
        strDatensatzPunkte[j, 0] = "0"
      Next
      'Punkte MIF
      strDatensatzPunkteMIF[0] = "Version 300"
      strDatensatzPunkteMIF[1] = "Charset " & Chr$(34) & "WindowsLatin1" & Chr$(34)
      strDatensatzPunkteMIF[2] = "Columns " & CStr(global.conSpaltenPunkte)
      strDatensatzPunkteMIF[3] = "  Nummer" & " integer"
      strDatensatzPunkteMIF[4] = "  LON" & " float"
      strDatensatzPunkteMIF[5] = "  LAK" & " float"
      strDatensatzPunkteMIF[6] = "  TempVL" & " float"
      strDatensatzPunkteMIF[7] = "  TempRL" & " float"
      strDatensatzPunkteMIF[8] = "  Massenstrom" & " float"
      strDatensatzPunkteMIF[9] = "  KntV1" & " integer"
      strDatensatzPunkteMIF[10] = "  TraV1" & " integer"
      strDatensatzPunkteMIF[11] = "  KntNAnz" & " integer"
      strDatensatzPunkteMIF[12] = "  KntN1" & " integer"
      strDatensatzPunkteMIF[13] = "  TraN1" & " integer"
      strDatensatzPunkteMIF[14] = "  KntN2" & " integer"
      strDatensatzPunkteMIF[15] = "  TraN2" & " integer"
      strDatensatzPunkteMIF[16] = "  KntN3" & " integer"
      strDatensatzPunkteMIF[17] = "  TraN3" & " integer"
      strDatensatzPunkteMIF[18] = "  Pmax" & " float"
      strDatensatzPunkteMIF[19] = "  GebTyp" & " char (16)"
      strDatensatzPunkteMIF[20] = "  TestBit" & " Integer"
      strDatensatzPunkteMIF[21] = "  Pakt" & " float"
      strDatensatzPunkteMIF[22] = "  MSakt" & " float"
      strDatensatzPunkteMIF[23] = "  QJahr" & " float"
      strDatensatzPunkteMIF[24] = "  KW" & " float"
      strDatensatzPunkteMIF[25] = "  TempVL2a" & " float"
      strDatensatzPunkteMIF[26] = "  TempRL2a" & " float"
      strDatensatzPunkteMIF[27] = "  Massenstrom2a" & " float"
      strDatensatzPunkteMIF[28] = "  Pakt2a" & " float"
      strDatensatzPunkteMIF[29] = "  <leer>" & " float"
      strDatensatzPunkteMIF[30] = "  <leer>" & " float"
      strDatensatzPunkteMIF[31] = "  <leer>" & " float"
      strDatensatzPunkteMIF[32] = "  <leer>" & " float"
      strDatensatzPunkteMIF[33] = "  <leer>" & " float"
      strDatensatzPunkteMIF[34] = "  <leer>" & " float"
      strDatensatzPunkteMIF[35] = "  TempVL2b" & " float"
      strDatensatzPunkteMIF[36] = "  TempRL2b" & " float"
      strDatensatzPunkteMIF[37] = "  Massenstrom2b" & " float"
      strDatensatzPunkteMIF[38] = "  Pakt2b" & " float"
      strDatensatzPunkteMIF[39] = "  <leer>" & " float"
      strDatensatzPunkteMIF[40] = "  <leer>" & " float"
      strDatensatzPunkteMIF[41] = "  <leer>" & " float"
      strDatensatzPunkteMIF[42] = "  Abnehmer" & " integer"
      strDatensatzPunkteMIF[43] = ""
      strDatensatzPunkteMIF[44] = "DATA"
      strZeile = ""
      strZeile &= "POINT "
      strZeile &= strDatensatzPunkte[1, 0] & " "
      strZeile &= strDatensatzPunkte[2, 0]
      strDatensatzPunkteMIF[global.conSpaltenPunkte + 5] = Replace$(strZeile, "\r", "")
      Goto ENDE_EINSPEISE
    Endif
   
    'wenn die Linie verkehrt rum
    If CFloat(strDatensatzNetzTrasseKoord[2, i]) = CFloat(strDatensatzEinspeiserMIFKoord[0]) And CFloat(strDatensatzNetzTrasseKoord[3, i]) = CFloat(strDatensatzEinspeiserMIFKoord[1]) Then
      'tausche x-Koordinaten
      strElement = strDatensatzNetzTrasseKoord[0, i]
      strDatensatzNetzTrasseKoord[0, i] = strDatensatzNetzTrasseKoord[2, i]
      strDatensatzNetzTrasseKoord[2, i] = Replace$(strElement, "\r", "")
      'tausche y-Koordinaten
      strElement = strDatensatzNetzTrasseKoord[1, i]
      strDatensatzNetzTrasseKoord[1, i] = strDatensatzNetzTrasseKoord[3, i]
      strDatensatzNetzTrasseKoord[3, i] = Replace$(strElement, "\r", "")
      'übertrage im MIF
      strElement = strDatensatzNetzTrasseMIF[i * 3 + 5 + Global.conSpaltenTrasse + 2]
      strDatensatzNetzTrasseMIF[i * 3 + 5 + Global.conSpaltenTrasse + 2] = strDatensatzNetzTrasseMIF[i * 3 + 5 + Global.conSpaltenTrasse + 1]
      strDatensatzNetzTrasseMIF[i * 3 + 5 + Global.conSpaltenTrasse + 1] = Replace$(strElement, "\r", "")

      
      'übertrage Einspeiserdaten
      strDatensatzNetzTrasse[0, i] = "1"
      strDatensatzPunkte[0, 0] = "1"
      strDatensatzPunkte[1, 0] = strDatensatzEinspeiserMIFKoord[0]
      strDatensatzPunkte[2, 0] = strDatensatzEinspeiserMIFKoord[1]
      For j = 3 To global.conSpaltenPunkte - 1
        strDatensatzPunkte[j, 0] = "0"
      Next
      'Punkte MIF
      strDatensatzPunkteMIF[0] = "Version 300"
      strDatensatzPunkteMIF[1] = "Charset " & Chr$(34) & "WindowsLatin1" & Chr$(34)
      strDatensatzPunkteMIF[2] = "Columns " & CStr(global.conSpaltenPunkte)
      strDatensatzPunkteMIF[3] = "  Nummer" & " integer"
      strDatensatzPunkteMIF[4] = "  LON" & " float"
      strDatensatzPunkteMIF[5] = "  LAK" & " float"
      strDatensatzPunkteMIF[6] = "  TempVL" & " float"
      strDatensatzPunkteMIF[7] = "  TempRL" & " float"
      strDatensatzPunkteMIF[8] = "  Massenstrom" & " float"
      strDatensatzPunkteMIF[9] = "  KntV1" & " integer"
      strDatensatzPunkteMIF[10] = "  TraV1" & " integer"
      strDatensatzPunkteMIF[11] = "  KntNAnz" & " integer"
      strDatensatzPunkteMIF[12] = "  KntN1" & " integer"
      strDatensatzPunkteMIF[13] = "  TraN1" & " integer"
      strDatensatzPunkteMIF[14] = "  KntN2" & " integer"
      strDatensatzPunkteMIF[15] = "  TraN2" & " integer"
      strDatensatzPunkteMIF[16] = "  KntN3" & " integer"
      strDatensatzPunkteMIF[17] = "  TraN3" & " integer"
      strDatensatzPunkteMIF[18] = "  Pmax" & " float"
      strDatensatzPunkteMIF[19] = "  GebTyp" & " char (16)"
      strDatensatzPunkteMIF[20] = "  TestBit" & " Integer"
      strDatensatzPunkteMIF[21] = "  Pakt" & " float"
      strDatensatzPunkteMIF[22] = "  MSakt" & " float"
      strDatensatzPunkteMIF[23] = "  QJahr" & " float"
      strDatensatzPunkteMIF[24] = "  KW" & " float"
      strDatensatzPunkteMIF[25] = "  TempVL2a" & " float"
      strDatensatzPunkteMIF[26] = "  TempRL2a" & " float"
      strDatensatzPunkteMIF[27] = "  Massenstrom2a" & " float"
      strDatensatzPunkteMIF[28] = "  Pakt2a" & " float"
      strDatensatzPunkteMIF[29] = "  <leer>" & " float"
      strDatensatzPunkteMIF[30] = "  <leer>" & " float"
      strDatensatzPunkteMIF[31] = "  <leer>" & " float"
      strDatensatzPunkteMIF[32] = "  <leer>" & " float"
      strDatensatzPunkteMIF[33] = "  <leer>" & " float"
      strDatensatzPunkteMIF[34] = "  <leer>" & " float"
      strDatensatzPunkteMIF[35] = "  TempVL2ba" & " float"
      strDatensatzPunkteMIF[36] = "  TempRL2b" & " float"
      strDatensatzPunkteMIF[37] = "  Massenstrom2b" & " float"
      strDatensatzPunkteMIF[38] = "  Pakt2b" & " float"
      strDatensatzPunkteMIF[39] = "  <leer>" & " float"
      strDatensatzPunkteMIF[40] = "  <leer>" & " float"
      strDatensatzPunkteMIF[41] = "  <leer>" & " float"
      strDatensatzPunkteMIF[42] = "  Abnehmer" & " integer"
      strDatensatzPunkteMIF[43] = ""
      strDatensatzPunkteMIF[44] = "DATA"
      strZeile = ""
      strZeile &= "POINT "
      strZeile &= strDatensatzPunkte[1, 0] & " "
      strZeile &= strDatensatzPunkte[2, 0]
      strDatensatzPunkteMIF[global.conSpaltenPunkte + 5] = Replace$(strZeile, "\r", "")
      Goto ENDE_EINSPEISE
    Endif
  Next
ENDE_EINSPEISE:
  intZeilenPunkte = global.conSpaltenPunkte + 5

  'Startwerte für die Punkte
  strDatensatzPunktMax[0] = "1"
  strDatensatzPunktMax[1] = strDatensatzPunkte[1, 0]
  strDatensatzPunktMax[2] = strDatensatzPunkte[2, 0]
  strDatensatzPunktAktuell[0] = "1"
  strDatensatzPunktAktuell[1] = strDatensatzPunkte[1, 0]
  strDatensatzPunktAktuell[2] = strDatensatzPunkte[2, 0]
  intPunktVorher = 0
  
  
'---------Ab hier werden weitere Punkte eingelesen ---------------------------------------------
  booPunkteOK = False
  While booPunkteOK = False
    'erste Schleife belegt alle AK mit gleichem Startpunkt (=aktueller Punkt)
    For i = 0 To intZeilenNetzTrasse - 1
      'wenn die Koordinaten des aktuellen Punktes = NetzrasseTrasse[AK,i] und der EK = 0
      If CFloat(strDatensatzNetzTrasseKoord[0, i]) = CFloat(strDatensatzPunktAktuell[1]) And CFloat(strDatensatzNetzTrasseKoord[1, i]) = CFloat(strDatensatzPunktAktuell[2]) And strDatensatzNetzTrasse[1, i] = 0 Then
        'AK wird in Trasse abgelegt
        strDatensatzNetzTrasse[0, i] = strDatensatzPunktAktuell[0]
        'intTrasseVorher = i + 1
      Endif
 
      'wenn die Koordinaten des aktuellen Punktes = NetzrasseTrasse[EK,i] und der AK = 0
      If CFloat(strDatensatzNetzTrasseKoord[2, i]) = CFloat(strDatensatzPunktAktuell[1]) And CFloat(strDatensatzNetzTrasseKoord[3, i]) = CFloat(strDatensatzPunktAktuell[2]) And strDatensatzNetzTrasse[0, i] = 0 Then
        'tausche x-Koordinaten
        strElement = strDatensatzNetzTrasseKoord[0, i]
        strDatensatzNetzTrasseKoord[0, i] = strDatensatzNetzTrasseKoord[2, i]
        strDatensatzNetzTrasseKoord[2, i] = Replace$(strElement, "\r", "")
        'tausche y-Koordinaten
        strElement = strDatensatzNetzTrasseKoord[1, i]
        strDatensatzNetzTrasseKoord[1, i] = strDatensatzNetzTrasseKoord[3, i]
        strDatensatzNetzTrasseKoord[3, i] = Replace$(strElement, "\r", "")
        
        'AK wird in Trasseabgelegt
        strDatensatzNetzTrasse[0, i] = strDatensatzPunktAktuell[0]
      Endif
    Next
    
    intPunktVorher = CInt(strDatensatzPunktAktuell[0])
    
    'zweite Schleife belegt alle gleichen AK und EK = 0 mit PunktMax
    For i = 0 To intZeilenNetzTrasse - 1
      If CInt(strDatensatzNetzTrasse[0, i]) > 0 And CInt(strDatensatzNetzTrasse[1, i]) = 0 Then
        'EK wird nächste freie Punktnummer
       strDatensatzNetzTrasse[1, i] = CStr(CInt(strDatensatzPunktMax[0]) + 1)
      
        'Punkte.MID wird mit dem EK der Trasse belegt
        strDatensatzPunkte[0, CInt(strDatensatzPunktMax[0]) + 1 - 1] = CStr(CInt(strDatensatzPunktMax[0] + 1))
        strDatensatzPunkte[1, CInt(strDatensatzPunktMax[0]) + 1 - 1] = strDatensatzNetzTrasseKoord[2, i]
        strDatensatzPunkte[2, CInt(strDatensatzPunktMax[0]) + 1 - 1] = strDatensatzNetzTrasseKoord[3, i]
        For j = 3 To 29 - 1
          strDatensatzPunkte[j, CInt(strDatensatzPunktMax[0]) + 1 - 1] = "0"
        Next
        
        strDatensatzPunkte[6, CInt(strDatensatzPunktMax[0]) + 1 - 1] = intPunktVorher
        strDatensatzPunkte[7, CInt(strDatensatzPunktMax[0]) + 1 - 1] = i + 1 'intTrasseVorher
        
        'Punkte.MIF wird mit dem EK der Trasse belegt
        strZeile = ""
        strZeile &= "POINT "
        strZeile &= strDatensatzNetzTrasseKoord[2, i] & " "
        strZeile &= strDatensatzNetzTrasseKoord[3, i]
        strDatensatzPunkteMIF[CInt(strDatensatzPunktMax[0]) + Global.conSpaltenPunkte + 5] = Replace$(strZeile, "\r", "")
        
        'die Anzahl der Zeilen in der Punktedatei und in PunkteMax wird um 1 erhöht
        'intZeilenPunkte = intZeilenPunkte + 1
        strDatensatzPunktMax[0] = CStr(CInt(strDatensatzPunktMax[0]) + 1)
      Endif
    Next
    'Als Aktueller Punkt wird der Neue definiert
    If CInt(strDatensatzPunktAktuell[0]) - 1 < CInt(strDatensatzPunktMax[0] - 1) Then
      strDatensatzPunktAktuell[0] = CStr(CInt(strDatensatzPunktAktuell[0]) + 1)
      strDatensatzPunktAktuell[1] = strDatensatzPunkte[1, CInt(strDatensatzPunktAktuell[0]) - 1]
      strDatensatzPunktAktuell[2] = strDatensatzPunkte[2, CInt(strDatensatzPunktAktuell[0]) - 1]
    Else
      booPunkteOK = True
    Endif
  Wend
  intZeilenPunkte = CInt(strDatensatzPunktMax[0])
'-------weitere Punkte Ende--------


'-------Übertrage Abnehmerdaten---------------------
 'Suche Abnehmerpunkte
  For j = 0 To intZeilenAbnehmer - 1
    For i = 0 To intZeilenPunkte - 1
      If CFloat(strDatensatzPunkte[1, i]) = CFloat(strDatensatzAbnehmerMIFKoord[0, j]) And CFloat(strDatensatzPunkte[2, i]) = CFloat(strDatensatzAbnehmerMIFKoord[1, j]) Then
       strDatensatzPunkte[15, i] = strDatensatzAbnehmer[0, j] 'Pmax
       strDatensatzPunkte[16, i] = strDatensatzAbnehmer[2, j] 'BAKlasse
       strDatensatzPunkte[20, i] = strDatensatzAbnehmer[1, j] 'QJahr
      Endif
    Next
  Next
'------Übertrage Abnehmerdaten ENDE----------------------


'--------suche N1, N2, N3-----------
  'Setze alle Nachpunktinfos = 0
  For i = 0 To intZeilenPunkte - 1
    For j = 8 To 14
      strDatensatzPunkte[j, i] = "0"
    Next
  Next
  
  'Setze TrassenWege = 0
  intSpaltenTrassenWeg = 0
    
  'Schleife über alle Punkte als mögliche Abnehmer 
  For i = 0 To intZeilenPunkte - 1
    'wenn Punkt i ein Abnehmer ist dann
    If CFloat(strDatensatzPunkte[20, i]) > 0 Then
      strDatensatzPunkte[39, i] = "1"
      
      'aktueller Punkt ist Abnehmer Punkt bei i
      strDatensatzPunktAktuell[0] = strDatensatzPunkte[0, i]
      strDatensatzPunktAktuell[1] = strDatensatzPunkte[1, i]
      strDatensatzPunktAktuell[2] = strDatensatzPunkte[2, i]

      'Trassenweg
      intSpaltenTrassenWeg = intSpaltenTrassenWeg + 1
      intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] = 0
      intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] = 0
      
      'WHILE Aktueller Punkt nicht Einspeiser (Einspeiser ist immer der Punkt 1!
      While CInt(strDatensatzPunktAktuell[0]) <> 1
        'trage beim Punkt v1 den aktuellen Punkt als n1 ein. wenn dort bei[8] schon 1 dann N2. wenn dort bei[8] schon 2 dann N3
        Select Case CInt(strDatensatzPunkte[8, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1])
          Case 0  'wenn  im vorhergehenden punkt unter 8 die Zahl 0 als Anzahl nachfolgender Punkte gewählt sind, dann
            'übertrage als nachfolgenden Punkt N1 den aktuellen Punkt
            strDatensatzPunkte[9, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1] = strDatensatzPunktAktuell[0]
            'erhöhe die Zahl nachfolgender Punkte auf 1
            strDatensatzPunkte[8, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1] = CStr(1)
            'Trasse übertragen
            strDatensatzPunkte[10, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1] = strDatensatzPunkte[7, CInt(strDatensatzPunktAktuell[0]) - 1]
            'Trassenweg
            intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] = intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] + 1
            strDatensatzTrassenWegPunkte[intSpaltenTrassenWeg - 1, intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] - 1] = strDatensatzPunktAktuell[0]
            intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] = intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] + 1
            strDatensatzTrassenWegStrecken[intSpaltenTrassenWeg - 1, intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] - 1] = strDatensatzPunkte[7, CInt(strDatensatzPunktAktuell[0]) - 1]
            
            'Aktuellen Punkt weiterschieben            
            strDatensatzPunktAktuell[1] = strDatensatzPunkte[1, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]
            strDatensatzPunktAktuell[2] = strDatensatzPunkte[2, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]
            strDatensatzPunktAktuell[0] = strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]
            
          Case 1
            'wenn der aktuelle Punkt noch nicht als Nachfolgerpunkt eingetragen is, dann
            If CInt(strDatensatzPunkte[9, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]) <> CInt(strDatensatzPunktAktuell[0]) Then
              'übertrage als nachfolgenden Punkt N2 den aktuellen Punkt
              strDatensatzPunkte[11, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1] = strDatensatzPunktAktuell[0]
              'erhöhe die Zahl nachfolgender Punkte auf 2
              strDatensatzPunkte[8, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1] = CStr(2)
              'Trasse übertragen
              strDatensatzPunkte[12, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1] = strDatensatzPunkte[7, CInt(strDatensatzPunktAktuell[0]) - 1]
            Endif
            'Trassenweg
            intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] = intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] + 1
            strDatensatzTrassenWegPunkte[intSpaltenTrassenWeg - 1, intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] - 1] = strDatensatzPunktAktuell[0]
            intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] = intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] + 1
            strDatensatzTrassenWegStrecken[intSpaltenTrassenWeg - 1, intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] - 1] = strDatensatzPunkte[7, CInt(strDatensatzPunktAktuell[0]) - 1]
            'Aktuellen Punkt weiterschieben
            strDatensatzPunktAktuell[1] = strDatensatzPunkte[1, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]
            strDatensatzPunktAktuell[2] = strDatensatzPunkte[2, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]
            strDatensatzPunktAktuell[0] = strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]
            
          Case 2
            'wenn der aktuelle Punkt noch nicht als Nachfolgerpunkt eingetragen is, dann 
            If CInt(strDatensatzPunkte[9, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]) <> CInt(strDatensatzPunktAktuell[0]) And CInt(strDatensatzPunkte[11, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]) <> CInt(strDatensatzPunktAktuell[0]) Then
              'übertrage als nachfolgenden Punkt N3 den aktuellen Punkt
              strDatensatzPunkte[13, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1] = strDatensatzPunktAktuell[0]
              'erhöhe die Zahl nachfolgender Punkte auf 3
              strDatensatzPunkte[8, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1] = CStr(3)
              'Trasse übertragen
              strDatensatzPunkte[14, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1] = strDatensatzPunkte[7, CInt(strDatensatzPunktAktuell[0]) - 1]
            Endif
            'Trassenweg
            intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] = intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] + 1
            strDatensatzTrassenWegPunkte[intSpaltenTrassenWeg - 1, intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] - 1] = strDatensatzPunktAktuell[0]
            intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] = intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] + 1
            strDatensatzTrassenWegStrecken[intSpaltenTrassenWeg - 1, intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] - 1] = strDatensatzPunkte[7, CInt(strDatensatzPunktAktuell[0]) - 1]
            'Aktuellen Punkt weiterschieben
            strDatensatzPunktAktuell[1] = strDatensatzPunkte[1, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]
            strDatensatzPunktAktuell[2] = strDatensatzPunkte[2, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]
            strDatensatzPunktAktuell[0] = strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]
            
          Case Else
            'Trassenweg
            intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] = intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] + 1
            strDatensatzTrassenWegPunkte[intSpaltenTrassenWeg - 1, intZeilenTrassenWegPunkte[intSpaltenTrassenWeg - 1] - 1] = CInt(strDatensatzPunktAktuell[0])
            intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] = intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] + 1
            strDatensatzTrassenWegStrecken[intSpaltenTrassenWeg - 1, intZeilenTrassenWegStrecken[intSpaltenTrassenWeg - 1] - 1] = strDatensatzPunkte[7, CInt(strDatensatzPunktAktuell[0]) - 1]
            'Aktuellen Punkt weiterschieben
            strDatensatzPunktAktuell[1] = strDatensatzPunkte[1, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]
            strDatensatzPunktAktuell[2] = strDatensatzPunkte[2, CInt(strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]) - 1]
            strDatensatzPunktAktuell[0] = strDatensatzPunkte[6, CInt(strDatensatzPunktAktuell[0]) - 1]
        End Select
        
      Wend
    Endif
  Next



'-------Ende suche N1, N2, N3 --------------
'-------Trassenlängen berechnen---------------
  For i = 0 To intZeilenNetzTrasse - 1
    x1 = strDatensatzPunkte[1, CInt(strDatensatzNetzTrasse[0, i] - 1)]
    y1 = strDatensatzPunkte[2, CInt(strDatensatzNetzTrasse[0, i] - 1)]
    x2 = strDatensatzPunkte[1, CInt(strDatensatzNetzTrasse[1, i] - 1)]
    y2 = strDatensatzPunkte[2, CInt(strDatensatzNetzTrasse[1, i] - 1)]
    strDatensatzNetzTrasse[2, i] = CStr(funLaenge(x1, y1, x2, y2))
  Next
'-------Trassenlängen berechnen ENDE---------------

'-------Schreibe Dateien zurück----------------
  'Schreibe NetzTrasse.MIF
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MIF" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  strZeile = "Version 300"
  Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  strZeile = "Charset " & Chr$(34) & "WindowsLatin1" & Chr$(34)
  Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  strZeile = "Columns " & CStr(Global.conSpaltenTrasse)
  Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  
  For i = 3 To intZeilenNetzTrasseMIF - 1 'intZeilenNetzTrasseMIF
    strZeile = strDatensatzNetzTrasseMIF[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  
  'Schreibe NetzTrasse.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenNetzTrasse - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenTrasse - 2
      strZeile &= strDatensatzNetzTrasse[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzNetzTrasse[Global.conSpaltenTrasse - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  'Schreibe Punkte.MIF
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MIF" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenPunkte - 1 + 5 + global.conSpaltenPunkte  'Schleife über die Bauteile
    strZeile = strDatensatzPunkteMIF[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  'Schreibe Punkte.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenPunkte - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenPunkte - 2
      strZeile &= strDatensatzPunkte[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzPunkte[Global.conSpaltenPunkte - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  'Schreibe rfPfadePunkte.csv
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePfadePunkte & ".csv" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  a = 0
  For i = 0 To intSpaltenTrassenWeg - 1 'Anzahl Spalten
    If a < CInt(intZeilenTrassenWegPunkte[i]) Then
      a = intZeilenTrassenWegPunkte[i]
    Endif
  Next
  
  For i = 0 To a   'Schleife über die Bauteile
    If i = 0 Then
      strZeile = ""
      For j = 0 To intSpaltenTrassenWeg - 2
        strZeile &= CStr(intZeilenTrassenWegPunkte[j]) & Chr$(9)
      Next
      strZeile &= CStr(intZeilenTrassenWegPunkte[j])
    Else
      strZeile = ""
      For j = 0 To intSpaltenTrassenWeg - 2
        strZeile &= strDatensatzTrassenWegPunkte[j, i - 1] & Chr$(9)
      Next
      strZeile &= strDatensatzTrassenWegPunkte[j, i - 1]
    Endif
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei

 'Schreibe rfPfadeStrecken.csv
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePfadeStrecken & ".csv" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  a = 0
  For i = 0 To intSpaltenTrassenWeg - 1 'Anzahl Spalten
    If a < CInt(intZeilenTrassenWegStrecken[i]) Then
      a = intZeilenTrassenWegStrecken[i]
    Endif
  Next
  
  For i = 0 To a   'Schleife über die Bauteile
    If i = 0 Then
      strZeile = ""
      For j = 0 To intSpaltenTrassenWeg - 2
        strZeile &= CStr(intZeilenTrassenWegStrecken[j]) & Chr$(9)
      Next
      strZeile &= CStr(intZeilenTrassenWegStrecken[j])
    Else
      strZeile = ""
      For j = 0 To intSpaltenTrassenWeg - 2
        strZeile &= strDatensatzTrassenWegStrecken[j, i - 1] & Chr$(9)
      Next
      strZeile &= strDatensatzTrassenWegStrecken[j, i - 1]
    Endif
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
'-------Schreibe Dateien zurück ENDE----------------
End



Public Sub Import_AbnehmerDaten()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim strDatensatzAbnehmer As New String[4, Global.conMaxDatensaetze]
Dim strDatensatzAbnehmerMIF As New String[2, Global.conMaxDatensaetze]
Dim strDatensatzAbnehmerMIF_temp As New String[Global.conMaxDatensaetze * 3 + 13]
Dim strDatensatzTemp As New String[10]
Dim strDatensatzPunkte As New String[Global.conSpaltenPunkte, Global.conMaxDatensaetze]
Dim strDatensatzPunkte_temp As New String[Global.conSpaltenPunkte, Global.conMaxDatensaetze]
Dim intZeilenAbnehmer, intAbnehmerSpaltenzahl, intZeilenAbnehmerMIF, intZeilenAbnehmerMIF_temp, intZeilenPunkte, intZeilenPunkte_temp As Integer
Dim a, b, i, j As Integer
  
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameAbnehmer & ".MID" For Input 'öffnen der Datei Abnehmer.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzAbnehmer[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    intAbnehmerSpaltenzahl = a
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenAbnehmer = b
  Close #hsDatei  'schließe Datei Kanten.MID
  
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameAbnehmer & ".MIF" For Input 'öffnen der Datei Abnehmer.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzAbnehmerMIF_temp[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenAbnehmerMIF_temp = b
  Close #hsDatei  'schließe Datei Ergebnis.MIF
  
  b = 0
  For i = 0 To intZeilenAbnehmerMIF_temp - 1
    strGesplittet = Split(strDatensatzAbnehmerMIF_temp[i], " ")
    a = 0
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzTemp[a] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    If strDatensatzTemp[0] = "POINT" Then
      strDatensatzAbnehmerMIF[0, b] = strDatensatzTemp[1]  'lese x-Koordinate LON
      strDatensatzAbnehmerMIF[1, b] = strDatensatzTemp[2]  'lese y-Koordinate LAK
      b = b + 1
    Endif
  Next
  intZeilenAbnehmerMIF = b

  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Input 'öffnen der Datei Punkte.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzPunkte[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenPunkte = b
  Close #hsDatei  'schließe Datei Punkte.MID

  a = 0
  For i = 0 To intZeilenPunkte - 1
    If strDatensatzPunkte[8, i] = 0 Then
      For j = 0 To 14
        strDatensatzPunkte_temp[j, a] = strDatensatzPunkte[j, i]
      Next
      a = a + 1
    Endif
  Next
  intZeilenPunkte_temp = a

  For i = 0 To intZeilenPunkte - 1
    strDatensatzPunkte[15, i] = "0"
    strDatensatzPunkte[16, i] = "0"
    strDatensatzPunkte[39, j] = "1"
    strDatensatzPunkte[18, i] = "0"
  Next
  

  For i = 0 To intZeilenAbnehmerMIF - 1
    For j = 0 To intZeilenPunkte - 1
      If CFloat(strDatensatzAbnehmerMIF[0, i]) = CFloat(strDatensatzPunkte[1, j]) And CFloat(strDatensatzAbnehmerMIF[1, i]) = CFloat(strDatensatzPunkte[2, j]) Then
        If intAbnehmerSpaltenzahl > 0 Then strDatensatzPunkte[15, j] = strDatensatzAbnehmer[0, i]
        If intAbnehmerSpaltenzahl > 1 Then strDatensatzPunkte[20, j] = strDatensatzAbnehmer[1, i]
        If intAbnehmerSpaltenzahl > 2 Then strDatensatzPunkte[16, j] = strDatensatzAbnehmer[2, i]
        If CFloat(strDatensatzPunkte[20, j]) > 0 Then strDatensatzPunkte[39, j] = "1"
        Goto ENDE1
      Endif
    Next
    ENDE1:
  Next

  'Schreibe Punkte.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenPunkte - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenPunkte - 2
      strZeile &= strDatensatzPunkte[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzPunkte[Global.conSpaltenPunkte - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
End






Public Sub Berechnung_iterativ()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim strDatensatzPunkte As New String[Global.conSpaltenPunkte, Global.conMaxDatensaetze]
Dim strDatensatzNetzTrasse As New String[Global.conSpaltenTrasse, Global.conMaxDatensaetze]
Dim strDatensatzNetzTrasseMIF As New String[Global.conMaxDatensaetze * 3 + 5 + Global.conSpaltenTrasse]
Dim strDatensatzRohre As New String[12, Global.conMaxRohre]
Dim intZeilenNetzTrasse, intZeilenPunkte, intZeilenNetzTrasseMIF As Integer
Dim a, b, i, j, z As Integer
Dim intNetzTrasseSpaltenzahl As Integer
Dim fltFaktorVL, fltFaktorRL As Float
Dim fltFaktorVL2a, fltFaktorRL2a As Float
Dim fltFaktorVL2b, fltFaktorRL2b As Float
Dim fltAuslegeleistung, fltAnteilP As Float
Dim Temperatur1, Temperatur2, Temperatur3, Temperatur1a, Temperatur2a, Temperatur3a, Temperatur1b, Temperatur2b, Temperatur3b As Float
Dim Massenstrom1, Massenstrom2, Massenstrom3, Massenstrom1a, Massenstrom2a, Massenstrom3a, Massenstrom1b, Massenstrom2b, Massenstrom3b As Float
Dim fltQ_VL, fltQ_RL, fltQ_VLa, fltQ_RLa, fltQ_VLb, fltQ_RLb As Float
Dim booZ As Boolean
  
  
  
'--------------------Dateien einlesen---------------------------------------------------     
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameBibRohre & ".csv" For Input 'öffnen der Datei Rohre.csv
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzRohre[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Close #hsDatei  'schließe Datei Rohre.csv
  
 
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MID" For Input 'öffnen der Datei NetzTrasse.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzNetzTrasse[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    intNetzTrasseSpaltenzahl = a
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenNetzTrasse = b
  Close #hsDatei  'schließe Datei NetzTrasse.MID

  
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MIF" For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzNetzTrasseMIF[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenNetzTrasseMIF = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF


  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Input 'öffnen der Datei Punkte.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzPunkte[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenPunkte = b
  Close #hsDatei  'schließe Datei Punkte.MID
'--------------------Dateien einlesen ENDE---------------------------------------------------   




'------------aktuelle Leistung an den Abnehmern-----------------------------------------------------
  'Setze die PAktuell, Lege die Massenströme an den Abnehmern fest
  For i = 0 To intZeilenPunkte - 1
    'wenn QJahr > 0 dann (Abnehmer)
    If CFloat(strDatensatzPunkte[20, i]) > 0 Then
      'wenn Abnehmer wird mitgerechnet (Spalte 39) dann belege Abnehmer mit Massenstrom
      If strDatensatzPunkte[39, i] = "1" Then
        strDatensatzPunkte[18, i] = CStr(funQStd(CFloat(Global.strDatensatzPunkte[21, i]), Global.strDatensatzPunkte[16, i], Global.intStunde))
      Else
        strDatensatzPunkte[18, i] = "0"
      Endif
            
      'Vierleiterfall
      If Global.booMehrleiter = True Then
        'wenn Abnehmer wird mitgerechnet (Spalte 39) dann belege Abnehmer mit Massenstrom
        If strDatensatzPunkte[39, i] = "1" Then
          fltAuslegeleistung = CStr(funQStd(CFloat(Global.strDatensatzPunkte[21, i]), Global.strDatensatzPunkte[16, i], Global.intStunde))
          'fltAuslegeleistung = funQStd_Dimensionierung(CFloat(strDatensatzPunkte[21, i]), strDatensatzPunkte[16, i], CFloat(Global.fltAuslegungstemperatur))
          'Bruch ist Anteil Teilastleistung an Auslegungsleistung
          fltAnteilP = CFloat(strDatensatzPunkte[18, i]) / fltAuslegeleistung
          
           'wenn Mehrleiternetz in Spitzen und Grundlast geteilt dann Pakt:
          If Global.booGLSPL = True Then
            If Global.fltAussentemperatur >= Global.conHeizGrenzTemperaturTWW Then
              strDatensatzPunkte[25, i] = "0"
              strDatensatzPunkte[35, i] = CStr(funQStd_Dimensionierung(CFloat(strDatensatzPunkte[21, i]), strDatensatzPunkte[16, i], Global.fltAussentemperatur))
            Else
              strDatensatzPunkte[35, i] = CStr(funQStd_Dimensionierung(CFloat(strDatensatzPunkte[21, i]), strDatensatzPunkte[16, i], Global.conHeizGrenzTemperaturTWW))
              strDatensatzPunkte[25, i] = CStr(funQStd_Dimensionierung(CFloat(strDatensatzPunkte[21, i]), strDatensatzPunkte[16, i], Global.fltAussentemperatur) - CFloat(strDatensatzPunkte[35, i]))
            Endif
          Else
            'Wenn der Leistungsanteil im Teillastfall kleiner ist als der Anteil für den kleineren Leiter ist wird Betriebsart 1: alles im kleinen Rohr gewählt
            If fltAnteilP * 100 <= Global.fltMLAnteilLeiter2 Then
              global.intMLNetzBetrieb = 1
            Endif
            'Wenn der Leistungsanteil im Teillastfall größer ist als der Anteil für den kleineren Leiter ist und kleiner als der Anteil für den größeren Leiter wird Betriebsart 2: alles im größeren Rohr gewählt
            If fltAnteilP * 100 > Global.fltMLAnteilLeiter2 And fltAnteilP * 100 <= (100 - Global.fltMLAnteilLeiter2) Then
              global.intMLNetzBetrieb = 2
            Endif
            'Wenn der Leistungsanteil im Teillastfall größer ist als der Anteil für den größeren Leiter ist wird Betriebsart 3: alles in beiden Rohren gewählt
            If fltAnteilP * 100 >= (100 - Global.fltMLAnteilLeiter2) Then
              global.intMLNetzBetrieb = 3
            Endif
        
            Select Case Global.intMLNetzBetrieb
            Case 1
              strDatensatzPunkte[25, i] = "0"
              strDatensatzPunkte[35, i] = strDatensatzPunkte[18, i]
            Case 2
              strDatensatzPunkte[25, i] = strDatensatzPunkte[18, i]
              strDatensatzPunkte[35, i] = "0"
            Case 3
              'erst das größere Rohr voll belegen
              strDatensatzPunkte[25, i] = CStr(fltAuslegeleistung * ((100 - Global.fltMLAnteilLeiter2) / 100))
              'dann den Rest auf das kleiner Rohr geben
              strDatensatzPunkte[35, i] = CStr(CFloat(strDatensatzPunkte[18, i]) - CFloat(strDatensatzPunkte[25, i]))
            End Select
          Endif
        'wenn Abnehmer berücksichtigen (Spalte 39) = "0" dann Pakta/b = "0"
        Else
           strDatensatzPunkte[25, i] = "0"
           strDatensatzPunkte[35, i] = "0"
        Endif
      Endif
    Endif
    'Testbit Punkt behandelt wird für alle auf "0" gesetzt
    strDatensatzPunkte[17, i] = "0"
  Next
'------------aktuelle Leistung an den Abnehmern ENDE----------------------------------------------------- 

  
  
'-------------------Massenströme berechnen---------------------------------------------------

For z = 0 To Global.intSchritte
  Global.fltVerlauf = z / Global.intSchritte
  
  'Ausstiegsvariable
  booZ = True

  'Vorbelegung der mit Startwerten 
  For i = 0 To intZeilenPunkte - 1

    fltFaktorRL = 1
    fltFaktorVL = 1
    fltFaktorRL2a = 1
    fltFaktorVL2a = 1
    fltFaktorRL2b = 1
    fltFaktorVL2b = 1
    
    If z = 0 Then
    
      'Setze die Massenströme auf 0
      strDatensatzPunkte[5, i] = "0"      'Massenstrom
      strDatensatzPunkte[19, i] = "0"     'MSakt
      strDatensatzPunkte[24, i] = "0"     'Massenstrom2a
      strDatensatzPunkte[34, i] = "0"     'Massenstrom2b
    
      'Belege die AbnehmerPunkte mit Massenströmen
      'Wenn noch nicht behandelt und kein nachfolger Punkt vorhanden
      If strDatensatzPunkte[17, i] = "0" And strDatensatzPunkte[8, i] = "0" Then
        strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[18, i]) / (Global.cp * Global.fltdeltaTHaus))
        strDatensatzPunkte[19, i] = strDatensatzPunkte[5, i]
    
        If Global.booMehrleiter = True Then
          strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[25, i]) / (Global.cp * Global.fltdeltaTHaus))
          strDatensatzPunkte[26, i] = strDatensatzPunkte[24, i]
          If Global.booGLSPL = True Then
            strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[35, i]) / (Global.cp * Global.fltTWWdT))
          Else
            strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[35, i]) / (Global.cp * Global.fltdeltaTHaus))
          Endif
          strDatensatzPunkte[36, i] = strDatensatzPunkte[34, i]
        Else
          strDatensatzPunkte[24, i] = "0"
          strDatensatzPunkte[26, i] = "0"
          strDatensatzPunkte[34, i] = "0"
          strDatensatzPunkte[36, i] = "0"
        Endif
     
        'Punkt behandelt
        strDatensatzPunkte[17, i] = "1"
      Endif
          
    Else
    
      'Setze die Massenströme auf 0
      strDatensatzPunkte[5, i] = "0"      'Massenstrom
      strDatensatzPunkte[24, i] = "0"     'Massenstrom2a
      strDatensatzPunkte[34, i] = "0"     'Massenstrom2b
      strDatensatzPunkte[17, i] = "0"     'Testbit
      
     
      'Belege die AbnehmerPunkte mit Massenströmen
      If strDatensatzPunkte[20, i] <> "0" Then
        'Wenn aktiver Abnehmer
        If strDatensatzPunkte[39, i] = "1" Then
                
          'Wenn Vorlauftemp < als Min dann 
          ' [GB2:CFLT] If CFlt(strDatensatzPunkte[3, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
          If CFloat(strDatensatzPunkte[3, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
            ' [GB2:CFLT] fltFaktorVL = (Global.fltGrenzVorlauftemperatur / CFlt(strDatensatzPunkte[3, i])) '* (1 + Global.conSchritte / z)
            fltFaktorVL = (Global.fltGrenzVorlauftemperatur / CFloat(strDatensatzPunkte[3, i])) '* (z / Global.conSchritte)
            'If fltFaktorVL > 100 Then fltFaktorVL = 100
          Else
            fltFaktorVL = 1
          Endif
          
          'wenn Rücklauftemperatur < als Min dann
          ' [GB2:CFLT] If CFlt(strDatensatzPunkte[4, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(strDatensatzPunkte[4, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz Then
          If CFloat(strDatensatzPunkte[4, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz 'Or CFloat(strDatensatzPunkte[4, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz Then
            ' [GB2:CFLT] fltFaktorRL = (Global.fltGrenzRuecklauftemperatur / CFlt(strDatensatzPunkte[4, i])) '* (1 + 0.1 * Global.conSchritte / z)   '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
            fltFaktorRL = (Global.fltGrenzRuecklauftemperatur / CFloat(strDatensatzPunkte[4, i])) ' * (z / Global.conSchritte)   '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
  
            'If fltFaktorRL > 100 Then fltFaktorRL = 100
          Else
            fltFaktorRL = 1
            'IF fltFaktorRL < 0.001 THEN fltFaktorRL = 0.001
          Endif
          
          'Übertrage aktuellen Massenstrom
          If fltFaktorVL > 1 Then
            strDatensatzPunkte[19, i] = CStr(CFloat(strDatensatzPunkte[19, i]) * fltFaktorVL)
          Else
            strDatensatzPunkte[19, i] = CStr(CFloat(strDatensatzPunkte[19, i]) * fltFaktorRL)
          Endif
          strDatensatzPunkte[5, i] = strDatensatzPunkte[19, i]
              
          'Fall Mehrleiter
          If Global.booMehrleiter = True Then
            If Global.booGLSPL = True Then
              
              'Leiter1
              ' [GB2:CFLT] If CFlt(strDatensatzPunkte[22, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
              If CFloat(strDatensatzPunkte[22, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                ' [GB2:CFLT] fltFaktorVL2a = (Global.fltGrenzVorlauftemperatur / CFlt(strDatensatzPunkte[22, i])) '* (1 + Global.conSchritte / z)
                fltFaktorVL2a = (Global.fltGrenzVorlauftemperatur / CFloat(strDatensatzPunkte[22, i])) '* (1 + Global.conSchritte / z)
                If fltFaktorVL2a > 10 Then fltFaktorVL2a = 10
              Else
                fltFaktorVL2a = 1
              Endif
              
              'wenn Rücklauftemperatur < als Min oder grßer als max dann
              ' [GB2:CFLT] If CFlt(strDatensatzPunkte[23, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(strDatensatzPunkte[23, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz Then
              If CFloat(strDatensatzPunkte[23, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                ' [GB2:CFLT] fltFaktorRL2a = (Global.fltGrenzRuecklauftemperatur / CFlt(strDatensatzPunkte[23, i]))
                fltFaktorRL2a = (Global.fltGrenzRuecklauftemperatur / CFloat(strDatensatzPunkte[23, i]))
                If fltFaktorRL2a > 10 Then fltFaktorRL2a = 10
              Else
                fltFaktorRL2a = 1
              Endif
              
              'Übertrage aktuellen Massenstrom
              If fltFaktorVL2a > 1 Then
                strDatensatzPunkte[26, i] = CStr(CFloat(strDatensatzPunkte[26, i]) * fltFaktorVL2a)
              Else
                strDatensatzPunkte[26, i] = CStr(CFloat(strDatensatzPunkte[26, i]) * fltFaktorRL2a)
              Endif
              strDatensatzPunkte[24, i] = strDatensatzPunkte[26, i]
              
              
              'Leiter2
              ' [GB2:CFLT] If CFlt(strDatensatzPunkte[32, i]) < Global.fltTWWVL - Global.fltGrenzRuecklauftemperaturToleranz Then
              If CFloat(strDatensatzPunkte[32, i]) < Global.fltTWWVL - Global.fltGrenzRuecklauftemperaturToleranz Then
                ' [GB2:CFLT] fltFaktorVL2b = (Global.fltTWWVL / CFlt(strDatensatzPunkte[32, i])) '* (1 + Global.conSchritte / z)
                fltFaktorVL2b = (Global.fltTWWVL / CFloat(strDatensatzPunkte[32, i])) '* (1 + Global.conSchritte / z)
                If fltFaktorVL2b > 10 Then fltFaktorVL2b = 10
              Else
                fltFaktorVL2b = 1
              Endif
              
              'wenn Rücklauftemperatur < als Min dann
              ' [GB2:CFLT] If CFlt(strDatensatzPunkte[33, i]) < Global.fltTWWRL - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(strDatensatzPunkte[33, i]) > Global.fltTWWRL + Global.fltGrenzRuecklauftemperaturToleranz Then
              If CFloat(strDatensatzPunkte[33, i]) < Global.fltTWWRL - Global.fltGrenzRuecklauftemperaturToleranz Then
                ' [GB2:CFLT] fltFaktorRL2b = (Global.fltTWWRL / CFlt(strDatensatzPunkte[33, i]))
                fltFaktorRL2b = (Global.fltTWWRL / CFloat(strDatensatzPunkte[33, i]))
                If fltFaktorRL2b > 10 Then fltFaktorRL2b = 10
              Else
                fltFaktorRL2b = 1
              Endif
              
              'Übertrage aktuellen Massenstrom
              If fltFaktorVL2b > 1 Then
                strDatensatzPunkte[36, i] = CStr(CFloat(strDatensatzPunkte[36, i]) * fltFaktorVL2b)
              Else
                strDatensatzPunkte[36, i] = CStr(CFloat(strDatensatzPunkte[36, i]) * fltFaktorRL2b)
              Endif
              strDatensatzPunkte[34, i] = strDatensatzPunkte[36, i]
            
            'wenn NICHT Grundlast - Spitzenlastfall  
            Else
                        
              'Leiter1
              If global.intMLNetzBetrieb = 2 Or global.intMLNetzBetrieb = 3 Then
                'Wenn Vorlauftemp < als Min dann 
                ' [GB2:CFLT] If CFlt(strDatensatzPunkte[22, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                If CFloat(strDatensatzPunkte[22, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                  ' [GB2:CFLT] fltFaktorVL2a = (Global.fltGrenzVorlauftemperatur / CFlt(strDatensatzPunkte[22, i])) '* (1 + Global.conSchritte / z)
                  fltFaktorVL2a = (Global.fltGrenzVorlauftemperatur / CFloat(strDatensatzPunkte[22, i])) '* (1 + Global.conSchritte / z)
                  If fltFaktorVL2a > 10 Then fltFaktorVL2a = 10
                Else
                  fltFaktorVL2a = 1
                Endif
        
                'wenn Rücklauftemperatur < als Min dann
                ' [GB2:CFLT] If CFlt(strDatensatzPunkte[23, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(strDatensatzPunkte[23, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz Then
                If CFloat(strDatensatzPunkte[23, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                  ' [GB2:CFLT] fltFaktorRL2a = (Global.fltGrenzRuecklauftemperatur / CFlt(strDatensatzPunkte[23, i]))  '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
                  fltFaktorRL2a = (Global.fltGrenzRuecklauftemperatur / CFloat(strDatensatzPunkte[23, i]))  '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
                  If fltFaktorRL2a > 10 Then fltFaktorRL2a = 10
                Else
                  fltFaktorRL2a = 1
                  'IF fltFaktorRL < 0.001 THEN fltFaktorRL = 0.001
                Endif
        
                'Übertrage aktuellen Massenstrom
                If fltFaktorVL2a > 1 Then
                  strDatensatzPunkte[26, i] = CStr(CFloat(strDatensatzPunkte[26, i]) * fltFaktorVL2a)
                Else
                  strDatensatzPunkte[26, i] = CStr(CFloat(strDatensatzPunkte[26, i]) * fltFaktorRL2a)
                Endif
                strDatensatzPunkte[24, i] = strDatensatzPunkte[26, i]
              Endif
              
              'Leiter2
              If global.intMLNetzBetrieb = 1 Or global.intMLNetzBetrieb = 3 Then
                'Wenn Vorlauftemp < als Min dann 
                ' [GB2:CFLT] If CFlt(strDatensatzPunkte[32, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                If CFloat(strDatensatzPunkte[32, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                  ' [GB2:CFLT] fltFaktorVL2b = (Global.fltGrenzVorlauftemperatur / CFlt(strDatensatzPunkte[32, i])) '* (1 + Global.conSchritte / z)
                  fltFaktorVL2b = (Global.fltGrenzVorlauftemperatur / CFloat(strDatensatzPunkte[32, i])) '* (1 + Global.conSchritte / z)
                  If fltFaktorVL2b > 10 Then fltFaktorVL2b = 10
                Else
                  fltFaktorVL2b = 1
                Endif
          
                'wenn Rücklauftemperatur < als Min dann
                ' [GB2:CFLT] If CFlt(strDatensatzPunkte[33, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(strDatensatzPunkte[33, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz Then
                If CFloat(strDatensatzPunkte[33, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                  ' [GB2:CFLT] fltFaktorRL2b = (Global.fltGrenzRuecklauftemperatur / CFlt(strDatensatzPunkte[33, i]))  '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
                  fltFaktorRL2b = (Global.fltGrenzRuecklauftemperatur / CFloat(strDatensatzPunkte[33, i]))  '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
                  If fltFaktorRL2b > 10 Then fltFaktorRL2b = 10
                  'IF fltFaktorRL < 0.001 THEN fltFaktorRL = 0.001
                Else
                  fltFaktorRL2b = 1
                Endif
          
                'Übertrage aktuellen Massenstrom
                If fltFaktorVL2b > 1 Then
                  strDatensatzPunkte[36, i] = CStr(CFloat(strDatensatzPunkte[36, i]) * fltFaktorVL2b)
                Else
                  strDatensatzPunkte[36, i] = CStr(CFloat(strDatensatzPunkte[36, i]) * fltFaktorRL2b)
                Endif
                strDatensatzPunkte[34, i] = strDatensatzPunkte[36, i]
              Endif
            Endif
          Endif
                  
        Endif  'IF strDatensatzPunkte[39, i] = "1" THEN
        'Testbit für den Abnehmer auf 1 setzen
        strDatensatzPunkte[17, i] = "1"
      Endif
    
    Endif
  Next
     
  
  
  For j = 0 To intZeilenPunkte - 1
    a = 0
    For i = 0 To intZeilenPunkte - 1
      'Wenn die Anzahl der Nachknoten > 0
      If CInt(strDatensatzPunkte[8, i]) > 0
        
        'Wenn es einen Nachknoten gibt
        If CInt(strDatensatzPunkte[8, i]) = 1 Then
          
          'Wenn Qakt = 0 (der aktuelle Punkt kein Abnehmer ist) UND der nachfolgende Punkte bereits behandelt wurde dann
          If strDatensatzPunkte[18, i] = "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] <> "0" Then
            'übertrage den Massenstrom des Folgepunktes auf den aktuellen
            strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[9, i] - 1)]))
          
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[9, i] - 1)]))
              strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[9, i] - 1)]))
            Endif
            
            'Punkt bearbeitet => Testbit = "1"
            strDatensatzPunkte[17, i] = "1"
              
          Endif
          
          'Fall Zwischenabnehmer!!!          
          If strDatensatzPunkte[20, i] <> "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] <> "0" Then
            'Leistung wird in diesem Punkt gelöscht
            strDatensatzPunkte[39, i] = "0"
            strDatensatzPunkte[15, i] = "0"
            strDatensatzPunkte[18, i] = "0"
            strDatensatzPunkte[25, i] = "0"
            strDatensatzPunkte[35, i] = "0"
                        
            'Behandlung wie normalen Punkt
            strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[9, i] - 1)]))
            
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[9, i] - 1)]))
              strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[9, i] - 1)]))
            Endif
            
            'Punkt bearbeitet => Testbit = "1"
            strDatensatzPunkte[17, i] = "1"
          Endif
          
        Endif
        
        
        'Wenn es zwei Nachknoten gibt
        If CInt(strDatensatzPunkte[8, i]) = 2 Then
          
          'wenn der Massenstrom des 1. Nachfolgen Punktes <> 0 UND der Massenstrom des 2. Nachfolgen Punktes <> 0 dann
          If strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] <> "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[11, i] - 1)] <> "0" Then
            'ist der Massentstrom des aktuellen Punktes die Summe der beiden nachfolgenden Massenströme (Makt= Mn1+Mn2)
            strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[11, i] - 1)]))

            If Global.booMehrleiter = True Then
              strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[11, i] - 1)]))
              strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[11, i] - 1)]))
            Endif
            
            'Punkt bearbeitet => Testbit = "1"
            strDatensatzPunkte[17, i] = "1"
          Endif
            
        Endif
        
        
        'Wenn es drei Nachknoten gibt  
        If CInt(strDatensatzPunkte[8, i]) = 3 Then
          'wenn der Massenstrom des 1. Nachfolgen Punktes <> 0 UND der Massenstrom des 2. Nachfolgen Punktes <> 0 UND der Massenstrom des 3. Nachfolgen Punktes <> 0 dann
          If strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] <> "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[11, i] - 1)] <> "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[13, i] - 1)] <> "0" Then
            'ist der Massentstrom des aktuellen Punktes die Summe der drei nachfolgenden Massenströme (Makt= Mn1+Mn2+Mn3)
            strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[11, i] - 1)] + CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[13, i] - 1)])))
      
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[11, i] - 1)] + CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[13, i] - 1)])))
              strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[11, i] - 1)] + CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[13, i] - 1)])))
            Endif
          
            'Punkt bearbeitet => Testbit = "1"
            strDatensatzPunkte[17, i] = "1"
          Endif
           
        Endif
        
      Endif
      
      'wenn Testbit (behandelter aktueller Punkt) = "1"  dann zähle a + 1 (a ist die Anzahl der behandelten Punkte)
      If strDatensatzPunkte[17, i] = "1" Then a = a + 1
    
    Next
    
    'wenn alle Punkte behandelt sind, dann 
    If a = intZeilenPunkte Then
      'EXIT die Schleife um Zeit zu sparen
      Goto ENDEMASSEN
    Endif
  
  Next
'  Message("Bei Massenstrombelegung maximale Anzahl an Durchläufen benötigt!")
ENDEMASSEN:

  For i = 0 To intZeilenPunkte - 1
    'Warnmeldung
    'IF strDatensatzPunkte[5, i] = "0" THEN 
      'Message("Warnung: Am Punkt " & CStr(i + 1) & " ist der Massenstrom = 0")
    'ENDIF 
    
    'Übertrage Massenstrom von Punkten auf Trasse (wenn Trassennummer vorher <> "0") 
    If strDatensatzPunkte[7, i] <> "0" Then
      strDatensatzNetzTrasse[4, strDatensatzPunkte[7, i] - 1] = strDatensatzPunkte[5, i]
      
      If Global.booMehrleiter = True Then
        strDatensatzNetzTrasse[15, strDatensatzPunkte[7, i] - 1] = strDatensatzPunkte[24, i]
        strDatensatzNetzTrasse[26, strDatensatzPunkte[7, i] - 1] = strDatensatzPunkte[34, i]
      Else
        strDatensatzNetzTrasse[15, strDatensatzPunkte[7, i] - 1] = "0"
        strDatensatzNetzTrasse[26, strDatensatzPunkte[7, i] - 1] = "0"
      Endif
    
    Endif
  Next
'-------------------Massenströme berechnen ENDE---------------------------------------------------  


'-------------------Berechne Temperaturen-----------------------------------------------------------     
  For i = 0 To intZeilenPunkte - 1
    'Setze die Temperaturen auf 0
    strDatensatzPunkte[3, i] = "0"
    strDatensatzPunkte[4, i] = "0"
    
    strDatensatzPunkte[22, i] = "0"
    strDatensatzPunkte[23, i] = "0"
    
    strDatensatzPunkte[32, i] = "0"
    strDatensatzPunkte[33, i] = "0"

    'suche Einspeiser und gebe ihm die StartTemp  
    If strDatensatzPunkte[6, i] = "0" And strDatensatzPunkte[9, i] <> "0" Then
      strDatensatzPunkte[3, i] = CStr(Global.fltVorlauftemperatur)
      
      If Global.booMehrleiter = True Then
        If Global.booGLSPL = True Then
          strDatensatzPunkte[22, i] = CStr(Global.fltVorlauftemperatur)
          strDatensatzPunkte[32, i] = CStr(Global.fltTWWVLEIN)
        Else
          strDatensatzPunkte[22, i] = CStr(Global.fltVorlauftemperatur)
          strDatensatzPunkte[32, i] = CStr(Global.fltVorlauftemperatur)
        Endif
      Endif
      
      'Punkt bearbeitet => Testbit = "0"; WICHTIGE INFO: im Bereich der Vorlauftemperatur bedeutet "1" noch NICHT behandelt!!!!
      strDatensatzPunkte[17, i] = "0"
   Endif
  Next
  
  
'---- Vorlauftemperaturen-------------------------------------------------------------------------------------  
  'a ist Zählvariable der belegten Punkte und wird 1 gesetzt (Einspeiser wurde schon behandelt)  
  a = 1
  For j = 0 To intZeilenPunkte - 1
    
    For i = 0 To intZeilenPunkte - 1
      'wenn der aktuelle Punkt kein Abnehmerpunkt ist    
      If strDatensatzPunkte[8, i] <> "0" Then
        'wenn aktueller Punkt schon behandelt wurde (die Vorlauftemperatur im aktuellen Punkt belegt) und der 1. nachfolgende Punkt noch nicht behandelt wurde, dann
        If strDatensatzPunkte[17, i] = "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i]) - 1] = "1" Then
        
          'für den Fall wenn die Anzahl der Nachknoten:
          Select Case strDatensatzPunkte[8, i]
          Case 1
            '1: dann wird die Vorlauftemperatur des nachfolgenden Punktes berechnet 
            strDatensatzPunkte[3, CInt(strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[10, i]) - 1])))
            strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[22, CInt(strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[10, i]) - 1])))
              strDatensatzPunkte[32, CInt(strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[10, i]) - 1])))
            Endif
            'wenn Testbit (behandelte Punkte) = "0"  dann zähle a + 1 (a ist die Anzahl der behandelten Punkte)
             a = a + 1
                      
          Case 2
            '2: dann wird die Vorlauftemperatur der beiden nachfolgenden Punkte berechnet 
            strDatensatzPunkte[3, CInt(strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[10, i]) - 1])))
            strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[22, CInt(strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[10, i]) - 1])))
              strDatensatzPunkte[32, CInt(strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[10, i]) - 1])))
            Endif
                    
            strDatensatzPunkte[3, CInt(strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[12, i]) - 1])))
            strDatensatzPunkte[17, CInt(strDatensatzPunkte[11, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[22, CInt(strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[12, i]) - 1])))
              strDatensatzPunkte[32, CInt(strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[12, i]) - 1])))
            Endif
            'wenn Testbit (behandelte Punkte) = "0"  dann zähle a + 2 (a ist die Anzahl der behandelten Punkte)
             a = a + 2
          
          Case 3
            '3: dann wird die Vorlauftemperatur der drei nachfolgenden Punkte berechnet 
            strDatensatzPunkte[3, CInt(strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[10, i]) - 1])))
            strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[22, CInt(strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[10, i]) - 1])))
              strDatensatzPunkte[32, CInt(strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[10, i]) - 1])))
            Endif
          
            strDatensatzPunkte[3, CInt(strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[12, i]) - 1])))
            strDatensatzPunkte[17, CInt(strDatensatzPunkte[11, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[22, CInt(strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[12, i]) - 1])))
              strDatensatzPunkte[32, CInt(strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[12, i]) - 1])))
            Endif
          
            strDatensatzPunkte[3, CInt(strDatensatzPunkte[13, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[14, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[14, i]) - 1])))
            strDatensatzPunkte[17, CInt(strDatensatzPunkte[13, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[22, CInt(strDatensatzPunkte[13, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[14, i]) - 1])))
              strDatensatzPunkte[32, CInt(strDatensatzPunkte[13, i]) - 1] = CStr(funTemperatur(CFloat(strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[14, i]) - 1])))
            Endif
          
            'wenn Testbit (behandelte Punkte) = "0"  dann zähle a + 3 (a ist die Anzahl der behandelten Punkte)
            a = a + 3
          End Select
      
        Endif
        
      Endif
    Next

    'wenn alle Punkte mit Vorlauftemperatur <> 0 belegt sind, dann 'EXIT die Schleife um Zeit zu sparen
    If a = intZeilenPunkte Then Goto ENDETVL
  Next
  Message("Bei Vorlauftemperaturbelegung maximale Anzahl an Durchläufen benötigt!")
ENDETVL:
'---- Vorlauftemperaturen ENDE ------





'----Rücklauftemperaturen----  
  For i = 0 To intZeilenPunkte - 1
    'Setze die Rücklauftemperaturen auf 0
    strDatensatzPunkte[4, i] = "0"
    'Mehrleiter   
    strDatensatzPunkte[23, i] = "0"
    strDatensatzPunkte[33, i] = "0"
    strDatensatzPunkte[17, i] = "0"
  Next

  
  'Belege die AbnehmerPunkte mit Rücklauftemperaturen (nur Endpunkte!!)
  For i = 0 To intZeilenPunkte - 1
    
    'wenn Punkt Testbit = "0" (unbehandelt) UND keine Anzahl Nachknoten = 0 (Abnehmer) dann
    If strDatensatzPunkte[17, i] = "0" And strDatensatzPunkte[8, i] = "0" Then
      'wenn Massenstrom > 0
      If CFloat(strDatensatzPunkte[19, i]) > 0 Then
        'Rücklauftemperatur = Vorlauftemperatur - (P/(cp*m))
        strDatensatzPunkte[4, i] = CStr(CFloat(strDatensatzPunkte[3, i]) - (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * CFloat(strDatensatzPunkte[19, i])))) 'dT aus Massenstromakt berechnet! Global.fltdeltaTHaus  Global.fltdeltaTHaus)
      Else
        strDatensatzPunkte[4, i] = CStr(Global.fltUmgebungstemperatur)
      Endif
            
      If Global.booMehrleiter = True Then
      
        If CFloat(strDatensatzPunkte[26, i]) > 0 Then
          strDatensatzPunkte[23, i] = CStr(CFloat(strDatensatzPunkte[22, i]) - (CFloat(strDatensatzPunkte[25, i]) / (Global.cp * CFloat(strDatensatzPunkte[26, i])))) 'dT aus Massenstromakt berechnet! Global.fltdeltaTHaus  Global.fltdeltaTHaus)
        Else
          strDatensatzPunkte[23, i] = CStr(Global.fltUmgebungstemperatur)
        Endif
        
        If CFloat(strDatensatzPunkte[36, i]) > 0 Then
          strDatensatzPunkte[33, i] = CStr(CFloat(strDatensatzPunkte[32, i]) - (CFloat(strDatensatzPunkte[35, i]) / (Global.cp * CFloat(strDatensatzPunkte[36, i])))) 'dT aus Massenstromakt berechnet! Global.fltdeltaTHaus  Global.fltdeltaTHaus)
        Else
          strDatensatzPunkte[33, i] = CStr(Global.fltUmgebungstemperatur)
        Endif
      Endif
      'Aktueller Punkt wurde behandelt (Testbit = "1")
      strDatensatzPunkte[17, i] = "1"
      
      'Abweichung von der Solltemperatur im Sollbereich ? (strDatensatzPunkte[39, i] = "1" And CFloat(strDatensatzPunkte[4, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz) Or
      If (strDatensatzPunkte[39, i] = "1" And CFloat(strDatensatzPunkte[4, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz) Then
        booZ = False
'IF z > 3 THEN Message(i & " VL: " & strDatensatzPunkte[4, i]) 
      Endif
      If strDatensatzPunkte[39, i] = "1" And CFloat(strDatensatzPunkte[3, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
        booZ = False
'IF z > 3 THEN Message(i & " RL: " & strDatensatzPunkte[3, i]) 
      Endif
      If global.booGLSPL = True Then '(strDatensatzPunkte[39, i] = "1" And CFloat(strDatensatzPunkte[33, i]) > Global.fltTWWRL + Global.fltGrenzRuecklauftemperaturToleranz) Or
        If (strDatensatzPunkte[39, i] = "1" And CFloat(strDatensatzPunkte[33, i]) < Global.fltTWWRL - Global.fltGrenzRuecklauftemperaturToleranz) Then
          booZ = False
        Endif
        If strDatensatzPunkte[39, i] = "1" And CFloat(strDatensatzPunkte[32, i]) < Global.fltTWWVL - Global.fltGrenzRuecklauftemperaturToleranz Then
          booZ = False
        Endif
      Endif
    Endif
  Next

  For j = 0 To intZeilenPunkte - 1
    'a ist Zählvariable der belegten Punkte und wird 0 gesetzt
    a = 0
    
    For i = 0 To intZeilenPunkte - 1
      
      'wenn Anzahl der Nachnkoten > 0 dann
      If CInt(strDatensatzPunkte[8, i]) > 0
        
        'wenn die Anzahl der Nachknoten = 1 dann
        If CInt(strDatensatzPunkte[8, i]) = 1 Then
          
          'wenn aktueller Knoten noch nicht behandelt UND der Nachknoten schon behandelt Testbit = "1" dann
          If strDatensatzPunkte[17, i] = "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] = "1" Then
            'Rücklauftemperatur wird berechnet
            strDatensatzPunkte[4, i] = CStr(funTemperatur(CFloat(strDatensatzPunkte[4, CInt(strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[10, i]) - 1])))
          
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[23, i] = CStr(funTemperatur(CFloat(strDatensatzPunkte[23, CInt(strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[10, i]) - 1])))
              strDatensatzPunkte[33, i] = CStr(funTemperatur(CFloat(strDatensatzPunkte[33, CInt(strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[10, i]) - 1])))
            Endif
            'aktueller Knoten wurde behandelt
            strDatensatzPunkte[17, i] = "1"
          Endif
          
        Endif

      
        'wenn die Anzahl der Nachknoten = 2 dann
        If CInt(strDatensatzPunkte[8, i]) = 2 Then
          
          'wenn aktueller Knoten noch nicht behandelt UND die beiden Nachknoten schon behandelt Testbit = "1" dann
          If strDatensatzPunkte[17, i] = "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] = "1" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[11, i] - 1)] = "1" Then
            'berechne Temperatur1 aus dem 1. nachfolgenden Punkt
            Temperatur1 = funTemperatur(CFloat(strDatensatzPunkte[4, CInt(strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[10, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur1a = funTemperatur(CFloat(strDatensatzPunkte[23, CInt(strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[10, i]) - 1]))
              Temperatur1b = funTemperatur(CFloat(strDatensatzPunkte[33, CInt(strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[10, i]) - 1]))
            Endif
            
            'berechne Temperatur2 aus dem 2. nachfolgenden Punkt
            Temperatur2 = funTemperatur(CFloat(strDatensatzPunkte[4, CInt(strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[12, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur2a = funTemperatur(CFloat(strDatensatzPunkte[23, CInt(strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[12, i]) - 1]))
              Temperatur2b = funTemperatur(CFloat(strDatensatzPunkte[33, CInt(strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[12, i]) - 1]))
            Endif
            
            'berechne Massenstrom1 aus dem 1. nachfolgenden Punkt
            Massenstrom1 = CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[10, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom1a = CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[10, i]) - 1])
              Massenstrom1b = CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[10, i]) - 1])
            Endif
            
            'berechne Massenstrom2 aus dem 2. nachfolgenden Punkt
            Massenstrom2 = CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[12, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom2a = CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[12, i]) - 1])
              Massenstrom2b = CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[12, i]) - 1])
            Endif
            
            'Berechne Mischtemperatur (NOCH EINFÜGEN wenn Massenströme = 0 dann Mischtemp = Umgebungstemp!!!)
            If (Massenstrom1 + Massenstrom2) = 0 Then
              strDatensatzPunkte[3, i] = CStr(Global.fltUmgebungstemperatur)
              strDatensatzPunkte[4, i] = CStr(Global.fltUmgebungstemperatur)
            Else
              strDatensatzPunkte[4, i] = CStr((Temperatur1 * Massenstrom1 + Temperatur2 * Massenstrom2) / (Massenstrom1 + Massenstrom2))
            Endif
            
            If Global.booMehrleiter = True Then
              If (Massenstrom1a + Massenstrom2a) = 0 Then
                strDatensatzPunkte[22, i] = CStr(Global.fltUmgebungstemperatur)
                strDatensatzPunkte[23, i] = CStr(Global.fltUmgebungstemperatur)
              Else
                strDatensatzPunkte[23, i] = CStr((Temperatur1a * Massenstrom1a + Temperatur2a * Massenstrom2a) / (Massenstrom1a + Massenstrom2a))
              Endif
              If (Massenstrom1b + Massenstrom2b) = 0 Then
                strDatensatzPunkte[32, i] = CStr(Global.fltUmgebungstemperatur)
                strDatensatzPunkte[33, i] = CStr(Global.fltUmgebungstemperatur)
              Else
                strDatensatzPunkte[33, i] = CStr((Temperatur1b * Massenstrom1b + Temperatur2b * Massenstrom2b) / (Massenstrom1b + Massenstrom2b))
              Endif
            Endif
            'aktueller Knoten wurde behandelt
            strDatensatzPunkte[17, i] = "1"
          Endif
        
        Endif
          
        
        'wenn die Anzahl der Nachknoten = 3 dann
        If CInt(strDatensatzPunkte[8, i]) = 3 Then
        
          'wenn aktueller Knoten noch nicht behandelt UND die drei Nachknoten schon behandelt Testbit = "1" dann
          If strDatensatzPunkte[17, i] = "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] = "1" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[11, i] - 1)] = "1" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[13, i] - 1)] = "1" Then
            'berechne Temperatur1 aus dem 1. nachfolgenden Punkt
            Temperatur1 = funTemperatur(CFloat(strDatensatzPunkte[4, CInt(strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[10, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur1a = funTemperatur(CFloat(strDatensatzPunkte[23, CInt(strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[10, i]) - 1]))
              Temperatur1b = funTemperatur(CFloat(strDatensatzPunkte[33, CInt(strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[10, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[10, i]) - 1]))
            Endif
            
            'berechne Temperatur2 aus dem 2. nachfolgenden Punkt
            Temperatur2 = funTemperatur(CFloat(strDatensatzPunkte[4, CInt(strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[12, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur2a = funTemperatur(CFloat(strDatensatzPunkte[23, CInt(strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[12, i]) - 1]))
              Temperatur2b = funTemperatur(CFloat(strDatensatzPunkte[33, CInt(strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[12, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[12, i]) - 1]))
            Endif
            
            'berechne Temperatur3 aus dem 3. nachfolgenden Punkt
            Temperatur3 = funTemperatur(CFloat(strDatensatzPunkte[4, CInt(strDatensatzPunkte[13, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[14, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[14, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur3a = funTemperatur(CFloat(strDatensatzPunkte[23, CInt(strDatensatzPunkte[13, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[14, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[14, i]) - 1]))
              Temperatur3b = funTemperatur(CFloat(strDatensatzPunkte[33, CInt(strDatensatzPunkte[13, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(strDatensatzNetzTrasse[2, CInt(strDatensatzPunkte[14, i]) - 1]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, CInt(strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[14, i]) - 1]))
            Endif
            
            'berechne Massenstrom2 aus dem 1. nachfolgenden Punkt
            Massenstrom1 = CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[10, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom1a = CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[10, i]) - 1])
              Massenstrom1b = CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[10, i]) - 1])
            Endif
            
            'berechne Massenstrom2 aus dem 2. nachfolgenden Punkt
            Massenstrom2 = CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[12, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom2a = CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[12, i]) - 1])
              Massenstrom2b = CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[12, i]) - 1])
            Endif
            
            'berechne Massenstrom2 aus dem 3. nachfolgenden Punkt
            Massenstrom3 = CFloat(strDatensatzNetzTrasse[4, CInt(strDatensatzPunkte[14, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom3a = CFloat(strDatensatzNetzTrasse[15, CInt(strDatensatzPunkte[14, i]) - 1])
              Massenstrom3b = CFloat(strDatensatzNetzTrasse[26, CInt(strDatensatzPunkte[14, i]) - 1])
            Endif
            
            'Berechne Mischtemperatur
            If (Massenstrom1 + Massenstrom2 + Massenstrom3) = 0 Then
              strDatensatzPunkte[3, i] = CStr(Global.fltUmgebungstemperatur)
              strDatensatzPunkte[4, i] = CStr(Global.fltUmgebungstemperatur)
            Else
              strDatensatzPunkte[4, i] = CStr((Temperatur1 * Massenstrom1 + Temperatur2 * Massenstrom2 + Temperatur3 * Massenstrom3) / (Massenstrom1 + Massenstrom2 + Massenstrom3))
            Endif
            
            If Global.booMehrleiter = True Then
              If (Massenstrom1a + Massenstrom2a + Massenstrom3a) = 0 Then
                strDatensatzPunkte[22, i] = CStr(Global.fltUmgebungstemperatur)
                strDatensatzPunkte[23, i] = CStr(Global.fltUmgebungstemperatur)
              Else
                strDatensatzPunkte[23, i] = CStr((Temperatur1a * Massenstrom1a + Temperatur2a * Massenstrom2a + Temperatur3a * Massenstrom3a) / (Massenstrom1a + Massenstrom2a + Massenstrom3a))
              Endif
              
              If (Massenstrom1b + Massenstrom2b + Massenstrom3b) = 0 Then
                strDatensatzPunkte[32, i] = CStr(Global.fltUmgebungstemperatur)
                strDatensatzPunkte[33, i] = CStr(Global.fltUmgebungstemperatur)
              Else
                strDatensatzPunkte[33, i] = CStr((Temperatur1b * Massenstrom1b + Temperatur2b * Massenstrom2b + Temperatur3b * Massenstrom3b) / (Massenstrom1b + Massenstrom2b + Massenstrom3b))
              Endif
            Endif
            'aktueller Knoten wurde behandelt
            strDatensatzPunkte[17, i] = "1"
          Endif
          
        Endif
        
      Endif
            'wenn Testbit (behandelter aktueller Punkt) = "1"  dann zähle a + 1 (a ist die Anzahl der behandelten Punkte)
      If strDatensatzPunkte[17, i] = "1" Then a = a + 1
    
    Next
    'wenn alle Punkte mit Rücklauftemperatur <> 0 belegt sind, dann 'EXIT die Schleife um Zeit zu sparen
    If a = intZeilenPunkte Then Goto ENDETRL
  
  Next
  Message("Bei Rücklauftemperaturbelegung maximale Anzahl an Durchläufen benötigt!")
ENDETRL:

'----Rücklauftemperaturen ENDE----  
'-------------------Berechne Temperaturen ENDE-----------------------------------------------------------     
  
  If booZ = True Then Goto ENDEZ

Next
ENDEZ:
Message("Durchläufe: " & CStr(z + 1))

'-----------------Druckverlust, Mitteltemperaturen und Wärmeverluste auf der Trasse-----------------------
  For i = 0 To intZeilenNetzTrasse - 1
    'wenn der Massenstrom auf der Trasse <> "0"
    If strDatensatzNetzTrasse[4, i] <> "0" Then
      'Mitteltemperatur Vorlauftrasse
      strDatensatzNetzTrasse[8, i] = CStr((CFloat((strDatensatzPunkte[3, CInt(strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(strDatensatzPunkte[3, CInt(strDatensatzNetzTrasse[1, i]) - 1])) / 2))
      If Global.booMehrleiter = True Then
        strDatensatzNetzTrasse[19, i] = CStr((CFloat((strDatensatzPunkte[22, CInt(strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(strDatensatzPunkte[22, CInt(strDatensatzNetzTrasse[1, i]) - 1])) / 2))
        strDatensatzNetzTrasse[30, i] = CStr((CFloat((strDatensatzPunkte[32, CInt(strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(strDatensatzPunkte[32, CInt(strDatensatzNetzTrasse[1, i]) - 1])) / 2))
      Endif
    
      'Mitteltemperatur Rücklauftrasse  
      strDatensatzNetzTrasse[9, i] = ((CFloat(strDatensatzPunkte[4, CInt(strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(strDatensatzPunkte[4, CInt(strDatensatzNetzTrasse[1, i]) - 1])) / 2)
      If Global.booMehrleiter = True Then
        strDatensatzNetzTrasse[20, i] = CStr((CFloat((strDatensatzPunkte[23, CInt(strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(strDatensatzPunkte[23, CInt(strDatensatzNetzTrasse[1, i]) - 1])) / 2))
        strDatensatzNetzTrasse[31, i] = CStr((CFloat((strDatensatzPunkte[33, CInt(strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(strDatensatzPunkte[33, CInt(strDatensatzNetzTrasse[1, i]) - 1])) / 2))
      Endif
    
      'Wärmeverlust Vorlauftrasse absolut
      fltQ_VL = (CFloat(strDatensatzNetzTrasse[4, i]) * Global.cp * 1000 * (CFloat(strDatensatzPunkte[3, CInt(strDatensatzNetzTrasse[0, i]) - 1]) - funTemperatur(CFloat(strDatensatzPunkte[3, CInt(strDatensatzNetzTrasse[0, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(strDatensatzNetzTrasse[2, i]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, i]) / 2), CFloat(strDatensatzNetzTrasse[3, i]) / 2, CFloat(strDatensatzNetzTrasse[3, i]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, i]) / 2), CFloat(strDatensatzNetzTrasse[4, i]))))
      strDatensatzNetzTrasse[10, i] = CStr(fltQ_VL)
      If Global.booMehrleiter = True Then
        fltQ_VLa = (CFloat(strDatensatzNetzTrasse[15, i]) * Global.cp * 1000 * (CFloat(strDatensatzPunkte[22, CInt(strDatensatzNetzTrasse[0, i]) - 1]) - funTemperatur(CFloat(strDatensatzPunkte[22, CInt(strDatensatzNetzTrasse[0, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(strDatensatzNetzTrasse[2, i]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, i]) / 2), CFloat(strDatensatzNetzTrasse[14, i]) / 2, CFloat(strDatensatzNetzTrasse[14, i]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, i]) / 2), CFloat(strDatensatzNetzTrasse[15, i]))))
        fltQ_VLb = (CFloat(strDatensatzNetzTrasse[26, i]) * Global.cp * 1000 * (CFloat(strDatensatzPunkte[32, CInt(strDatensatzNetzTrasse[0, i]) - 1]) - funTemperatur(CFloat(strDatensatzPunkte[32, CInt(strDatensatzNetzTrasse[0, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(strDatensatzNetzTrasse[2, i]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, i]) / 2), CFloat(strDatensatzNetzTrasse[25, i]) / 2, CFloat(strDatensatzNetzTrasse[25, i]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, i]) / 2), CFloat(strDatensatzNetzTrasse[26, i]))))
        strDatensatzNetzTrasse[21, i] = CStr(fltQ_VLa)
        strDatensatzNetzTrasse[32, i] = CStr(fltQ_VLb)
      Endif
         
      'Wärmeverlust Rücklauftrasse absolut
      fltQ_RL = (CFloat(strDatensatzNetzTrasse[4, i]) * Global.cp * 1000 * (CFloat(strDatensatzPunkte[4, CInt(strDatensatzNetzTrasse[1, i]) - 1]) - funTemperatur(CFloat(strDatensatzPunkte[4, CInt(strDatensatzNetzTrasse[1, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(strDatensatzNetzTrasse[2, i]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, i]) / 2), CFloat(strDatensatzNetzTrasse[3, i]) / 2, CFloat(strDatensatzNetzTrasse[3, i]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[3, i]) / 2), CFloat(strDatensatzNetzTrasse[4, i]))))
      strDatensatzNetzTrasse[11, i] = CStr(fltQ_RL)
      If Global.booMehrleiter = True Then
        fltQ_RLa = (CFloat(strDatensatzNetzTrasse[15, i]) * Global.cp * 1000 * (CFloat(strDatensatzPunkte[23, CInt(strDatensatzNetzTrasse[1, i]) - 1]) - funTemperatur(CFloat(strDatensatzPunkte[23, CInt(strDatensatzNetzTrasse[1, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(strDatensatzNetzTrasse[2, i]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, i]) / 2), CFloat(strDatensatzNetzTrasse[14, i]) / 2, CFloat(strDatensatzNetzTrasse[14, i]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[14, i]) / 2), CFloat(strDatensatzNetzTrasse[15, i]))))
        fltQ_RLb = (CFloat(strDatensatzNetzTrasse[26, i]) * Global.cp * 1000 * (CFloat(strDatensatzPunkte[33, CInt(strDatensatzNetzTrasse[1, i]) - 1]) - funTemperatur(CFloat(strDatensatzPunkte[33, CInt(strDatensatzNetzTrasse[1, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(strDatensatzNetzTrasse[2, i]), funLambda(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, i]) / 2), CFloat(strDatensatzNetzTrasse[25, i]) / 2, CFloat(strDatensatzNetzTrasse[25, i]) / 2 + funDaemmstaerke(strDatensatzRohre, CFloat(strDatensatzNetzTrasse[25, i]) / 2), CFloat(strDatensatzNetzTrasse[26, i]))))
        strDatensatzNetzTrasse[22, i] = CStr(fltQ_RLa)
        strDatensatzNetzTrasse[33, i] = CStr(fltQ_RLb)
      Endif
    
      'Wärmeverlust Vorlauftrasse relativ
      strDatensatzNetzTrasse[12, i] = CStr(fltQ_VL / CFloat(strDatensatzNetzTrasse[2, i]))
      If Global.booMehrleiter = True Then
        strDatensatzNetzTrasse[23, i] = CStr(fltQ_VLa / CFloat(strDatensatzNetzTrasse[2, i]))
        strDatensatzNetzTrasse[34, i] = CStr(fltQ_VLb / CFloat(strDatensatzNetzTrasse[2, i]))
      Endif
    
      'Wärmeverlust Rücklauftrasse relativ
      strDatensatzNetzTrasse[13, i] = CStr(fltQ_RL / CFloat(strDatensatzNetzTrasse[2, i]))
      If Global.booMehrleiter = True Then
        strDatensatzNetzTrasse[24, i] = CStr(fltQ_RLa / CFloat(strDatensatzNetzTrasse[2, i]))
        strDatensatzNetzTrasse[35, i] = CStr(fltQ_RLb / CFloat(strDatensatzNetzTrasse[2, i]))
      Endif
    
      'Druckverlust
      'function funDruckverlust(RHO AS Float, k AS Float, alpha AS Float, ms AS Float, l AS Float, di AS Float)
      strDatensatzNetzTrasse[5, i] = CStr(2 * funDruckverlust(1000, Global.k, Global.fltZuschlagFormstuecke, CFloat(strDatensatzNetzTrasse[4, i]), CFloat(strDatensatzNetzTrasse[2, i]), CFloat(strDatensatzNetzTrasse[3, i])))
      If Global.booMehrleiter = True Then
        strDatensatzNetzTrasse[16, i] = CStr(2 * funDruckverlust(1000, Global.k, Global.fltZuschlagFormstuecke, CFloat(strDatensatzNetzTrasse[15, i]), CFloat(strDatensatzNetzTrasse[2, i]), CFloat(strDatensatzNetzTrasse[14, i])))
        strDatensatzNetzTrasse[27, i] = CStr(2 * funDruckverlust(1000, Global.k, Global.fltZuschlagFormstuecke, CFloat(strDatensatzNetzTrasse[26, i]), CFloat(strDatensatzNetzTrasse[2, i]), CFloat(strDatensatzNetzTrasse[25, i])))
      Endif
    
    Else  'kein Massenstrom auf der Trasse
    
      'Mitteltemperatur Vorlauftrasse
      strDatensatzNetzTrasse[8, i] = CStr(Global.fltUmgebungstemperatur)
      strDatensatzNetzTrasse[19, i] = CStr(Global.fltUmgebungstemperatur)
      strDatensatzNetzTrasse[30, i] = CStr(Global.fltUmgebungstemperatur)
      'Mitteltemperatur Rücklauftrasse  
      strDatensatzNetzTrasse[9, i] = CStr(Global.fltUmgebungstemperatur)
      strDatensatzNetzTrasse[20, i] = CStr(Global.fltUmgebungstemperatur)
      strDatensatzNetzTrasse[31, i] = CStr(Global.fltUmgebungstemperatur)
      'Wärmeverlust Vorlauftrasse absolut
      strDatensatzNetzTrasse[10, i] = "0"
      strDatensatzNetzTrasse[21, i] = "0"
      strDatensatzNetzTrasse[32, i] = "0"
      'Wärmeverlust Rücklauftrasse absolut
      strDatensatzNetzTrasse[11, i] = "0"
      strDatensatzNetzTrasse[22, i] = "0"
      strDatensatzNetzTrasse[33, i] = "0"
      'Wärmeverlust Vorlauftrasse relativ
      strDatensatzNetzTrasse[12, i] = "0"
      strDatensatzNetzTrasse[23, i] = "0"
      strDatensatzNetzTrasse[34, i] = "0"
      'Wärmeverlust Rücklauftrasse relativ
      strDatensatzNetzTrasse[13, i] = "0"
      strDatensatzNetzTrasse[24, i] = "0"
      strDatensatzNetzTrasse[35, i] = "0"
      'Druckverlust
      strDatensatzNetzTrasse[5, i] = "0"
      strDatensatzNetzTrasse[16, i] = "0"
      strDatensatzNetzTrasse[27, i] = "0"
      
    Endif
  Next
'-----------------Druckverlust, Mitteltemperaturen und Wärmeverluste auf der Trasse ENDE-----------------------


'----------------Kostenberechnung------------------------------------------------------------------------------
  For j = 0 To Global.conMaxRohre - 1
    Global.fltRohrLaengeKosten[1, j] = 0
    Global.fltRohrLaengeKosten[2, j] = 0
    
    Global.fltRohrLaengeKosten_a[1, j] = 0
    Global.fltRohrLaengeKosten_a[2, j] = 0
    
    Global.fltRohrLaengeKosten_b[1, j] = 0
    Global.fltRohrLaengeKosten_b[2, j] = 0
  Next
  
  For i = 0 To intZeilenNetzTrasse - 1
    For j = 0 To Global.conMaxRohre - 1
      If CFloat(strDatensatzNetzTrasse[3, i]) = CFloat(strDatensatzRohre[1, j]) Then
        strDatensatzNetzTrasse[6, i] = CStr(CFloat(strDatensatzNetzTrasse[2, i]) * CFloat(strDatensatzRohre[7 + Global.intDaemmklasse, j]))
        
        'wenn Massenstrom auf Trasse <> "0" dann
        If strDatensatzNetzTrasse[4, i] <> "0" Then
          'Durchmesser innen
          Global.fltRohrLaengeKosten[0, j] = CFloat(strDatensatzNetzTrasse[3, i])
          'Länge
          Global.fltRohrLaengeKosten[1, j] += CFloat(strDatensatzNetzTrasse[2, i])
          'Kosten
          Global.fltRohrLaengeKosten[2, j] += CFloat(strDatensatzNetzTrasse[6, i])
        Endif
        
      Endif
    Next
    
    For j = 0 To Global.conMaxRohre - 1
      If CFloat(strDatensatzNetzTrasse[14, i]) = CFloat(strDatensatzRohre[1, j]) Then
        strDatensatzNetzTrasse[17, i] = CStr(CFloat(strDatensatzNetzTrasse[2, i]) * CFloat(strDatensatzRohre[7 + Global.intDaemmklasse, j]))
        
        'wenn Massenstrom auf Trasse <> "0" dann
        If strDatensatzNetzTrasse[4, i] <> "0" Then
          'Durchmesser innen
          Global.fltRohrLaengeKosten_a[0, j] = CFloat(strDatensatzNetzTrasse[14, i])
          'Länge
          Global.fltRohrLaengeKosten_a[1, j] += CFloat(strDatensatzNetzTrasse[2, i])
          'Kosten
          Global.fltRohrLaengeKosten_a[2, j] += CFloat(strDatensatzNetzTrasse[17, i])
        Endif
        
      Endif
    Next
    
    For j = 0 To Global.conMaxRohre - 1
      If CFloat(strDatensatzNetzTrasse[25, i]) = CFloat(strDatensatzRohre[1, j]) Then
        strDatensatzNetzTrasse[28, i] = CStr(CFloat(strDatensatzNetzTrasse[2, i]) * (CFloat(strDatensatzRohre[7 + Global.intDaemmklasse, j]) - CFloat(strDatensatzRohre[11, j])))
        
        'wenn Massenstrom auf Trasse <> "0" dann
        If strDatensatzNetzTrasse[4, i] <> "0" Then
          'Durchmesser innen
          Global.fltRohrLaengeKosten_b[0, j] = CFloat(strDatensatzNetzTrasse[25, i])
         'Länge
          Global.fltRohrLaengeKosten_b[1, j] += CFloat(strDatensatzNetzTrasse[2, i])
          'Kosten
          Global.fltRohrLaengeKosten_b[2, j] += CFloat(strDatensatzNetzTrasse[28, i])
         Endif
      
      Endif
    Next
  Next
'----------------Kostenberechnung ENDE------------------------------------------------------------------------------
  
   
'-------Schreibe Dateien zurück----------------  
  'Schreibe NetzTrasse.MIF
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MIF" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  strZeile = "Version 300"
  Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  strZeile = "Charset " & Chr$(34) & "WindowsLatin1" & Chr$(34)
  Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  strZeile = "Columns " & CStr(Global.conSpaltenTrasse)
  Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  
  For i = 3 To intZeilenNetzTrasseMIF - 1 'intZeilenNetzTrasseMIF
    strZeile = strDatensatzNetzTrasseMIF[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  
  'Schreibe NetzTrasse.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenNetzTrasse - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenTrasse - 2
      strZeile &= strDatensatzNetzTrasse[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzNetzTrasse[Global.conSpaltenTrasse - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  
  'Schreibe Punkte.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenPunkte - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenPunkte - 2
      strZeile &= strDatensatzPunkte[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzPunkte[Global.conSpaltenPunkte - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  Programmcode.loesche_DateiLeerzeilen(Global.strtxbPfad & Global.conDateiNamePunkte & ".MID")
'-------Schreibe Dateien zurück ENDE----------------
End


Public Sub lese_Klima_TagKW()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim a, b As Integer
  
  'KlimaTag
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameKlimaTagKW & ".csv" For Input 'öffnen der Datei rfKlimaTag.csv
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      Global.strDatensatzKlimaTagKW[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Close #hsDatei  'schließe Datei Punkte.MID
End




Public Sub lese_Klima_Tag()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim a, b As Integer
  
  'KlimaTag
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameKlimaTag & ".csv" For Input 'öffnen der Datei rfKlimaTag.csv
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      Global.strDatensatzKlimaTag[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Close #hsDatei  'schließe Datei Punkte.MID
  
  Global.strTagStart[0] = "1"
  Global.strTagStart[1] = "1"
  If CInt(Global.strDatensatzKlimaTag[4, 1]) < 10 Then
    Global.strTagStart[2] = Global.strDatensatzKlimaTag[3, 1] & "0" & Global.strDatensatzKlimaTag[4, 1]
  Else
    Global.strTagStart[2] = Global.strDatensatzKlimaTag[3, 1] & Global.strDatensatzKlimaTag[4, 1]
  Endif
  
  
  Global.strTagEnde[0] = "31"
  Global.strTagEnde[1] = "12"
  If CInt(Global.strDatensatzKlimaTag[4, 1]) < 10 Then
    Global.strTagEnde[2] = Global.strDatensatzKlimaTag[3, 1] & "0" & Global.strDatensatzKlimaTag[4, 1]
  Else
    Global.strTagEnde[2] = Global.strDatensatzKlimaTag[3, 1] & Global.strDatensatzKlimaTag[4, 1]
  Endif
End



Public Sub reset_NetzTrasseSimulationsergebnisErgebnis(Zeilen As Integer)
Dim i, j As Integer
  For i = 0 To Zeilen - 1
    For j = 0 To Global.conSpaltenTrasseSimulationsErgebnis - 1
      Global.strDatensatzNetzTrasseSimulationsErgebnis[j, i] = "0"
    Next
  Next
End



Public Sub lese_Daten_fuer_Simulation()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim a, b As Integer

'--------------------Dateien einlesen---------------------------------------------------     
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameBibRohre & ".csv" For Input 'öffnen der Datei Rohre.csv
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      Global.strDatensatzRohre[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Close #hsDatei  'schließe Datei Rohre.csv
  
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MID" For Input 'öffnen der Datei NetzTrasse.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      Global.strDatensatzNetzTrasse[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    Global.intNetzTrasseSpaltenzahl = a
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Global.intZeilenNetzTrasse = b
  Close #hsDatei  'schließe Datei NetzTrasse.MID
  
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MIF" For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    Global.strDatensatzNetzTrasseMIF[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Global.intZeilenNetzTrasseMIF = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF

  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Input 'öffnen der Datei Punkte.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      Global.strDatensatzPunkte[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Global.intZeilenPunkte = b
  Close #hsDatei  'schließe Datei Punkte.MID
  
  
 
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePfadeStrecken & ".csv" For Input 'öffnen der Datei rfPfadeStrecken.csv
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      Global.strDatensatzTrassenWegStrecken[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    Global.intSpaltenTrassenWeg = a
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Close #hsDatei  'schließe Datei rfPfadeStrecken.csv


  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePfadePunkte & ".csv" For Input 'öffnen der Datei rfPfadePunkte.csv
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      Global.strDatensatzTrassenWegPunkte[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    Global.intSpaltenTrassenWeg = a
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Close #hsDatei  'schließe Datei rfPfadePunkte.csv
 
'--------------------Dateien einlesen ENDE---------------------------------------------------   
End



Public Sub schreibe_Daten_von_Simulation(strDatei As String, intStart As Integer, intEnde As Integer)
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim i, j As Integer
 
  'Schreibe Ergebnis.csv
  hsDatei = Open Global.strtxbPfad & strDatei & ".csv" For Output Create     'Öffne die Datei zum Schreiben Global.conDateiNameErgebnis
  hsDatei.EndOfLine = gb.Windows
  
  For i = intStart To intEnde  'Schleife über alle Stunden
    strZeile = ""
    
    For j = 0 To 49 - 1
      strZeile &= Global.strDatensatzSimErgebnis[j, i] & Chr$(9)
    Next
    
    strZeile &= Global.strDatensatzSimErgebnis[49, i]
    
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  Programmcode.Erzeuge_NetzTrasseSimulationsErgebnis(strDatei)
End



Public Sub berechne_dP_MS_PWaermeOUT_PWaermeVerlust_fuer_Simulation()
Dim dp, dpmax, Qabs, Qgeliefert As Float
Dim dp2a, dpmax2a, Qabs2a, Qgeliefert2a As Float
Dim dp2b, dpmax2b, Qabs2b, Qgeliefert2b As Float
Dim i, j As Integer
  dpmax = 0
  dpmax2a = 0
  dpmax2b = 0
  Qabs = 0
  Qabs2a = 0
  Qabs2a = 0
  Qgeliefert = 0
  Qgeliefert2a = 0
  Qgeliefert2b = 0
  
  For i = 0 To Global.intSpaltenTrassenWeg - 1
    dp = 0
    dp2a = 0
    dp2b = 0
    
    Qgeliefert += CFloat(Global.strDatensatzPunkte[18, CInt(Global.strDatensatzTrassenWegPunkte[i, 1]) - 1])
    Qgeliefert2a += CFloat(Global.strDatensatzPunkte[25, CInt(Global.strDatensatzTrassenWegPunkte[i, 1]) - 1])
    Qgeliefert2b += CFloat(Global.strDatensatzPunkte[35, CInt(Global.strDatensatzTrassenWegPunkte[i, 1]) - 1])
   
    For j = 1 To Global.strDatensatzTrassenWegStrecken[i, 0]
      dp += Global.strDatensatzNetzTrasse[5, CInt(Global.strDatensatzTrassenWegStrecken[i, j]) - 1]
      dp2a += Global.strDatensatzNetzTrasse[16, CInt(Global.strDatensatzTrassenWegStrecken[i, j]) - 1]
      dp2b += Global.strDatensatzNetzTrasse[27, CInt(Global.strDatensatzTrassenWegStrecken[i, j]) - 1]
    Next
    
    If dpmax < dp Then dpmax = dp
    If dpmax2a < dp2a Then dpmax2a = dp2a
    If dpmax2b < dp2b Then dpmax2b = dp2b
  Next
  
  dpmax += Global.fltWaermetauscherdP
  dpmax2a += Global.fltWaermetauscherdP
  dpmax2b += Global.fltWaermetauscherdP
  
  For i = 0 To Global.intZeilenNetzTrasse - 1
    Qabs += Global.strDatensatzNetzTrasse[10, i] + Global.strDatensatzNetzTrasse[11, i]
    Qabs2a += Global.strDatensatzNetzTrasse[21, i] + Global.strDatensatzNetzTrasse[22, i]
    Qabs2b += Global.strDatensatzNetzTrasse[32, i] + Global.strDatensatzNetzTrasse[33, i]
  Next
  
  global.fltDP = dpmax
  global.fltDP2a = dpmax2a
  global.fltDP2b = dpmax2b
  global.fltPWaermeOUT = Qgeliefert
  global.fltPWaermeOUT2a = Qgeliefert2a
  global.fltPWaermeOUT2b = Qgeliefert2b
  global.fltPWaermeVERLUST = Qabs / 1000
  global.fltPWaermeVERLUST2a = Qabs2a / 1000
  global.fltPWaermeVERLUST2b = Qabs2b / 1000
End





Public Sub simuliere(intStunde As Integer)
Dim a, i, j, z As Integer
Dim Temperatur1, Temperatur2, Temperatur3 As Float
Dim Temperatur1a, Temperatur2a, Temperatur3a As Float
Dim Temperatur1b, Temperatur2b, Temperatur3b As Float
Dim Massenstrom1, Massenstrom2, Massenstrom3 As Float
Dim Massenstrom1a, Massenstrom2a, Massenstrom3a As Float
Dim Massenstrom1b, Massenstrom2b, Massenstrom3b As Float
Dim fltQ As Float
Dim fltQ_VL, fltQ_RL As Float
Dim fltQ_VLa, fltQ_RLa As Float
Dim fltQ_VLb, fltQ_RLb As Float
Dim fltFaktorVL, fltFaktorRL As Float
Dim fltFaktorVL2a, fltFaktorRL2a As Float
Dim fltFaktorVL2b, fltFaktorRL2b As Float
Dim fltAuslegeleistung, fltAnteilP As Float
Dim booZ As Boolean
 
  
 

  Global.fltQIstQMax = 100
  'Global.fltdeltaTHaus = 30



  '------------aktuelle Leistung an den Abnehmern-----------------------------------------------------
  'Setze die PAktuell, Lege die Massenströme an den Abnehmern fest
  For i = 0 To Global.intZeilenPunkte - 1
    'wenn QJahr > 0 dann (Abnehmer)
    If CFloat(Global.strDatensatzPunkte[20, i]) > 0 Then
      'wenn Abnehmer wird mitgerechnet (Spalte 39) dann belege Abnehmer mit Massenstrom
      If Global.strDatensatzPunkte[39, i] = "1" Then
        Global.strDatensatzPunkte[18, i] = CStr(funQStd(CFloat(Global.strDatensatzPunkte[21, i]), Global.strDatensatzPunkte[16, i], intStunde))
      Else
        Global.strDatensatzPunkte[18, i] = "0"
      Endif
            
      'Vierleiterfall
      If Global.booMehrleiter = True Then
        'wenn Abnehmer wird mitgerechnet (Spalte 39) dann belege Abnehmer mit Massenstrom
        If Global.strDatensatzPunkte[39, i] = "1" Then
          fltAuslegeleistung = funQStd_Dimensionierung(CFloat(Global.strDatensatzPunkte[21, i]), Global.strDatensatzPunkte[16, i], CFloat(Global.fltAuslegungstemperatur))
          'Bruch ist Anteil Teilastleistung an Auslegungsleistung
          fltAnteilP = CFloat(Global.strDatensatzPunkte[18, i]) / fltAuslegeleistung
          
          'wenn Mehrleiternetz in Spitzen und Grundlast geteilt dann Pakt:
          If Global.booGLSPL = True Then
            If CFloat(global.strDatensatzKlimaTag[0, Int(intStunde / 24) + 1]) >= Global.conHeizGrenzTemperaturTWW Then
              Global.strDatensatzPunkte[25, i] = "0"
              Global.strDatensatzPunkte[35, i] = CStr(funQStd(CFloat(Global.strDatensatzPunkte[21, i]), Global.strDatensatzPunkte[16, i], intStunde))
            Else
              Global.strDatensatzPunkte[35, i] = CStr(funQStd_Heizgrenze(CFloat(Global.strDatensatzPunkte[21, i]), Global.strDatensatzPunkte[16, i], intStunde))
              Global.strDatensatzPunkte[25, i] = CStr((funQStd(CFloat(Global.strDatensatzPunkte[21, i]), Global.strDatensatzPunkte[16, i], intStunde)) - CFloat(Global.strDatensatzPunkte[35, i]))
            Endif
          Else
    
            'Wenn der Leistungsanteil im Teillastfall kleiner ist als der Anteil für den kleineren Leiter ist wird Betriebsart 1: alles im kleinen Rohr gewählt
            If fltAnteilP * 100 <= Global.fltMLAnteilLeiter2 Then
              global.intMLNetzBetrieb = 1
            Endif
            'Wenn der Leistungsanteil im Teillastfall größer ist als der Anteil für den kleineren Leiter ist und kleiner als der Anteil für den größeren Leiter wird Betriebsart 2: alles im größeren Rohr gewählt
            If fltAnteilP * 100 > Global.fltMLAnteilLeiter2 And fltAnteilP * 100 <= (100 - Global.fltMLAnteilLeiter2) Then
              global.intMLNetzBetrieb = 2
            Endif
            'Wenn der Leistungsanteil im Teillastfall größer ist als der Anteil für den größeren Leiter ist wird Betriebsart 3: alles in beiden Rohren gewählt
            If fltAnteilP * 100 >= (100 - Global.fltMLAnteilLeiter2) Then
              global.intMLNetzBetrieb = 3
            Endif
        
            Select Case global.intMLNetzBetrieb
            Case 1
              Global.strDatensatzPunkte[25, i] = "0"
              Global.strDatensatzPunkte[35, i] = Global.strDatensatzPunkte[18, i]
            Case 2
              Global.strDatensatzPunkte[25, i] = Global.strDatensatzPunkte[18, i]
              Global.strDatensatzPunkte[35, i] = "0"
            Case 3
              'erst das größere Rohr voll belegen
              Global.strDatensatzPunkte[25, i] = CStr(fltAuslegeleistung * ((100 - Global.fltMLAnteilLeiter2) / 100))
              'dann den Rest auf das kleiner Rohr geben
              Global.strDatensatzPunkte[35, i] = CStr(CFloat(Global.strDatensatzPunkte[18, i]) - CFloat(Global.strDatensatzPunkte[25, i]))
            End Select
          Endif
        'wenn Abnehmer berücksichtigen (Spalte 39) = "0" dann Pakta/b = "0"
        Else
           Global.strDatensatzPunkte[25, i] = "0"
           Global.strDatensatzPunkte[35, i] = "0"
        Endif
      'wenn booMehrleiter = false
      Else
        Global.strDatensatzPunkte[25, i] = "0"
        Global.strDatensatzPunkte[35, i] = "0"
      Endif
    Endif
    'Testbit Punkt behandelt wird für alle auf "0" gesetzt
    Global.strDatensatzPunkte[17, i] = "0"
  Next
'------------aktuelle Leistung an den Abnehmern ENDE----------------------------------------------------- 

  

 

  
'-------------------Massenströme berechnen---------------------------------------------------

For z = 0 To Global.intSchritte
  Global.fltVerlauf = z / Global.intSchritte
  
  'Ausstiegsvariable
  booZ = True

  'Vorbelegung der mit Startwerten 
  For i = 0 To Global.intZeilenPunkte - 1

    fltFaktorRL = 1
    fltFaktorVL = 1
    fltFaktorRL2a = 1
    fltFaktorVL2a = 1
    fltFaktorRL2b = 1
    fltFaktorVL2b = 1
    
    If z = 0 Then
    
      'Setze die Massenströme auf 0
      Global.strDatensatzPunkte[5, i] = "0"      'Massenstrom
      Global.strDatensatzPunkte[19, i] = "0"     'MSakt
      Global.strDatensatzPunkte[24, i] = "0"     'Massenstrom2a
      Global.strDatensatzPunkte[34, i] = "0"     'Massenstrom2b
    
      'Belege die AbnehmerPunkte mit Massenströmen
      'Wenn noch nicht behandelt und kein nachfolger Punkt vorhanden
      If Global.strDatensatzPunkte[17, i] = "0" And Global.strDatensatzPunkte[8, i] = "0" Then
        Global.strDatensatzPunkte[5, i] = CStr(CFloat(Global.strDatensatzPunkte[18, i]) / (Global.cp * Global.fltdeltaTHaus))
        Global.strDatensatzPunkte[19, i] = Global.strDatensatzPunkte[5, i]
    
        If Global.booMehrleiter = True Then
          Global.strDatensatzPunkte[24, i] = CStr(CFloat(Global.strDatensatzPunkte[25, i]) / (Global.cp * Global.fltdeltaTHaus))
          Global.strDatensatzPunkte[26, i] = Global.strDatensatzPunkte[24, i]
          If Global.booGLSPL = True Then
            Global.strDatensatzPunkte[34, i] = CStr(CFloat(Global.strDatensatzPunkte[35, i]) / (Global.cp * Global.fltTWWdT))
          Else
            Global.strDatensatzPunkte[34, i] = CStr(CFloat(Global.strDatensatzPunkte[35, i]) / (Global.cp * Global.fltdeltaTHaus))
          Endif
          Global.strDatensatzPunkte[36, i] = Global.strDatensatzPunkte[34, i]
        Else
          Global.strDatensatzPunkte[24, i] = "0"
          Global.strDatensatzPunkte[26, i] = "0"
          Global.strDatensatzPunkte[34, i] = "0"
          Global.strDatensatzPunkte[36, i] = "0"
        Endif
     
        'Punkt behandelt
        Global.strDatensatzPunkte[17, i] = "1"
      Endif
          
    Else
    
      'Setze die Massenströme auf 0
      Global.strDatensatzPunkte[5, i] = "0"      'Massenstrom
      Global.strDatensatzPunkte[24, i] = "0"     'Massenstrom2a
      Global.strDatensatzPunkte[34, i] = "0"     'Massenstrom2b
      Global.strDatensatzPunkte[17, i] = "0"     'Testbit
      
     
      'Belege die AbnehmerPunkte mit Massenströmen
      If Global.strDatensatzPunkte[20, i] <> "0" Then
        'Wenn aktiver Abnehmer
        If Global.strDatensatzPunkte[39, i] = "1" Then
                
          'Wenn Vorlauftemp < als Min dann 
          ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[3, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
          If CFloat(Global.strDatensatzPunkte[3, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
            ' [GB2:CFLT] fltFaktorVL = (Global.fltGrenzVorlauftemperatur / CFlt(Global.strDatensatzPunkte[3, i])) '* (1 + Global.conSchritte / z)
            fltFaktorVL = (Global.fltGrenzVorlauftemperatur / CFloat(Global.strDatensatzPunkte[3, i])) '* (1 + Global.conSchritte / z)
            If fltFaktorVL > 100 Then fltFaktorVL = 100
          Else
            fltFaktorVL = 1
          Endif
          
          'wenn Rücklauftemperatur < als Min dann
          ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[4, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(Global.strDatensatzPunkte[4, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz Then
          If CFloat(Global.strDatensatzPunkte[4, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
            ' [GB2:CFLT] fltFaktorRL = (Global.fltGrenzRuecklauftemperatur / CFlt(Global.strDatensatzPunkte[4, i])) '* (1 + 0.1 * Global.conSchritte / z)   '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
            fltFaktorRL = (Global.fltGrenzRuecklauftemperatur / CFloat(Global.strDatensatzPunkte[4, i])) '* (1 + 0.1 * Global.conSchritte / z)   '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
            If fltFaktorRL > 100 Then fltFaktorRL = 100
          Else
            fltFaktorRL = 1
            'IF fltFaktorRL < 0.001 THEN fltFaktorRL = 0.001
          Endif
          
          'Übertrage aktuellen Massenstrom
          If fltFaktorVL > 1 Then
            Global.strDatensatzPunkte[19, i] = CStr(CFloat(Global.strDatensatzPunkte[19, i]) * fltFaktorVL)
          Else
            Global.strDatensatzPunkte[19, i] = CStr(CFloat(Global.strDatensatzPunkte[19, i]) * fltFaktorRL)
          Endif
          Global.strDatensatzPunkte[5, i] = Global.strDatensatzPunkte[19, i]
                 
        
          'Fall Mehrleiter
          If Global.booMehrleiter = True Then
            If Global.booGLSPL = True Then
              
              'Leiter1
              ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[22, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
              If CFloat(Global.strDatensatzPunkte[22, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                ' [GB2:CFLT] fltFaktorVL2a = (Global.fltGrenzVorlauftemperatur / CFlt(Global.strDatensatzPunkte[22, i])) ' *(1 + Global.conSchritte / z)
                fltFaktorVL2a = (Global.fltGrenzVorlauftemperatur / CFloat(Global.strDatensatzPunkte[22, i])) ' *(1 + Global.conSchritte / z)
                If fltFaktorVL2a > 10 Then fltFaktorVL2a = 10
              Else
                fltFaktorVL2a = 1
              Endif
              
              'wenn Rücklauftemperatur < als Min oder grßer als max dann
              ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[23, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(Global.strDatensatzPunkte[23, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz Then
              If CFloat(Global.strDatensatzPunkte[23, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                ' [GB2:CFLT] fltFaktorRL2a = (Global.fltGrenzRuecklauftemperatur / CFlt(Global.strDatensatzPunkte[23, i]))
                fltFaktorRL2a = (Global.fltGrenzRuecklauftemperatur / CFloat(Global.strDatensatzPunkte[23, i]))
                If fltFaktorRL2a > 10 Then fltFaktorRL2a = 10
              Else
                fltFaktorRL2a = 1
              Endif
              
              'Übertrage aktuellen Massenstrom
              If fltFaktorVL2a > 1 Then
                Global.strDatensatzPunkte[26, i] = CStr(CFloat(Global.strDatensatzPunkte[26, i]) * fltFaktorVL2a)
              Else
                Global.strDatensatzPunkte[26, i] = CStr(CFloat(Global.strDatensatzPunkte[26, i]) * fltFaktorRL2a)
              Endif
              Global.strDatensatzPunkte[24, i] = Global.strDatensatzPunkte[26, i]
              
              
              'Leiter2
              ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[32, i]) < Global.fltTWWVL - Global.fltGrenzRuecklauftemperaturToleranz Then
              If CFloat(Global.strDatensatzPunkte[32, i]) < Global.fltTWWVL - Global.fltGrenzRuecklauftemperaturToleranz Then
                ' [GB2:CFLT] fltFaktorVL2b = (Global.fltTWWVL / CFlt(Global.strDatensatzPunkte[32, i])) '* (1 + Global.conSchritte / z)
                fltFaktorVL2b = (Global.fltTWWVL / CFloat(Global.strDatensatzPunkte[32, i])) '* (1 + Global.conSchritte / z)
                If fltFaktorVL2b > 10 Then fltFaktorVL2b = 10
              Else
                fltFaktorVL2b = 1
              Endif
              
              'wenn Rücklauftemperatur < als Min dann
              ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[33, i]) < Global.fltTWWRL - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(Global.strDatensatzPunkte[33, i]) > Global.fltTWWRL + Global.fltGrenzRuecklauftemperaturToleranz Then
              If CFloat(Global.strDatensatzPunkte[33, i]) < Global.fltTWWRL - Global.fltGrenzRuecklauftemperaturToleranz Then
                ' [GB2:CFLT] fltFaktorRL2b = (Global.fltTWWRL / CFlt(Global.strDatensatzPunkte[33, i]))
                fltFaktorRL2b = (Global.fltTWWRL / CFloat(Global.strDatensatzPunkte[33, i]))
                If fltFaktorRL2b > 10 Then fltFaktorRL2b = 10
              Else
                fltFaktorRL2b = 1
              Endif
              
              'Übertrage aktuellen Massenstrom
              If fltFaktorVL2b > 1 Then
                Global.strDatensatzPunkte[36, i] = CStr(CFloat(Global.strDatensatzPunkte[36, i]) * fltFaktorVL2b)
              Else
                Global.strDatensatzPunkte[36, i] = CStr(CFloat(Global.strDatensatzPunkte[36, i]) * fltFaktorRL2b)
              Endif
              Global.strDatensatzPunkte[34, i] = Global.strDatensatzPunkte[36, i]
            
            'wenn NICHT Grundlast - Spitzenlastfall  
            Else
            
              'Leiter1
              If global.intMLNetzBetrieb = 2 Or global.intMLNetzBetrieb = 3 Then
                'Wenn Vorlauftemp < als Min dann 
                ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[22, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                If CFloat(Global.strDatensatzPunkte[22, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                  ' [GB2:CFLT] fltFaktorVL2a = (Global.fltGrenzVorlauftemperatur / CFlt(Global.strDatensatzPunkte[22, i])) '* (1 + Global.conSchritte / z)
                  fltFaktorVL2a = (Global.fltGrenzVorlauftemperatur / CFloat(Global.strDatensatzPunkte[22, i])) '* (1 + Global.conSchritte / z)
                  If fltFaktorVL2a > 10 Then fltFaktorVL2a = 10
                Else
                  fltFaktorVL2a = 1
                Endif
        
                'wenn Rücklauftemperatur < als Min dann
                ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[23, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(Global.strDatensatzPunkte[23, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz Then
                If CFloat(Global.strDatensatzPunkte[23, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                  ' [GB2:CFLT] fltFaktorRL2a = (Global.fltGrenzRuecklauftemperatur / CFlt(Global.strDatensatzPunkte[23, i]))  '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
                  fltFaktorRL2a = (Global.fltGrenzRuecklauftemperatur / CFloat(Global.strDatensatzPunkte[23, i]))  '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
                  If fltFaktorRL2a > 10 Then fltFaktorRL2a = 10
                  'IF fltFaktorRL < 0.001 THEN fltFaktorRL = 0.001
                Else
                  fltFaktorRL2a = 1
                Endif
          
                'Übertrage aktuellen Massenstrom
                If fltFaktorVL2a > 1 Then
                  Global.strDatensatzPunkte[26, i] = CStr(CFloat(Global.strDatensatzPunkte[26, i]) * fltFaktorVL2a)
                Else
                  Global.strDatensatzPunkte[26, i] = CStr(CFloat(Global.strDatensatzPunkte[26, i]) * fltFaktorRL2a)
                Endif
                Global.strDatensatzPunkte[24, i] = Global.strDatensatzPunkte[26, i]
              Endif
            
              'Leiter2
             If global.intMLNetzBetrieb = 1 Or global.intMLNetzBetrieb = 3 Then
                'Wenn Vorlauftemp < als Min dann 
                ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[32, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                If CFloat(Global.strDatensatzPunkte[32, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                  ' [GB2:CFLT] fltFaktorVL2b = (Global.fltGrenzVorlauftemperatur / CFlt(Global.strDatensatzPunkte[32, i])) '* (1 + Global.conSchritte / z)
                  fltFaktorVL2b = (Global.fltGrenzVorlauftemperatur / CFloat(Global.strDatensatzPunkte[32, i])) '* (1 + Global.conSchritte / z)
                  If fltFaktorVL2b > 10 Then fltFaktorVL2b = 10
                Else
                  fltFaktorVL2b = 1
                Endif
          
                'wenn Rücklauftemperatur < als Min dann
                ' [GB2:CFLT] If CFlt(Global.strDatensatzPunkte[33, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Or CFlt(Global.strDatensatzPunkte[33, i]) > Global.fltGrenzRuecklauftemperatur + Global.fltGrenzRuecklauftemperaturToleranz Then
                If CFloat(Global.strDatensatzPunkte[33, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
                  ' [GB2:CFLT] fltFaktorRL2b = (Global.fltGrenzRuecklauftemperatur / CFlt(Global.strDatensatzPunkte[33, i]))  '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
                  fltFaktorRL2b = (Global.fltGrenzRuecklauftemperatur / CFloat(Global.strDatensatzPunkte[33, i]))  '0.9 * (CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - Global.fltGrenzRuecklauftemperatur)) / ((CFloat(strDatensatzPunkte[18, i]) / (Global.cp * (CFlt(strDatensatzPunkte[3, i]) - CFlt(strDatensatzPunkte[4, i]))))))
                  If fltFaktorRL2b > 10 Then fltFaktorRL2b = 10
                  'IF fltFaktorRL < 0.001 THEN fltFaktorRL = 0.001
                Else
                  fltFaktorRL2b = 1
                Endif
            
                'Übertrage aktuellen Massenstrom
                If fltFaktorVL2b > 1 Then
                  Global.strDatensatzPunkte[36, i] = CStr(CFloat(Global.strDatensatzPunkte[36, i]) * fltFaktorVL2b)
                Else
                  Global.strDatensatzPunkte[36, i] = CStr(CFloat(Global.strDatensatzPunkte[36, i]) * fltFaktorRL2b)
                Endif
                Global.strDatensatzPunkte[34, i] = Global.strDatensatzPunkte[36, i]
              Endif
            Endif
          Endif
                  
        Endif  'IF strDatensatzPunkte[39, i] = "1" THEN
        'Testbit für den Abnehmer auf 1 setzen
        Global.strDatensatzPunkte[17, i] = "1"
      Endif
    
    Endif
  Next
     
  
  
  For j = 0 To Global.intZeilenPunkte - 1
    a = 0
    For i = 0 To Global.intZeilenPunkte - 1
      'Wenn die Anzahl der Nachknoten > 0
      If CInt(Global.strDatensatzPunkte[8, i]) > 0
        
        'Wenn es einen Nachknoten gibt
        If CInt(Global.strDatensatzPunkte[8, i]) = 1 Then
          
          'Wenn Qakt = 0 (der aktuelle Punkt kein Abnehmer ist) UND der nachfolgende Punkte bereits behandelt wurde dann
          If Global.strDatensatzPunkte[18, i] = "0" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i] - 1)] <> "0" Then
            'übertrage den Massenstrom des Folgepunktes auf den aktuellen
            Global.strDatensatzPunkte[5, i] = CStr(CFloat(Global.strDatensatzPunkte[5, CInt(Global.strDatensatzPunkte[9, i] - 1)]))
          
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[24, i] = CStr(CFloat(Global.strDatensatzPunkte[24, CInt(Global.strDatensatzPunkte[9, i] - 1)]))
              Global.strDatensatzPunkte[34, i] = CStr(CFloat(Global.strDatensatzPunkte[34, CInt(Global.strDatensatzPunkte[9, i] - 1)]))
            Endif
            
            'Punkt bearbeitet => Testbit = "1"
            Global.strDatensatzPunkte[17, i] = "1"
              
          Endif
          
          'Fall Zwischenabnehmer!!!          
          If Global.strDatensatzPunkte[20, i] <> "0" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i] - 1)] <> "0" Then
            'Leistung wird in diesem Punkt gelöscht
            Global.strDatensatzPunkte[39, i] = "0"
            Global.strDatensatzPunkte[15, i] = "0"
            Global.strDatensatzPunkte[18, i] = "0"
            Global.strDatensatzPunkte[25, i] = "0"
            Global.strDatensatzPunkte[35, i] = "0"
                        
            'Behandlung wie normalen Punkt
            Global.strDatensatzPunkte[5, i] = CStr(CFloat(Global.strDatensatzPunkte[5, CInt(Global.strDatensatzPunkte[9, i] - 1)]))
            
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[24, i] = CStr(CFloat(Global.strDatensatzPunkte[24, CInt(Global.strDatensatzPunkte[9, i] - 1)]))
              Global.strDatensatzPunkte[34, i] = CStr(CFloat(Global.strDatensatzPunkte[34, CInt(Global.strDatensatzPunkte[9, i] - 1)]))
            Endif
            
            'Punkt bearbeitet => Testbit = "1"
            Global.strDatensatzPunkte[17, i] = "1"
          Endif
          
        Endif
        
        
        'Wenn es zwei Nachknoten gibt
        If CInt(Global.strDatensatzPunkte[8, i]) = 2 Then
          
          'wenn der Massenstrom des 1. Nachfolgen Punktes <> 0 UND der Massenstrom des 2. Nachfolgen Punktes <> 0 dann
          If Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i] - 1)] <> "0" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[11, i] - 1)] <> "0" Then
            'ist der Massentstrom des aktuellen Punktes die Summe der beiden nachfolgenden Massenströme (Makt= Mn1+Mn2)
            Global.strDatensatzPunkte[5, i] = CStr(CFloat(Global.strDatensatzPunkte[5, CInt(Global.strDatensatzPunkte[9, i] - 1)]) + CFloat(Global.strDatensatzPunkte[5, CInt(Global.strDatensatzPunkte[11, i] - 1)]))

            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[24, i] = CStr(CFloat(Global.strDatensatzPunkte[24, CInt(Global.strDatensatzPunkte[9, i] - 1)]) + CFloat(Global.strDatensatzPunkte[24, CInt(Global.strDatensatzPunkte[11, i] - 1)]))
              Global.strDatensatzPunkte[34, i] = CStr(CFloat(Global.strDatensatzPunkte[34, CInt(Global.strDatensatzPunkte[9, i] - 1)]) + CFloat(Global.strDatensatzPunkte[34, CInt(Global.strDatensatzPunkte[11, i] - 1)]))
            Endif
            
            'Punkt bearbeitet => Testbit = "1"
            Global.strDatensatzPunkte[17, i] = "1"
          Endif
            
        Endif
        
        
        'Wenn es drei Nachknoten gibt  
        If CInt(Global.strDatensatzPunkte[8, i]) = 3 Then
          'wenn der Massenstrom des 1. Nachfolgen Punktes <> 0 UND der Massenstrom des 2. Nachfolgen Punktes <> 0 UND der Massenstrom des 3. Nachfolgen Punktes <> 0 dann
          If Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i] - 1)] <> "0" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[11, i] - 1)] <> "0" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[13, i] - 1)] <> "0" Then
            'ist der Massentstrom des aktuellen Punktes die Summe der drei nachfolgenden Massenströme (Makt= Mn1+Mn2+Mn3)
            Global.strDatensatzPunkte[5, i] = CStr(CFloat(Global.strDatensatzPunkte[5, CInt(Global.strDatensatzPunkte[9, i] - 1)]) + CFloat(Global.strDatensatzPunkte[5, CInt(Global.strDatensatzPunkte[11, i] - 1)] + CFloat(Global.strDatensatzPunkte[5, CInt(Global.strDatensatzPunkte[13, i] - 1)])))
      
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[24, i] = CStr(CFloat(Global.strDatensatzPunkte[24, CInt(Global.strDatensatzPunkte[9, i] - 1)]) + CFloat(Global.strDatensatzPunkte[24, CInt(Global.strDatensatzPunkte[11, i] - 1)] + CFloat(Global.strDatensatzPunkte[24, CInt(Global.strDatensatzPunkte[13, i] - 1)])))
              Global.strDatensatzPunkte[34, i] = CStr(CFloat(Global.strDatensatzPunkte[34, CInt(Global.strDatensatzPunkte[9, i] - 1)]) + CFloat(Global.strDatensatzPunkte[34, CInt(Global.strDatensatzPunkte[11, i] - 1)] + CFloat(Global.strDatensatzPunkte[34, CInt(Global.strDatensatzPunkte[13, i] - 1)])))
            Endif
          
            'Punkt bearbeitet => Testbit = "1"
            Global.strDatensatzPunkte[17, i] = "1"
          Endif
           
        Endif
        
      Endif
      
      'wenn Testbit (behandelter aktueller Punkt) = "1"  dann zähle a + 1 (a ist die Anzahl der behandelten Punkte)
      If Global.strDatensatzPunkte[17, i] = "1" Then a = a + 1
    
    Next
    
    'wenn alle Punkte behandelt sind, dann 
    If a = Global.intZeilenPunkte Then
      'EXIT die Schleife um Zeit zu sparen
      Goto ENDEMASSEN
    Endif
  
  Next
  Message("Bei Massenstrombelegung maximale Anzahl an Durchläufen benötigt!")
ENDEMASSEN:

  For i = 0 To Global.intZeilenPunkte - 1
    'Warnmeldung
    'IF strDatensatzPunkte[5, i] = "0" THEN 
      'Message("Warnung: Am Punkt " & CStr(i + 1) & " ist der Massenstrom = 0")
    'ENDIF 
    
    'Übertrage Massenstrom von Punkten auf Trasse (wenn Trassennummer vorher <> "0") 
    If Global.strDatensatzPunkte[7, i] <> "0" Then
      Global.strDatensatzNetzTrasse[4, Global.strDatensatzPunkte[7, i] - 1] = Global.strDatensatzPunkte[5, i]
      
      If Global.booMehrleiter = True Then
        Global.strDatensatzNetzTrasse[15, Global.strDatensatzPunkte[7, i] - 1] = Global.strDatensatzPunkte[24, i]
        Global.strDatensatzNetzTrasse[26, Global.strDatensatzPunkte[7, i] - 1] = Global.strDatensatzPunkte[34, i]
      Else
        Global.strDatensatzNetzTrasse[15, Global.strDatensatzPunkte[7, i] - 1] = "0"
        Global.strDatensatzNetzTrasse[26, Global.strDatensatzPunkte[7, i] - 1] = "0"
      Endif
    
    Endif
  Next
'-------------------Massenströme berechnen ENDE---------------------------------------------------  

  Global.fltUmgebungstemperatur = CFloat(Programmcode.funErdreichtemp(intStunde))

  
'-------------------Berechne Temperaturen-----------------------------------------------------------     
  For i = 0 To Global.intZeilenPunkte - 1
    'Setze die Temperaturen auf 0
    Global.strDatensatzPunkte[3, i] = "0"
    Global.strDatensatzPunkte[4, i] = "0"
    
    Global.strDatensatzPunkte[22, i] = "0"
    Global.strDatensatzPunkte[23, i] = "0"
    
    Global.strDatensatzPunkte[32, i] = "0"
    Global.strDatensatzPunkte[33, i] = "0"

    'suche Einspeiser und gebe ihm die StartTemp  
    If Global.strDatensatzPunkte[6, i] = "0" And Global.strDatensatzPunkte[9, i] <> "0" Then
      Global.strDatensatzPunkte[3, i] = CStr(Global.fltVorlauftemperatur)
      Global.intEinspeisepunkt = i
      
      If Global.booMehrleiter = True Then
        If Global.booGLSPL = True Then
          Global.strDatensatzPunkte[22, i] = CStr(Global.fltVorlauftemperatur)
          Global.strDatensatzPunkte[32, i] = CStr(Global.fltTWWVLEIN)
        Else
          Global.strDatensatzPunkte[22, i] = CStr(Global.fltVorlauftemperatur)
          Global.strDatensatzPunkte[32, i] = CStr(Global.fltVorlauftemperatur)
        Endif
      Endif
      
      'Punkt bearbeitet => Testbit = "0"; WICHTIGE INFO: im Bereich der Vorlauftemperatur bedeutet "1" noch NICHT behandelt!!!!
      Global.strDatensatzPunkte[17, i] = "0"
   Endif
  Next
  
  
'---- Vorlauftemperaturen-------------------------------------------------------------------------------------  
  'a ist Zählvariable der belegten Punkte und wird 1 gesetzt (Einspeiser wurde schon behandelt)  
  a = 1
  For j = 0 To Global.intZeilenPunkte - 1
    
    For i = 0 To Global.intZeilenPunkte - 1
      'wenn der aktuelle Punkt kein Abnehmerpunkt ist    
      If Global.strDatensatzPunkte[8, i] <> "0" Then
        'wenn aktueller Punkt schon behandelt wurde (die Vorlauftemperatur im aktuellen Punkt belegt) und der 1. nachfolgende Punkt noch nicht behandelt wurde, dann
        If Global.strDatensatzPunkte[17, i] = "0" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i]) - 1] = "1" Then
        
          'für den Fall wenn die Anzahl der Nachknoten:
          Select Case Global.strDatensatzPunkte[8, i]
          Case 1
            '1: dann wird die Vorlauftemperatur des nachfolgenden Punktes berechnet 
            Global.strDatensatzPunkte[3, CInt(Global.strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
            Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[22, CInt(Global.strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
              Global.strDatensatzPunkte[32, CInt(Global.strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
            Endif
            'wenn Testbit (behandelte Punkte) = "0"  dann zähle a + 1 (a ist die Anzahl der behandelten Punkte)
             a = a + 1
                      
          Case 2
            '2: dann wird die Vorlauftemperatur der beiden nachfolgenden Punkte berechnet 
            Global.strDatensatzPunkte[3, CInt(Global.strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
            Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[22, CInt(Global.strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
              Global.strDatensatzPunkte[32, CInt(Global.strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
            Endif
                    
            Global.strDatensatzPunkte[3, CInt(Global.strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[12, i]) - 1])))
            Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[11, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[22, CInt(Global.strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[12, i]) - 1])))
              Global.strDatensatzPunkte[32, CInt(Global.strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[12, i]) - 1])))
            Endif
            'wenn Testbit (behandelte Punkte) = "0"  dann zähle a + 2 (a ist die Anzahl der behandelten Punkte)
             a = a + 2
          
          Case 3
            '3: dann wird die Vorlauftemperatur der drei nachfolgenden Punkte berechnet 
            Global.strDatensatzPunkte[3, CInt(Global.strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
            Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[22, CInt(Global.strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
              Global.strDatensatzPunkte[32, CInt(Global.strDatensatzPunkte[9, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
            Endif
          
            Global.strDatensatzPunkte[3, CInt(Global.strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[12, i]) - 1])))
            Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[11, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[22, CInt(Global.strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[12, i]) - 1])))
              Global.strDatensatzPunkte[32, CInt(Global.strDatensatzPunkte[11, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[12, i]) - 1])))
            Endif
          
            Global.strDatensatzPunkte[3, CInt(Global.strDatensatzPunkte[13, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[3, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[14, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[14, i]) - 1])))
            Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[13, i]) - 1] = "0"
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[22, CInt(Global.strDatensatzPunkte[13, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[22, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[14, i]) - 1])))
              Global.strDatensatzPunkte[32, CInt(Global.strDatensatzPunkte[13, i]) - 1] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[32, i]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[14, i]) - 1])))
            Endif
          
            'wenn Testbit (behandelte Punkte) = "0"  dann zähle a + 3 (a ist die Anzahl der behandelten Punkte)
            a = a + 3
          End Select
      
        Endif
        
      Endif
    Next

    'wenn alle Punkte mit Vorlauftemperatur <> 0 belegt sind, dann 'EXIT die Schleife um Zeit zu sparen
    If a = Global.intZeilenPunkte Then Goto ENDETVL
  Next
  Message("Bei Vorlauftemperaturbelegung maximale Anzahl an Durchläufen benötigt!")
ENDETVL:
'---- Vorlauftemperaturen ENDE ------


'----Rücklauftemperaturen----  
  For i = 0 To Global.intZeilenPunkte - 1
    'Setze die Rücklauftemperaturen auf 0
    Global.strDatensatzPunkte[4, i] = "0"
    'Mehrleiter   
    Global.strDatensatzPunkte[23, i] = "0"
    Global.strDatensatzPunkte[33, i] = "0"
    Global.strDatensatzPunkte[17, i] = "0"
  Next

  
  'Belege die AbnehmerPunkte mit Rücklauftemperaturen (nur Endpunkte!!)
  For i = 0 To Global.intZeilenPunkte - 1
    
    'wenn Punkt Testbit = "0" (unbehandelt) UND keine Anzahl Nachknoten = 0 (Abnehmer) dann
    If Global.strDatensatzPunkte[17, i] = "0" And Global.strDatensatzPunkte[8, i] = "0" Then
      'wenn Massenstrom > 0
      If CFloat(Global.strDatensatzPunkte[19, i]) > 0 Then
        'Rücklauftemperatur = Vorlauftemperatur - (P/(cp*m))
        Global.strDatensatzPunkte[4, i] = CStr(CFloat(Global.strDatensatzPunkte[3, i]) - (CFloat(Global.strDatensatzPunkte[18, i]) / (Global.cp * CFloat(Global.strDatensatzPunkte[19, i])))) 'dT aus Massenstromakt berechnet! Global.fltdeltaTHaus  Global.fltdeltaTHaus)
      Else
        Global.strDatensatzPunkte[4, i] = CStr(Global.fltUmgebungstemperatur)
      Endif
            
      If Global.booMehrleiter = True Then
      
        If CFloat(Global.strDatensatzPunkte[26, i]) > 0 Then
          Global.strDatensatzPunkte[23, i] = CStr(CFloat(Global.strDatensatzPunkte[22, i]) - (CFloat(Global.strDatensatzPunkte[25, i]) / (Global.cp * CFloat(Global.strDatensatzPunkte[26, i])))) 'dT aus Massenstromakt berechnet! Global.fltdeltaTHaus  Global.fltdeltaTHaus)
        Else
          Global.strDatensatzPunkte[23, i] = CStr(Global.fltUmgebungstemperatur)
        Endif
        
        If CFloat(Global.strDatensatzPunkte[36, i]) > 0 Then
          Global.strDatensatzPunkte[33, i] = CStr(CFloat(Global.strDatensatzPunkte[32, i]) - (CFloat(Global.strDatensatzPunkte[35, i]) / (Global.cp * CFloat(Global.strDatensatzPunkte[36, i])))) 'dT aus Massenstromakt berechnet! Global.fltdeltaTHaus  Global.fltdeltaTHaus)
        Else
          Global.strDatensatzPunkte[33, i] = CStr(Global.fltUmgebungstemperatur)
        Endif
      Endif
      'Aktueller Punkt wurde behandelt (Testbit = "1")
      Global.strDatensatzPunkte[17, i] = "1"
      
      'Abweichung von der Solltemperatur im Sollbereich ?
      If (Global.strDatensatzPunkte[39, i] = "1" And CFloat(Global.strDatensatzPunkte[4, i]) < Global.fltGrenzRuecklauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz) Then
        booZ = False
'IF z > 3 THEN Message(i & " VL: " & strDatensatzPunkte[4, i]) 
      Endif
      If Global.strDatensatzPunkte[39, i] = "1" And CFloat(Global.strDatensatzPunkte[3, i]) < Global.fltGrenzVorlauftemperatur - Global.fltGrenzRuecklauftemperaturToleranz Then
        booZ = False
'IF z > 3 THEN Message(i & " RL: " & strDatensatzPunkte[3, i]) 
      Endif
      If global.booGLSPL = True Then
        If (Global.strDatensatzPunkte[39, i] = "1" And CFloat(Global.strDatensatzPunkte[33, i]) < Global.fltTWWRL - Global.fltGrenzRuecklauftemperaturToleranz) Then
          booZ = False
        Endif
        If Global.strDatensatzPunkte[39, i] = "1" And CFloat(Global.strDatensatzPunkte[32, i]) < Global.fltTWWVL - Global.fltGrenzRuecklauftemperaturToleranz Then
          booZ = False
        Endif
      Endif
    Endif
  Next

  For j = 0 To Global.intZeilenPunkte - 1
    'a ist Zählvariable der belegten Punkte und wird 0 gesetzt
    a = 0
    
    For i = 0 To Global.intZeilenPunkte - 1
      
      'wenn Anzahl der Nachnkoten > 0 dann
      If CInt(Global.strDatensatzPunkte[8, i]) > 0
        
        'wenn die Anzahl der Nachknoten = 1 dann
        If CInt(Global.strDatensatzPunkte[8, i]) = 1 Then
          
          'wenn aktueller Knoten noch nicht behandelt UND der Nachknoten schon behandelt Testbit = "1" dann
          If Global.strDatensatzPunkte[17, i] = "0" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i] - 1)] = "1" Then
            'Rücklauftemperatur wird berechnet
            Global.strDatensatzPunkte[4, i] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
          
            If Global.booMehrleiter = True Then
              Global.strDatensatzPunkte[23, i] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[23, CInt(Global.strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
              Global.strDatensatzPunkte[33, i] = CStr(funTemperatur(CFloat(Global.strDatensatzPunkte[33, CInt(Global.strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[10, i]) - 1])))
            Endif
            'aktueller Knoten wurde behandelt
            Global.strDatensatzPunkte[17, i] = "1"
          Endif
          
        Endif

      
        'wenn die Anzahl der Nachknoten = 2 dann
        If CInt(Global.strDatensatzPunkte[8, i]) = 2 Then
          
          'wenn aktueller Knoten noch nicht behandelt UND die beiden Nachknoten schon behandelt Testbit = "1" dann
          If Global.strDatensatzPunkte[17, i] = "0" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i] - 1)] = "1" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[11, i] - 1)] = "1" Then
            'berechne Temperatur1 aus dem 1. nachfolgenden Punkt
            Temperatur1 = funTemperatur(CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[10, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur1a = funTemperatur(CFloat(Global.strDatensatzPunkte[23, CInt(Global.strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[10, i]) - 1]))
              Temperatur1b = funTemperatur(CFloat(Global.strDatensatzPunkte[33, CInt(Global.strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[10, i]) - 1]))
            Endif
            
            'berechne Temperatur2 aus dem 2. nachfolgenden Punkt
            Temperatur2 = funTemperatur(CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[12, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur2a = funTemperatur(CFloat(Global.strDatensatzPunkte[23, CInt(Global.strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[12, i]) - 1]))
              Temperatur2b = funTemperatur(CFloat(Global.strDatensatzPunkte[33, CInt(Global.strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[12, i]) - 1]))
            Endif
            
            'berechne Massenstrom1 aus dem 1. nachfolgenden Punkt
            Massenstrom1 = CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[10, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom1a = CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[10, i]) - 1])
              Massenstrom1b = CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[10, i]) - 1])
            Endif
            
            'berechne Massenstrom2 aus dem 2. nachfolgenden Punkt
            Massenstrom2 = CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[12, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom2a = CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[12, i]) - 1])
              Massenstrom2b = CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[12, i]) - 1])
            Endif
            
            'Berechne Mischtemperatur (NOCH EINFÜGEN wenn Massenströme = 0 dann Mischtemp = Umgebungstemp!!!)
            If (Massenstrom1 + Massenstrom2) = 0 Then
              Global.strDatensatzPunkte[3, i] = CStr(Global.fltUmgebungstemperatur)
              Global.strDatensatzPunkte[4, i] = CStr(Global.fltUmgebungstemperatur)
            Else
              Global.strDatensatzPunkte[4, i] = CStr((Temperatur1 * Massenstrom1 + Temperatur2 * Massenstrom2) / (Massenstrom1 + Massenstrom2))
            Endif
            
            If Global.booMehrleiter = True Then
              If (Massenstrom1a + Massenstrom2a) = 0 Then
                Global.strDatensatzPunkte[22, i] = CStr(Global.fltUmgebungstemperatur)
                Global.strDatensatzPunkte[23, i] = CStr(Global.fltUmgebungstemperatur)
              Else
                Global.strDatensatzPunkte[23, i] = CStr((Temperatur1a * Massenstrom1a + Temperatur2a * Massenstrom2a) / (Massenstrom1a + Massenstrom2a))
              Endif
              If (Massenstrom1b + Massenstrom2b) = 0 Then
                Global.strDatensatzPunkte[32, i] = CStr(Global.fltUmgebungstemperatur)
                Global.strDatensatzPunkte[33, i] = CStr(Global.fltUmgebungstemperatur)
              Else
                Global.strDatensatzPunkte[33, i] = CStr((Temperatur1b * Massenstrom1b + Temperatur2b * Massenstrom2b) / (Massenstrom1b + Massenstrom2b))
              Endif
            Endif
            'aktueller Knoten wurde behandelt
            Global.strDatensatzPunkte[17, i] = "1"
          Endif
        
        Endif
          
        
        'wenn die Anzahl der Nachknoten = 3 dann
        If CInt(Global.strDatensatzPunkte[8, i]) = 3 Then
        
          'wenn aktueller Knoten noch nicht behandelt UND die drei Nachknoten schon behandelt Testbit = "1" dann
          If Global.strDatensatzPunkte[17, i] = "0" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[9, i] - 1)] = "1" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[11, i] - 1)] = "1" And Global.strDatensatzPunkte[17, CInt(Global.strDatensatzPunkte[13, i] - 1)] = "1" Then
            'berechne Temperatur1 aus dem 1. nachfolgenden Punkt
            Temperatur1 = funTemperatur(CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[10, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur1a = funTemperatur(CFloat(Global.strDatensatzPunkte[23, CInt(Global.strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[10, i]) - 1]))
              Temperatur1b = funTemperatur(CFloat(Global.strDatensatzPunkte[33, CInt(Global.strDatensatzPunkte[9, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[10, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[10, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[10, i]) - 1]))
            Endif
            
            'berechne Temperatur2 aus dem 2. nachfolgenden Punkt
            Temperatur2 = funTemperatur(CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[12, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur2a = funTemperatur(CFloat(Global.strDatensatzPunkte[23, CInt(Global.strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[12, i]) - 1]))
              Temperatur2b = funTemperatur(CFloat(Global.strDatensatzPunkte[33, CInt(Global.strDatensatzPunkte[11, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[12, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[12, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[12, i]) - 1]))
            Endif
            
            'berechne Temperatur3 aus dem 3. nachfolgenden Punkt
            Temperatur3 = funTemperatur(CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzPunkte[13, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[14, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[14, i]) - 1]))
            If Global.booMehrleiter = True Then
              Temperatur3a = funTemperatur(CFloat(Global.strDatensatzPunkte[23, CInt(Global.strDatensatzPunkte[13, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[14, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[14, i]) - 1]))
              Temperatur3b = funTemperatur(CFloat(Global.strDatensatzPunkte[33, CInt(Global.strDatensatzPunkte[13, i] - 1)]), CFloat(Global.fltUmgebungstemperatur), CFloat(Global.strDatensatzNetzTrasse[2, CInt(Global.strDatensatzPunkte[14, i]) - 1]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, CInt(Global.strDatensatzPunkte[14, i]) - 1]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[14, i]) - 1]))
            Endif
            
            'berechne Massenstrom2 aus dem 1. nachfolgenden Punkt
            Massenstrom1 = CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[10, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom1a = CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[10, i]) - 1])
              Massenstrom1b = CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[10, i]) - 1])
            Endif
            
            'berechne Massenstrom2 aus dem 2. nachfolgenden Punkt
            Massenstrom2 = CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[12, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom2a = CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[12, i]) - 1])
              Massenstrom2b = CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[12, i]) - 1])
            Endif
            
            'berechne Massenstrom2 aus dem 3. nachfolgenden Punkt
            Massenstrom3 = CFloat(Global.strDatensatzNetzTrasse[4, CInt(Global.strDatensatzPunkte[14, i]) - 1])
            If Global.booMehrleiter = True Then
              Massenstrom3a = CFloat(Global.strDatensatzNetzTrasse[15, CInt(Global.strDatensatzPunkte[14, i]) - 1])
              Massenstrom3b = CFloat(Global.strDatensatzNetzTrasse[26, CInt(Global.strDatensatzPunkte[14, i]) - 1])
            Endif
            
            'Berechne Mischtemperatur
            If (Massenstrom1 + Massenstrom2 + Massenstrom3) = 0 Then
              Global.strDatensatzPunkte[3, i] = CStr(Global.fltUmgebungstemperatur)
              Global.strDatensatzPunkte[4, i] = CStr(Global.fltUmgebungstemperatur)
            Else
              Global.strDatensatzPunkte[4, i] = CStr((Temperatur1 * Massenstrom1 + Temperatur2 * Massenstrom2 + Temperatur3 * Massenstrom3) / (Massenstrom1 + Massenstrom2 + Massenstrom3))
            Endif
            
            If Global.booMehrleiter = True Then
              If (Massenstrom1a + Massenstrom2a + Massenstrom3a) = 0 Then
                Global.strDatensatzPunkte[22, i] = CStr(Global.fltUmgebungstemperatur)
                Global.strDatensatzPunkte[23, i] = CStr(Global.fltUmgebungstemperatur)
              Else
                Global.strDatensatzPunkte[23, i] = CStr((Temperatur1a * Massenstrom1a + Temperatur2a * Massenstrom2a + Temperatur3a * Massenstrom3a) / (Massenstrom1a + Massenstrom2a + Massenstrom3a))
              Endif
              
              If (Massenstrom1b + Massenstrom2b + Massenstrom3b) = 0 Then
                Global.strDatensatzPunkte[32, i] = CStr(Global.fltUmgebungstemperatur)
                Global.strDatensatzPunkte[33, i] = CStr(Global.fltUmgebungstemperatur)
              Else
                Global.strDatensatzPunkte[33, i] = CStr((Temperatur1b * Massenstrom1b + Temperatur2b * Massenstrom2b + Temperatur3b * Massenstrom3b) / (Massenstrom1b + Massenstrom2b + Massenstrom3b))
              Endif
            Endif
            'aktueller Knoten wurde behandelt
            Global.strDatensatzPunkte[17, i] = "1"
          Endif
          
        Endif
        
      Endif
            'wenn Testbit (behandelter aktueller Punkt) = "1"  dann zähle a + 1 (a ist die Anzahl der behandelten Punkte)
      If Global.strDatensatzPunkte[17, i] = "1" Then a = a + 1
    
    Next
    'wenn alle Punkte mit Rücklauftemperatur <> 0 belegt sind, dann 'EXIT die Schleife um Zeit zu sparen
    If a = Global.intZeilenPunkte Then Goto ENDETRL
  
  Next
  Message("Bei Rücklauftemperaturbelegung maximale Anzahl an Durchläufen benötigt!")
ENDETRL:

'----Rücklauftemperaturen ENDE----  
'-------------------Berechne Temperaturen ENDE-----------------------------------------------------------     
  
  If booZ = True Then Goto ENDEZ

Next
ENDEZ:


'-----------------Druckverlust, Mitteltemperaturen und Wärmeverluste auf der Trasse-----------------------
  For i = 0 To Global.intZeilenNetzTrasse - 1
    'wenn der Massenstrom auf der Trasse <> "0"
    If Global.strDatensatzNetzTrasse[4, i] <> "0" Then
      'Mitteltemperatur Vorlauftrasse
      Global.strDatensatzNetzTrasse[8, i] = CStr((CFloat((Global.strDatensatzPunkte[3, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(Global.strDatensatzPunkte[3, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1])) / 2))
      If Global.booMehrleiter = True Then
        Global.strDatensatzNetzTrasse[19, i] = CStr((CFloat((Global.strDatensatzPunkte[22, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(Global.strDatensatzPunkte[22, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1])) / 2))
        Global.strDatensatzNetzTrasse[30, i] = CStr((CFloat((Global.strDatensatzPunkte[32, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(Global.strDatensatzPunkte[32, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1])) / 2))
      Endif
    
      'Mitteltemperatur Rücklauftrasse  
      Global.strDatensatzNetzTrasse[9, i] = ((CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1])) / 2)
      If Global.booMehrleiter = True Then
        Global.strDatensatzNetzTrasse[20, i] = CStr((CFloat((Global.strDatensatzPunkte[23, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(Global.strDatensatzPunkte[23, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1])) / 2))
        Global.strDatensatzNetzTrasse[31, i] = CStr((CFloat((Global.strDatensatzPunkte[33, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]) + CFloat(Global.strDatensatzPunkte[33, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1])) / 2))
      Endif
      'Waermetransport VL und RL Q=mcdT
      fltQ = (Global.strDatensatzNetzTrasse[4, i] * Global.cp * (Global.strDatensatzNetzTrasse[8, i] - Global.strDatensatzNetzTrasse[9, i]))
      
      If fltQ = 0 Then fltQ = 0.1
            
      'Wärmeverlust Vorlauftrasse absolut
      fltQ_VL = (CFloat(Global.strDatensatzNetzTrasse[4, i]) * Global.cp * 1000 * (CFloat(Global.strDatensatzPunkte[3, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]) - funTemperatur(CFloat(Global.strDatensatzPunkte[3, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(Global.strDatensatzNetzTrasse[2, i]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, i]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, i]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, i]))))
      Global.strDatensatzNetzTrasse[10, i] = CStr(fltQ_VL)
      If Global.booMehrleiter = True Then
        fltQ_VLa = (CFloat(Global.strDatensatzNetzTrasse[15, i]) * Global.cp * 1000 * (CFloat(Global.strDatensatzPunkte[22, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]) - funTemperatur(CFloat(Global.strDatensatzPunkte[22, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(Global.strDatensatzNetzTrasse[2, i]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, i]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, i]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, i]))))
        fltQ_VLb = (CFloat(Global.strDatensatzNetzTrasse[26, i]) * Global.cp * 1000 * (CFloat(Global.strDatensatzPunkte[32, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]) - funTemperatur(CFloat(Global.strDatensatzPunkte[32, CInt(Global.strDatensatzNetzTrasse[0, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(Global.strDatensatzNetzTrasse[2, i]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, i]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, i]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, i]))))
        Global.strDatensatzNetzTrasse[21, i] = CStr(fltQ_VLa)
        Global.strDatensatzNetzTrasse[32, i] = CStr(fltQ_VLb)
      Endif
         
      'Wärmeverlust Rücklauftrasse absolut
      fltQ_RL = (CFloat(Global.strDatensatzNetzTrasse[4, i]) * Global.cp * 1000 * (CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1]) - funTemperatur(CFloat(Global.strDatensatzPunkte[4, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(Global.strDatensatzNetzTrasse[2, i]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[3, i]) / 2, CFloat(Global.strDatensatzNetzTrasse[3, i]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[3, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[4, i]))))
      Global.strDatensatzNetzTrasse[11, i] = CStr(fltQ_RL)
      If Global.booMehrleiter = True Then
        fltQ_RLa = (CFloat(Global.strDatensatzNetzTrasse[15, i]) * Global.cp * 1000 * (CFloat(Global.strDatensatzPunkte[23, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1]) - funTemperatur(CFloat(Global.strDatensatzPunkte[23, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(Global.strDatensatzNetzTrasse[2, i]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[14, i]) / 2, CFloat(Global.strDatensatzNetzTrasse[14, i]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[14, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[15, i]))))
        fltQ_RLb = (CFloat(Global.strDatensatzNetzTrasse[26, i]) * Global.cp * 1000 * (CFloat(Global.strDatensatzPunkte[33, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1]) - funTemperatur(CFloat(Global.strDatensatzPunkte[33, CInt(Global.strDatensatzNetzTrasse[1, i]) - 1]), Global.fltUmgebungstemperatur, CFloat(Global.strDatensatzNetzTrasse[2, i]), funLambda(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[25, i]) / 2, CFloat(Global.strDatensatzNetzTrasse[25, i]) / 2 + funDaemmstaerke(Global.strDatensatzRohre, CFloat(Global.strDatensatzNetzTrasse[25, i]) / 2), CFloat(Global.strDatensatzNetzTrasse[26, i]))))
        Global.strDatensatzNetzTrasse[22, i] = CStr(fltQ_RLa)
        Global.strDatensatzNetzTrasse[33, i] = CStr(fltQ_RLb)
      Endif
    
      'Wärmeverlust Vorlauftrasse relativ
      Global.strDatensatzNetzTrasse[12, i] = CStr(fltQ_VL / (CFloat(Global.strDatensatzNetzTrasse[2, i]) * fltQ))
      If Global.booMehrleiter = True Then
        Global.strDatensatzNetzTrasse[23, i] = CStr(fltQ_VLa / (CFloat(Global.strDatensatzNetzTrasse[2, i]) * fltQ))
        Global.strDatensatzNetzTrasse[34, i] = CStr(fltQ_VLb / (CFloat(Global.strDatensatzNetzTrasse[2, i]) * fltQ))
      Endif
    
      'Wärmeverlust Rücklauftrasse relativ
      Global.strDatensatzNetzTrasse[13, i] = CStr(fltQ_RL / (CFloat(Global.strDatensatzNetzTrasse[2, i]) * fltQ))
      If Global.booMehrleiter = True Then
        Global.strDatensatzNetzTrasse[24, i] = CStr(fltQ_RLa / CFloat(Global.strDatensatzNetzTrasse[2, i]))
        Global.strDatensatzNetzTrasse[35, i] = CStr(fltQ_RLb / CFloat(Global.strDatensatzNetzTrasse[2, i]))
      Endif
    
      'Druckverlust
      'function funDruckverlust(RHO AS Float, k AS Float, alpha AS Float, ms AS Float, l AS Float, di AS Float)
      Global.strDatensatzNetzTrasse[5, i] = CStr(2 * funDruckverlust(1000, Global.k, Global.fltZuschlagFormstuecke, CFloat(Global.strDatensatzNetzTrasse[4, i]), CFloat(Global.strDatensatzNetzTrasse[2, i]), CFloat(Global.strDatensatzNetzTrasse[3, i])))
      If Global.booMehrleiter = True Then
        Global.strDatensatzNetzTrasse[16, i] = CStr(2 * funDruckverlust(1000, Global.k, Global.fltZuschlagFormstuecke, CFloat(Global.strDatensatzNetzTrasse[15, i]), CFloat(Global.strDatensatzNetzTrasse[2, i]), CFloat(Global.strDatensatzNetzTrasse[14, i])))
        Global.strDatensatzNetzTrasse[27, i] = CStr(2 * funDruckverlust(1000, Global.k, Global.fltZuschlagFormstuecke, CFloat(Global.strDatensatzNetzTrasse[26, i]), CFloat(Global.strDatensatzNetzTrasse[2, i]), CFloat(Global.strDatensatzNetzTrasse[25, i])))
      Endif
    
    Else  'kein Massenstrom auf der Trasse
    
      'Mitteltemperatur Vorlauftrasse
      Global.strDatensatzNetzTrasse[8, i] = CStr(Global.fltUmgebungstemperatur)
      Global.strDatensatzNetzTrasse[19, i] = CStr(Global.fltUmgebungstemperatur)
      Global.strDatensatzNetzTrasse[30, i] = CStr(Global.fltUmgebungstemperatur)
      'Mitteltemperatur Rücklauftrasse  
      Global.strDatensatzNetzTrasse[9, i] = CStr(Global.fltUmgebungstemperatur)
      Global.strDatensatzNetzTrasse[20, i] = CStr(Global.fltUmgebungstemperatur)
      Global.strDatensatzNetzTrasse[31, i] = CStr(Global.fltUmgebungstemperatur)
      'Wärmeverlust Vorlauftrasse absolut
      Global.strDatensatzNetzTrasse[10, i] = "0"
      Global.strDatensatzNetzTrasse[21, i] = "0"
      Global.strDatensatzNetzTrasse[32, i] = "0"
      'Wärmeverlust Rücklauftrasse absolut
      Global.strDatensatzNetzTrasse[11, i] = "0"
      Global.strDatensatzNetzTrasse[22, i] = "0"
      Global.strDatensatzNetzTrasse[33, i] = "0"
      'Wärmeverlust Vorlauftrasse relativ
      Global.strDatensatzNetzTrasse[12, i] = "0"
      Global.strDatensatzNetzTrasse[23, i] = "0"
      Global.strDatensatzNetzTrasse[34, i] = "0"
      'Wärmeverlust Rücklauftrasse relativ
      Global.strDatensatzNetzTrasse[13, i] = "0"
      Global.strDatensatzNetzTrasse[24, i] = "0"
      Global.strDatensatzNetzTrasse[35, i] = "0"
      'Druckverlust
      Global.strDatensatzNetzTrasse[5, i] = "0"
      Global.strDatensatzNetzTrasse[16, i] = "0"
      Global.strDatensatzNetzTrasse[27, i] = "0"
      
    Endif
  Next
'-----------------Druckverlust, Mitteltemperaturen und Wärmeverluste auf der Trasse ENDE-----------------------

  
  berechne_dP_MS_PWaermeOUT_PWaermeVerlust_fuer_Simulation()
  '-------Schreibe Ergebnisse in globale Variablen zurück----------------  
  'Stunde [h]
  Global.strDatensatzSimErgebnis[0, intStunde] = CStr(intStunde + 1)
  'Temp Vorlauf[°C]
  Global.strDatensatzSimErgebnis[1, intStunde] = CStr(Global.strDatensatzPunkte[3, Global.intEinspeisepunkt])
  'Temp Rücklauf [°C]
  Global.strDatensatzSimErgebnis[2, intStunde] = CStr(Global.strDatensatzPunkte[4, Global.intEinspeisepunkt])
  'Temp Erdreich [°C]
  Global.strDatensatzSimErgebnis[3, intStunde] = CStr(Global.fltUmgebungstemperatur)
  'Temp Luft [°C]
  Global.strDatensatzSimErgebnis[4, intStunde] = CStr(global.strDatensatzKlimaTag[0, Int(intStunde / 24) + 1])
  'Temp Vorlauf[°C] Mehrleiter großes Rohr
  Global.strDatensatzSimErgebnis[5, intStunde] = CStr(Global.strDatensatzPunkte[22, Global.intEinspeisepunkt])
  'Temp Rücklauf [°C] Mehrleiter großes Rohr
  Global.strDatensatzSimErgebnis[6, intStunde] = CStr(Global.strDatensatzPunkte[23, Global.intEinspeisepunkt])
  'Temp Vorlauf[°C] Mehrleiter kleines Rohr
  Global.strDatensatzSimErgebnis[7, intStunde] = CStr(Global.strDatensatzPunkte[32, Global.intEinspeisepunkt])
  'Temp Rücklauf [°C] Mehrleiter kleines Rohr
  Global.strDatensatzSimErgebnis[8, intStunde] = CStr(Global.strDatensatzPunkte[33, Global.intEinspeisepunkt])
  'dP [bar]
  Global.strDatensatzSimErgebnis[10, intStunde] = CStr(Global.fltDP)
  'Massenstrom [kg/s]
  Global.strDatensatzSimErgebnis[11, intStunde] = CStr(Global.strDatensatzPunkte[5, Global.intEinspeisepunkt])
  'dP [bar] Mehrleiter großes Rohr
  Global.strDatensatzSimErgebnis[12, intStunde] = CStr(Global.fltDP2a)
  'Massenstrom [kg/s] Mehrleiter großes Rohr
  Global.strDatensatzSimErgebnis[13, intStunde] = CStr(Global.strDatensatzPunkte[24, Global.intEinspeisepunkt])
    'dP [bar] Mehrleiter kleines Rohr
  Global.strDatensatzSimErgebnis[14, intStunde] = CStr(Global.fltDP2b)
  'Massenstrom [kg/s] Mehrleiter kleines Rohr
  Global.strDatensatzSimErgebnis[15, intStunde] = CStr(Global.strDatensatzPunkte[34, Global.intEinspeisepunkt])
  'Pumpleistung hydraulisch [kW]
  Global.strDatensatzSimErgebnis[20, intStunde] = CStr(((CFloat(Global.strDatensatzPunkte[5, Global.intEinspeisepunkt]) / 1000) * Global.fltDP * 100000) / 1000)
  'Pumpleistung elektrisch [kW]
  Global.strDatensatzSimErgebnis[21, intStunde] = CStr(CFloat(Global.strDatensatzSimErgebnis[20, intStunde]) / global.fltWirkungsgradPumpe)
  'Leistung Wärme eingepeist
  Global.strDatensatzSimErgebnis[22, intStunde] = CStr(global.fltPWaermeOUT + global.fltPWaermeVERLUST)
  'Leistung Wärme verkauft
  Global.strDatensatzSimErgebnis[23, intStunde] = CStr(global.fltPWaermeOUT)
  'Leistung Wärme Verlust
  Global.strDatensatzSimErgebnis[24, intStunde] = CStr(global.fltPWaermeVERLUST)
  'Pumpleistung hydraulisch [kW] Mehrleiter großes Rohr
  Global.strDatensatzSimErgebnis[30, intStunde] = CStr(((CFloat(Global.strDatensatzPunkte[24, Global.intEinspeisepunkt]) / 1000) * Global.fltDP2a * 100000) / 1000)
  'Pumpleistung elektrisch [kW] Mehrleiter großes Rohr
  Global.strDatensatzSimErgebnis[31, intStunde] = CStr(CFloat(Global.strDatensatzSimErgebnis[30, intStunde]) / global.fltWirkungsgradPumpe)
  'Leistung Wärme eingepeist Mehrleiter großes Rohr
  Global.strDatensatzSimErgebnis[32, intStunde] = CStr(global.fltPWaermeOUT2a + global.fltPWaermeVERLUST2a)
  'Leistung Wärme verkauft Mehrleiter großes Rohr
  Global.strDatensatzSimErgebnis[33, intStunde] = CStr(global.fltPWaermeOUT2a)
  'Leistung Wärme Verlust Mehrleiter großes Rohr
  Global.strDatensatzSimErgebnis[34, intStunde] = CStr(global.fltPWaermeVERLUST2a)
    'Pumpleistung hydraulisch [kW] Mehrleiter kleines Rohr
  Global.strDatensatzSimErgebnis[40, intStunde] = CStr(((CFloat(Global.strDatensatzPunkte[34, Global.intEinspeisepunkt]) / 1000) * Global.fltDP2b * 100000) / 1000)
  'Pumpleistung elektrisch [kW] Mehrleiter kleines Rohr
  Global.strDatensatzSimErgebnis[41, intStunde] = CStr(CFloat(Global.strDatensatzSimErgebnis[40, intStunde]) / global.fltWirkungsgradPumpe)
  'Leistung Wärme eingepeist Mehrleiter kleines Rohr
  Global.strDatensatzSimErgebnis[42, intStunde] = CStr(global.fltPWaermeOUT2b + global.fltPWaermeVERLUST2b)
  'Leistung Wärme verkauft Mehrleiter kleines Rohr
  Global.strDatensatzSimErgebnis[43, intStunde] = CStr(global.fltPWaermeOUT2b)
  'Leistung Wärme Verlust Mehrleiter kleines Rohr
  Global.strDatensatzSimErgebnis[44, intStunde] = CStr(global.fltPWaermeVERLUST2b)
  
  '------schreibe Daten in globalen Trassendatensatz------------
  For i = 0 To Global.intZeilenNetzTrasse - 1
    For j = 0 To 3
      Global.strDatensatzNetzTrasseSimulationsErgebnis[j, i] = Global.strDatensatzNetzTrasse[j, i]
    Next
    'Wärmemenge Transport absolut VL und RL (Q = m*c*dT)  
    Global.strDatensatzNetzTrasseSimulationsErgebnis[4, i] += (Global.strDatensatzNetzTrasse[4, i] * Global.cp * (Global.strDatensatzNetzTrasse[8, i] - Global.strDatensatzNetzTrasse[9, i]))
    'Wärmemenge Verlust absolut VL und RL
    Global.strDatensatzNetzTrasseSimulationsErgebnis[6, i] += ((Global.strDatensatzNetzTrasse[10, i] + Global.strDatensatzNetzTrasse[11, i]) / 1000) 'W -> kW
    'Wärmemenge Verlust absolut VL
    Global.strDatensatzNetzTrasseSimulationsErgebnis[7, i] += (Global.strDatensatzNetzTrasse[10, i] / 1000)
    'Wärmemenge Verlust absolut VL
    Global.strDatensatzNetzTrasseSimulationsErgebnis[8, i] += (Global.strDatensatzNetzTrasse[11, i] / 1000)
    'Durchmesser 2a (bei Mehrleiter Rohr a)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[10, i] += Global.strDatensatzNetzTrasse[14, i]
    'Wärmemenge Transport absolut VL und RL (Q = m*c*dT) 2a (bei Mehrleiter Rohr a)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[11, i] += (Global.strDatensatzNetzTrasse[15, i] * Global.cp * (Global.strDatensatzNetzTrasse[19, i] - Global.strDatensatzNetzTrasse[20, i]))
    'Wärmemenge Verlust absolut VL und RL 2a (bei Mehrleiter Rohr a)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[13, i] += ((Global.strDatensatzNetzTrasse[21, i] + Global.strDatensatzNetzTrasse[22, i]) / 1000) 'W->kW
    'Wärmemenge Verlust absolut VL 2a (bei Mehrleiter Rohr a)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[14, i] += (Global.strDatensatzNetzTrasse[21, i] / 1000)
    'Wärmemenge Verlust absolut VL 2a (bei Mehrleiter Rohr a)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[15, i] += (Global.strDatensatzNetzTrasse[22, i] / 1000)
    'Durchmesser 2b (bei Mehrleiter Rohr b)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[17, i] += Global.strDatensatzNetzTrasse[25, i]
    'Wärmemenge Transport absolut VL und RL (Q = m*c*dT) 2b (bei Mehrleiter Rohr b)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[18, i] += ((Global.strDatensatzNetzTrasse[26, i] * Global.cp * (Global.strDatensatzNetzTrasse[30, i] - Global.strDatensatzNetzTrasse[31, i])) / 1000)
    'Wärmemenge Verlust absolut VL und RL 2b (bei Mehrleiter Rohr b)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[20, i] += ((Global.strDatensatzNetzTrasse[32, i] + Global.strDatensatzNetzTrasse[33, i]) / 1000)
    'Wärmemenge Verlust absolut VL 2b (bei Mehrleiter Rohr b)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[21, i] += (Global.strDatensatzNetzTrasse[32, i] / 1000)
    'Wärmemenge Verlust absolut VL 2b (bei Mehrleiter Rohr b)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[22, i] += (Global.strDatensatzNetzTrasse[33, i] / 1000)
  Next
  
  
  For i = 0 To Global.intZeilenNetzTrasse - 1
    'Wärmemenge Transport spezifisch VL und RL (Q/l)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[5, i] = (Global.strDatensatzNetzTrasseSimulationsErgebnis[4, i] / Global.strDatensatzNetzTrasseSimulationsErgebnis[2, i])
    'Wärmemenge Verlust spezifisch VL und RL
    Global.strDatensatzNetzTrasseSimulationsErgebnis[9, i] = (Global.strDatensatzNetzTrasseSimulationsErgebnis[7, i] + Global.strDatensatzNetzTrasseSimulationsErgebnis[8, i]) / Global.strDatensatzNetzTrasse[2, i]
  
    'Wärmemenge Transport spezifisch VL und RL (Q/l) 2a (bei Mehrleiter Rohr a)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[12, i] = (Global.strDatensatzNetzTrasseSimulationsErgebnis[11, i] / Global.strDatensatzNetzTrasseSimulationsErgebnis[2, i])
    'Wärmemenge Verlust spezifisch VL und RL 2a (bei Mehrleiter Rohr a)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[16, i] = (Global.strDatensatzNetzTrasseSimulationsErgebnis[14, i] + Global.strDatensatzNetzTrasseSimulationsErgebnis[15, i]) / Global.strDatensatzNetzTrasse[2, i]
  
    'Wärmemenge Transport spezifisch VL und RL (Q/l) 2b (bei Mehrleiter Rohr b)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[19, i] = (Global.strDatensatzNetzTrasseSimulationsErgebnis[18, i] / Global.strDatensatzNetzTrasseSimulationsErgebnis[2, i])
    'Wärmemenge Verlust spezifisch VL und RL 2a (bei Mehrleiter Rohr a)
    Global.strDatensatzNetzTrasseSimulationsErgebnis[23, i] = (Global.strDatensatzNetzTrasseSimulationsErgebnis[21, i] + Global.strDatensatzNetzTrasseSimulationsErgebnis[22, i]) / Global.strDatensatzNetzTrasse[2, i]
   'Wärmemenge Verlust Prozent
    If CFloat(Global.strDatensatzNetzTrasseSimulationsErgebnis[4, i]) > 0 Then
      Global.strDatensatzNetzTrasseSimulationsErgebnis[24, i] = (Global.strDatensatzNetzTrasseSimulationsErgebnis[6, i] / Global.strDatensatzNetzTrasseSimulationsErgebnis[4, i]) * 100
    Else
      Global.strDatensatzNetzTrasseSimulationsErgebnis[24, i] = "0"
    Endif
    'Wärmemenge Verlust Prozent 2a
    If CFloat(Global.strDatensatzNetzTrasseSimulationsErgebnis[11, i]) > 0 Then
      Global.strDatensatzNetzTrasseSimulationsErgebnis[25, i] = (Global.strDatensatzNetzTrasseSimulationsErgebnis[13, i] / Global.strDatensatzNetzTrasseSimulationsErgebnis[11, i]) * 100
    Else
      Global.strDatensatzNetzTrasseSimulationsErgebnis[25, i] = "0"
    Endif
    'Wärmemenge Verlust Prozent 2b
    If CFloat(Global.strDatensatzNetzTrasseSimulationsErgebnis[15, i]) > 0 Then
      Global.strDatensatzNetzTrasseSimulationsErgebnis[26, i] = (Global.strDatensatzNetzTrasseSimulationsErgebnis[17, i] / Global.strDatensatzNetzTrasseSimulationsErgebnis[15, i]) * 100
    Else
      Global.strDatensatzNetzTrasseSimulationsErgebnis[26, i] = "0"
    Endif
  Next
  '-----ENDE --schreibe Daten in globalen Trassendatensatz------------
  
End





Public Sub Dimensionierung()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim strDatensatzPunkte As New String[Global.conSpaltenPunkte, Global.conMaxDatensaetze]
Dim strDatensatzNetzTrasse As New String[Global.conSpaltenTrasse, Global.conMaxDatensaetze]
Dim strDatensatzNetzTrasseMIF As New String[Global.conMaxDatensaetze * 3 + 5 + Global.conSpaltenTrasse]
Dim strDatensatzRohre As New String[12, Global.conMaxRohre]
Dim intZeilenNetzTrasse, intZeilenPunkte, intZeilenNetzTrasseMIF As Integer
Dim a, b, i, j, z As Integer
Dim intNetzTrasseSpaltenzahl As Integer
Dim intZeilenRohre As Integer
Dim di, dp As Float
Dim fltAuslegeleistung, fltAnteilP As Float
  

'--------------------Dateien einlesen---------------------------------------------------     
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameBibRohre & ".csv" For Input 'öffnen der Datei Rohre.csv
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzRohre[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenRohre = b
  Close #hsDatei  'schließe Datei Rohre.csv
  
 
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MID" For Input 'öffnen der Datei NetzTrasse.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzNetzTrasse[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    intNetzTrasseSpaltenzahl = a
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenNetzTrasse = b
  Close #hsDatei  'schließe Datei NetzTrasse.MID

  
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MIF" For Input 'öffnen der Datei NetzTrasse.MIF
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzNetzTrasseMIF[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenNetzTrasseMIF = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF


  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Input 'öffnen der Datei Punkte.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzPunkte[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenPunkte = b
  Close #hsDatei  'schließe Datei Punkte.MID
'--------------------Dateien einlesen ENDE---------------------------------------------------   

      
'------------aktuelle Leistung an den Abnehmern-----------------------------------------------------
  'Setze die PAktuell, Lege die Massenströme an den Abnehmern fest
  For i = 0 To intZeilenPunkte - 1
    'wenn QJahr > 0 dann (Abnehmer)
    If CFloat(strDatensatzPunkte[20, i]) > 0 Then
      'wenn Abnehmer wird mitgerechnet (Spalte 39) dann belege Abnehmer mit Massenstrom
      If strDatensatzPunkte[39, i] = "1" Then
        strDatensatzPunkte[18, i] = CStr(funQStd_Dimensionierung(CFloat(strDatensatzPunkte[21, i]), strDatensatzPunkte[16, i], Global.fltAuslegungstemperatur))
      Else
        strDatensatzPunkte[18, i] = "0"
      Endif
            
      'Vierleiterfall
      If Global.booMehrleiter = True Then
        'wenn Abnehmer wird mitgerechnet (Spalte 39) dann belege Abnehmer mit Massenstrom
        If strDatensatzPunkte[39, i] = "1" Then
          fltAuslegeleistung = funQStd_Dimensionierung(CFloat(strDatensatzPunkte[21, i]), strDatensatzPunkte[16, i], Global.fltAuslegungstemperatur)
          'Bruch ist Anteil Teilastleistung an Auslegungsleistung
          fltAnteilP = CFloat(strDatensatzPunkte[18, i]) / fltAuslegeleistung
          
          'wenn Mehrleiternetz in Spitzen und Grundlast geteilt dann Pakt:
          If Global.booGLSPL = True Then
            If Global.fltAuslegungstemperatur >= Global.conHeizGrenzTemperaturTWW Then
              strDatensatzPunkte[25, i] = "0"
              strDatensatzPunkte[35, i] = CStr(funQStd_Dimensionierung(CFloat(strDatensatzPunkte[21, i]), strDatensatzPunkte[16, i], Global.fltAuslegungstemperatur))
            Else
              'die Temperatur 32 soll den nur TWWB Fall simulieren
              strDatensatzPunkte[35, i] = CStr(funQStd_Dimensionierung(CFloat(strDatensatzPunkte[21, i]), strDatensatzPunkte[16, i], Global.conHeizGrenzTemperaturTWW))
              'der Anschlussgrad 0 bedeutet keine TWWB
              strDatensatzPunkte[25, i] = CStr(funQStd_Dimensionierung(CFloat(strDatensatzPunkte[21, i]), strDatensatzPunkte[16, i], Global.fltAuslegungstemperatur) - CFloat(strDatensatzPunkte[35, i]))
            Endif
          Else
            'Wenn der Leistungsanteil im Teillastfall kleiner ist als der Anteil für den kleineren Leiter ist wird Betriebsart 1: alles im kleinen Rohr gewählt
            If fltAnteilP * 100 <= Global.fltMLAnteilLeiter2 Then
              global.intMLNetzBetrieb = 1
            Endif
            'Wenn der Leistungsanteil im Teillastfall größer ist als der Anteil für den kleineren Leiter ist und kleiner als der Anteil für den größeren Leiter wird Betriebsart 2: alles im größeren Rohr gewählt
            If fltAnteilP * 100 > Global.fltMLAnteilLeiter2 And fltAnteilP * 100 <= (100 - Global.fltMLAnteilLeiter2) Then
              global.intMLNetzBetrieb = 2
            Endif
            'Wenn der Leistungsanteil im Teillastfall größer ist als der Anteil für den größeren Leiter ist wird Betriebsart 3: alles in beiden Rohren gewählt
            If fltAnteilP * 100 >= (100 - Global.fltMLAnteilLeiter2) Then
              global.intMLNetzBetrieb = 3
            Endif
        
            Select Case global.intMLNetzBetrieb
            Case 1
              strDatensatzPunkte[25, i] = "0"
              strDatensatzPunkte[35, i] = strDatensatzPunkte[18, i]
            Case 2
              strDatensatzPunkte[25, i] = strDatensatzPunkte[18, i]
              strDatensatzPunkte[35, i] = "0"
            Case 3
              'erst das größere Rohr voll belegen
              strDatensatzPunkte[25, i] = CStr(fltAuslegeleistung * ((100 - Global.fltMLAnteilLeiter2) / 100))
              'dann den Rest auf das kleiner Rohr geben
              strDatensatzPunkte[35, i] = CStr(CFloat(strDatensatzPunkte[18, i]) - CFloat(strDatensatzPunkte[25, i]))
            End Select
          Endif
        'wenn Abnehmer berücksichtigen (Spalte 39) = "0" dann Pakta/b = "0"
        Else
           strDatensatzPunkte[25, i] = "0"
           strDatensatzPunkte[35, i] = "0"
        Endif
      Endif
    Endif
    'Testbit Punkt behandelt wird für alle auf "0" gesetzt
    strDatensatzPunkte[17, i] = "0"
  Next
'------------aktuelle Leistung an den Abnehmern ENDE----------------------------------------------------- 
  
  
  
'-------------------Massenströme berechnen---------------------------------------------------
'Vorbelegung der mit Startwerten 
  For i = 0 To intZeilenPunkte - 1
    'Setze die Massenströme auf 0
    strDatensatzPunkte[5, i] = "0"      'Massenstrom
    strDatensatzPunkte[19, i] = "0"     'MSakt
    strDatensatzPunkte[24, i] = "0"     'Massenstrom2a
    strDatensatzPunkte[34, i] = "0"     'Massenstrom2b
    
    'Belege die AbnehmerPunkte mit Massenströmen
    'Wenn noch nicht behandelt und kein nachfolge Punkt vorhanden
    If strDatensatzPunkte[17, i] = "0" And strDatensatzPunkte[8, i] = "0" Then
      strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[18, i]) / (Global.cp * Global.fltdeltaTHaus))
      strDatensatzPunkte[19, i] = strDatensatzPunkte[5, i]
    
      If Global.booMehrleiter = True Then
        strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[25, i]) / (Global.cp * Global.fltdeltaTHaus))
        strDatensatzPunkte[26, i] = strDatensatzPunkte[24, i]
        If Global.booGLSPL = True Then
          strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[35, i]) / (Global.cp * Global.fltTWWdT))
        Else
          strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[35, i]) / (Global.cp * Global.fltdeltaTHaus))
        Endif
        strDatensatzPunkte[36, i] = strDatensatzPunkte[34, i]
      Else
        strDatensatzPunkte[24, i] = "0"
        strDatensatzPunkte[26, i] = "0"
        strDatensatzPunkte[34, i] = "0"
        strDatensatzPunkte[36, i] = "0"
      Endif
     
      'Punkt behandelt
      strDatensatzPunkte[17, i] = "1"
    Endif
  Next
    
  
  For j = 0 To intZeilenPunkte - 1
    a = 0
    For i = 0 To intZeilenPunkte - 1
      'Wenn die Anzahl der Nachknoten > 0
      If CInt(strDatensatzPunkte[8, i]) > 0
        
        'Wenn es einen Nachknoten gibt
        If CInt(strDatensatzPunkte[8, i]) = 1 Then
          
          'Wenn Qakt = 0 (der aktuelle Punkt kein Abnehmer ist) UND der nachfolgende Punkte bereits behandelt wurde dann
          If strDatensatzPunkte[18, i] = "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] <> "0" Then
            'übertrage den Massenstrom des Folgepunktes auf den aktuellen
            strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[9, i] - 1)]))
          
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[9, i] - 1)]))
              strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[9, i] - 1)]))
            Endif
            
            'Punkt bearbeitet => Testbit = "1"
            strDatensatzPunkte[17, i] = "1"
              
          Endif
          
          'Fall Zwischenabnehmer!!!          
          If strDatensatzPunkte[18, i] <> "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] <> "0" Then
            'Leistung wird in diesem Punkt gelöscht
            strDatensatzPunkte[39, i] = "0"
            strDatensatzPunkte[15, i] = "0"
            strDatensatzPunkte[18, i] = "0"
            strDatensatzPunkte[25, i] = "0"
            strDatensatzPunkte[35, i] = "0"
                        
            'Behandlung wie normalen Punkt
            strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[9, i] - 1)]))
            
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[9, i] - 1)]))
              strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[9, i] - 1)]))
            Endif
            
            'Punkt bearbeitet => Testbit = "1"
            strDatensatzPunkte[17, i] = "1"
          Endif
          
        Endif
        
        
        'Wenn es zwei Nachknoten gibt
        If CInt(strDatensatzPunkte[8, i]) = 2 Then
          
          'wenn der Massenstrom des 1. Nachfolgen Punktes <> 0 UND der Massenstrom des 2. Nachfolgen Punktes <> 0 dann
          If strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] <> "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[11, i] - 1)] <> "0" Then
            'ist der Massentstrom des aktuellen Punktes die Summe der beiden nachfolgenden Massenströme (Makt= Mn1+Mn2)
            strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[11, i] - 1)]))

            If Global.booMehrleiter = True Then
              strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[11, i] - 1)]))
              strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[11, i] - 1)]))
            Endif
            
            'Punkt bearbeitet => Testbit = "1"
            strDatensatzPunkte[17, i] = "1"
          Endif
            
        Endif
        
        
        'Wenn es drei Nachknoten gibt  
        If CInt(strDatensatzPunkte[8, i]) = 3 Then
          'wenn der Massenstrom des 1. Nachfolgen Punktes <> 0 UND der Massenstrom des 2. Nachfolgen Punktes <> 0 UND der Massenstrom des 3. Nachfolgen Punktes <> 0 dann
          If strDatensatzPunkte[17, CInt(strDatensatzPunkte[9, i] - 1)] <> "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[11, i] - 1)] <> "0" And strDatensatzPunkte[17, CInt(strDatensatzPunkte[13, i] - 1)] <> "0" Then
            'ist der Massentstrom des aktuellen Punktes die Summe der drei nachfolgenden Massenströme (Makt= Mn1+Mn2+Mn3)
            strDatensatzPunkte[5, i] = CStr(CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[11, i] - 1)] + CFloat(strDatensatzPunkte[5, CInt(strDatensatzPunkte[13, i] - 1)])))
      
            If Global.booMehrleiter = True Then
              strDatensatzPunkte[24, i] = CStr(CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[11, i] - 1)] + CFloat(strDatensatzPunkte[24, CInt(strDatensatzPunkte[13, i] - 1)])))
              strDatensatzPunkte[34, i] = CStr(CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[9, i] - 1)]) + CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[11, i] - 1)] + CFloat(strDatensatzPunkte[34, CInt(strDatensatzPunkte[13, i] - 1)])))
            Endif
          
            'Punkt bearbeitet => Testbit = "1"
            strDatensatzPunkte[17, i] = "1"
          Endif
           
        Endif
        
      Endif
      
      'wenn Testbit (behandelter aktueller Punkt) = "1"  dann zähle a + 1 (a ist die Anzahl der behandelten Punkte)
      If strDatensatzPunkte[17, i] = "1" Then a = a + 1
    
    Next
    
    'wenn alle Punkte behandelt sind, dann 
    If a = intZeilenPunkte Then
      'EXIT die Schleife um Zeit zu sparen
      Goto ENDEMASSEN
    Endif
  
  Next
  Message("Bei Massenstrombelegung maximale Anzahl an Durchläufen benötigt!")
ENDEMASSEN:

  For i = 0 To intZeilenPunkte - 1
    'Warnmeldung
    'IF strDatensatzPunkte[5, i] = "0" THEN 
      'Message("Warnung: Am Punkt " & CStr(i + 1) & " ist der Massenstrom = 0")
    'ENDIF 
    
    'Übertrage Massenstrom von Punkten auf Trasse (wenn Trassennummer vorher <> "0") 
    If strDatensatzPunkte[7, i] <> "0" Then
      strDatensatzNetzTrasse[4, strDatensatzPunkte[7, i] - 1] = strDatensatzPunkte[5, i]
      
      If Global.booMehrleiter = True Then
        strDatensatzNetzTrasse[15, strDatensatzPunkte[7, i] - 1] = strDatensatzPunkte[24, i]
        strDatensatzNetzTrasse[26, strDatensatzPunkte[7, i] - 1] = strDatensatzPunkte[34, i]
      Else
        strDatensatzNetzTrasse[15, strDatensatzPunkte[7, i] - 1] = "0"
        strDatensatzNetzTrasse[26, strDatensatzPunkte[7, i] - 1] = "0"
      Endif
    
    Endif
  Next
'-------------------Massenströme berechnen ENDE---------------------------------------------------  






'------------------Dimensionierung-----------------------------------------------
  'Nullsetzen aller Daten ausser AK EK Länge und die MS, MS1a, MS2a
  For i = 0 To intZeilenNetzTrasse - 1
    For j = 3 To 3
      If strDatensatzNetzTrasse[36, i] = "0" Then strDatensatzNetzTrasse[j, i] = "0"
    Next
    For j = 5 To 13
      strDatensatzNetzTrasse[j, i] = "0"
    Next
    For j = 14 To 14
      If strDatensatzNetzTrasse[36, i] = "0" Then strDatensatzNetzTrasse[j, i] = "0"
    Next
    For j = 16 To 24
      strDatensatzNetzTrasse[j, i] = "0"
    Next
    For j = 25 To 25
      If strDatensatzNetzTrasse[36, i] = "0" Then strDatensatzNetzTrasse[j, i] = "0"
    Next
    For j = 27 To 35
      strDatensatzNetzTrasse[j, i] = "0"
    Next
    For j = 37 To Global.conSpaltenTrasse - 1
      strDatensatzNetzTrasse[j, i] = "0"
    Next
  Next
  
  For i = 0 To intZeilenNetzTrasse - 1
    'wenn Massenstrom > 0 und VorDim = "0" dann
    If CFloat(strDatensatzNetzTrasse[4, i]) > 0 And strDatensatzNetzTrasse[36, i] = "0" Then
      'größter Rohrdurchmesser
      z = intZeilenRohre - 1
      a = 0
      While a = 0
        di = CFloat(strDatensatzRohre[1, z])
        'funDruckverlust(RHO AS Float, k AS Float, alpha AS Float, ms AS Float, l AS Float, di AS Float)
        dp = funDruckverlust(1000, Global.k, 0.3, CFloat(strDatensatzNetzTrasse[4, i]), CFloat(strDatensatzNetzTrasse[2, i]), di)
        If dp > Global.fltMaxDP * CFloat(strDatensatzNetzTrasse[2, i]) / 100000 Then
          a = 1
          If z < intZeilenRohre - 1 Then 
             z = z + 1
          Endif
        Else
          z -= 1
        Endif
      
        If z = -1 Then
          z = 0
          a = 1
        Endif
      Wend
      strDatensatzNetzTrasse[3, i] = strDatensatzRohre[1, z]
    Else
      If strDatensatzNetzTrasse[36, i] = "0" Then strDatensatzNetzTrasse[3, i] = "0"
    Endif
  Next
  
  If Global.booMehrleiter = True Then
    For i = 0 To intZeilenNetzTrasse - 1
      If strDatensatzNetzTrasse[4, i] <> "0" And strDatensatzNetzTrasse[36, i] = "0" Then
        'größter Rohrdurchmesser
        z = intZeilenRohre - 1
        a = 0
        While a = 0
          di = CFloat(strDatensatzRohre[1, z])
          'funDruckverlust(RHO AS Float, k AS Float, alpha AS Float, ms AS Float, l AS Float, di AS Float)
          dp = funDruckverlust(1000, Global.k, 0.3, CFloat(strDatensatzNetzTrasse[15, i]), CFloat(strDatensatzNetzTrasse[2, i]), di)
          If dp > Global.fltMaxDP * CFloat(strDatensatzNetzTrasse[2, i]) / 100000 Then
            a = 1
            z = z + 1
          Else
            z -= 1
          Endif
      
          If z = -1 Then
            z = 0
            a = 1
          Endif
        Wend
        strDatensatzNetzTrasse[14, i] = strDatensatzRohre[1, z]
      Endif
    Next

    For i = 0 To intZeilenNetzTrasse - 1
      If strDatensatzNetzTrasse[4, i] <> "0" And strDatensatzNetzTrasse[36, i] = "0" Then
        'größter Rohrdurchmesser
        z = intZeilenRohre - 1
        a = 0
        While a = 0
          di = CFloat(strDatensatzRohre[1, z])
          'funDruckverlust(RHO AS Float, k AS Float, alpha AS Float, ms AS Float, l AS Float, di AS Float)
          dp = funDruckverlust(1000, Global.k, 0.3, CFloat(strDatensatzNetzTrasse[26, i]), CFloat(strDatensatzNetzTrasse[2, i]), di)
          If dp > Global.fltMaxDP * CFloat(strDatensatzNetzTrasse[2, i]) / 100000 Then
            a = 1
            z = z + 1
          Else
            z -= 1
          Endif
      
          If z = -1 Then
            z = 0
            a = 1
          Endif
        Wend
        strDatensatzNetzTrasse[25, i] = strDatensatzRohre[1, z]
      Endif
    Next
  Else
    For i = 0 To intZeilenNetzTrasse - 1
      If strDatensatzNetzTrasse[36, i] = "0" Then strDatensatzNetzTrasse[14, i] = "0"
      If strDatensatzNetzTrasse[36, i] = "0" Then strDatensatzNetzTrasse[25, i] = "0"
    Next
  Endif
     
'------------------Dimensionierung ENDE-----------------------------------------------



'-------Schreibe Dateien zurück----------------  
  'Schreibe NetzTrasse.MIF
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MIF" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  strZeile = "Version 300"
  Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  strZeile = "Charset " & Chr$(34) & "WindowsLatin1" & Chr$(34)
  Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  strZeile = "Columns " & CStr(Global.conSpaltenTrasse)
  Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  
  For i = 3 To intZeilenNetzTrasseMIF - 1 'intZeilenNetzTrasseMIF
    strZeile = strDatensatzNetzTrasseMIF[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  
  'Schreibe NetzTrasse.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenNetzTrasse - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenTrasse - 2
      strZeile &= strDatensatzNetzTrasse[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzNetzTrasse[Global.conSpaltenTrasse - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  
  'Schreibe Punkte.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenPunkte - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenPunkte - 2
      strZeile &= strDatensatzPunkte[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzPunkte[Global.conSpaltenPunkte - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
'-------Schreibe Dateien zurück ENDE----------------
End



Public Sub leseDWD()
  Dim hsDatei As Stream
  Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
  Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
  Dim strDatensatzDWD As New String[400000]
  Dim fltHeizGradTage As New Float[300]
  Dim intZeilenzahlDWD As Integer
  Dim intJahr, intTag As Integer
  Dim b, i As Integer
  Dim booStart As Boolean
  
     
  b = 0
  hsDatei = Open Global.strPfadKlimadateiDWD For Input 'öffnen der DWD Klimadatei
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzDWD[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenzahlDWD = b
  Close #hsDatei  'schließe Datei DWD Klimadatei
  booStart = False
  
  intJahr = 0
  intTag = 0
  For i = 0 To intZeilenzahlDWD - 1
    strGesplittet = Split(strDatensatzDWD[i], ";") 
    If i > 0 Then
      
      If Mid$(strGesplittet[1], 5, 4) = "0101" Then 
              
        If booStart = True Then 
          If intTag = Global.fltTagesMittelTemperatur[0, intJahr, 0] Then 'wenn das vorige Jahr nicht weniger als 365 bzw 366 Tage hatte
            intJahr += 1
            intTag = 0
          Else
            intTag = 0
          Endif
        Endif      
        
        booStart = True
        
        
        If funSchaltjahr(CInt(Mid$(strGesplittet[1], 1, 4))) Then
          Global.fltTagesMittelTemperatur[0, intJahr, intTag] = 366
          Global.fltTagesMittelTemperatur[1, intJahr, intTag] = 0
          Global.fltTagesMittelTemperatur[2, intJahr, intTag] = 0
          Global.fltTagesMittelTemperatur[3, intJahr, intTag] = 0
          Global.fltTagesMittelTemperatur[4, intJahr, intTag] = 0
          Global.fltTagesMittelTemperatur[5, intJahr, intTag] = 0
          intTag += 1
        Else
          Global.fltTagesMittelTemperatur[0, intJahr, intTag] = 365
          Global.fltTagesMittelTemperatur[1, intJahr, intTag] = 0
          Global.fltTagesMittelTemperatur[2, intJahr, intTag] = 0
          Global.fltTagesMittelTemperatur[3, intJahr, intTag] = 0
          Global.fltTagesMittelTemperatur[4, intJahr, intTag] = 0
          Global.fltTagesMittelTemperatur[5, intJahr, intTag] = 0
          intTag += 1
        Endif
      Else
        If booStart = True Then intTag += 1
      Endif               
      
      If intTag < 367 Then
        Global.fltTagesMittelTemperatur[0, intJahr, intTag] = CFloat(strGesplittet[13])
        Global.fltTagesMittelTemperatur[1, intJahr, intTag] = CFloat(Mid$(strGesplittet[1], 7, 2))
        Global.fltTagesMittelTemperatur[2, intJahr, intTag] = CFloat(Mid$(strGesplittet[1], 5, 2))
        Global.fltTagesMittelTemperatur[3, intJahr, intTag] = CFloat(Mid$(strGesplittet[1], 1, 2))
        Global.fltTagesMittelTemperatur[4, intJahr, intTag] = CFloat(Mid$(strGesplittet[1], 3, 2))
               
      Endif
    Endif
  Next
  
  
  'wenn das letzte Jahr vollständig in der DWD Datei enthalten ist
  If intTag = Global.fltTagesMittelTemperatur[0, intJahr, 0] Then
    Global.intKlimadatenJahre = intJahr + 1
  Else
    Global.intKlimadatenJahre = intJahr
  Endif
  
  'Berechnung Heizgradtage
  For intJahr = 0 To Global.intKlimadatenJahre - 1
    fltHeizGradTage[intJahr] = 0
    For intTag = 1 To CInt(Global.fltTagesMittelTemperatur[0, intJahr, 0])
      If Global.fltTagesMittelTemperatur[0, IntJahr, intTag] < Global.conHeizGrenzTemperatur Then
        Global.fltTagesMittelTemperatur[5, intJahr, intTag] = (Global.conHeizGrenzTemperatur - Global.fltTagesMittelTemperatur[0, intJahr, intTag])
        Global.fltTagesMittelTemperatur[5, intJahr, 0] += (Global.conHeizGrenzTemperatur - Global.fltTagesMittelTemperatur[0, intJahr, intTag])
      Endif
    Next
  Next
End


Public Sub leseDWDKW()
  Dim hsDatei As Stream
  Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
  Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
  Dim strDatensatzDWD As New String[400000]
  Dim fltHeizGradTage As New Float[300]
  Dim intZeilenzahlDWD As Integer
  Dim intJahr, intTag As Integer
  Dim b, i As Integer
  Dim booStart As Boolean
    
  b = 0
  hsDatei = Open Global.strPfadKlimadateiDWDKW For Input 'öffnen der DWD Klimadatei KW
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzDWD[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenzahlDWD = b
  Close #hsDatei  'schließe Datei DWD Klimadatei
  booStart = False
  
  intJahr = 0
  intTag = 0
  For i = 0 To intZeilenzahlDWD - 1
    strGesplittet = Split(strDatensatzDWD[i], ";") 
    If i > 0 Then
      If Mid$(strGesplittet[1], 5, 4) = "0101" Then
               
        If booStart = True Then 
          If intTag = Global.fltTagesMittelTemperaturKW[0, intJahr, 0] Then 'wenn das vorige Jahr weniger als 365 bzw 366 Tage hatte
            intJahr += 1
            intTag = 0
          Else
            intTag = 0
          Endif
        Endif      
        
        booStart = True
        
        
        If funSchaltjahr(CInt(Mid$(strGesplittet[1], 1, 4))) Then
          Global.fltTagesMittelTemperaturKW[0, intJahr, intTag] = 366
          Global.fltTagesMittelTemperaturKW[1, intJahr, intTag] = 0
          Global.fltTagesMittelTemperaturKW[2, intJahr, intTag] = 0
          Global.fltTagesMittelTemperaturKW[3, intJahr, intTag] = 0
          Global.fltTagesMittelTemperaturKW[4, intJahr, intTag] = 0
          Global.fltTagesMittelTemperaturKW[5, intJahr, intTag] = 0
          intTag += 1
        Else
          Global.fltTagesMittelTemperaturKW[0, intJahr, intTag] = 365
          Global.fltTagesMittelTemperaturKW[1, intJahr, intTag] = 0
          Global.fltTagesMittelTemperaturKW[2, intJahr, intTag] = 0
          Global.fltTagesMittelTemperaturKW[3, intJahr, intTag] = 0
          Global.fltTagesMittelTemperaturKW[4, intJahr, intTag] = 0
          Global.fltTagesMittelTemperaturKW[5, intJahr, intTag] = 0
          intTag += 1
        Endif
      Else
        If booStart = True Then intTag += 1
      Endif
      
      If intTag < 367 Then
        Global.fltTagesMittelTemperaturKW[0, intJahr, intTag] = CFloat(strGesplittet[13])
        Global.fltTagesMittelTemperaturKW[1, intJahr, intTag] = CFloat(Mid$(strGesplittet[1], 7, 2))
        Global.fltTagesMittelTemperaturKW[2, intJahr, intTag] = CFloat(Mid$(strGesplittet[1], 5, 2))
        Global.fltTagesMittelTemperaturKW[3, intJahr, intTag] = CFloat(Mid$(strGesplittet[1], 1, 2))
        Global.fltTagesMittelTemperaturKW[4, intJahr, intTag] = CFloat(Mid$(strGesplittet[1], 3, 2))
      Endif
    Endif
  Next
  
  'wenn das letzte Jahr vollständig in der DWD Datei enthalten ist
  If intTag = Global.fltTagesMittelTemperaturKW[0, intJahr, 0] Then
    Global.intKlimadatenJahreKW = intJahr + 1
  Else
    Global.intKlimadatenJahreKW = intJahr
  Endif
  
  'Berechnung Heizgradtage
  For intJahr = 0 To Global.intKlimadatenJahreKW - 1
    fltHeizGradTage[intJahr] = 0
    For intTag = 1 To CInt(Global.fltTagesMittelTemperaturKW[0, intJahr, 0])
      If Global.fltTagesMittelTemperaturKW[0, IntJahr, intTag] < Global.conHeizGrenzTemperatur Then
        Global.fltTagesMittelTemperaturKW[5, intJahr, intTag] = (Global.conHeizGrenzTemperatur - Global.fltTagesMittelTemperaturKW[0, intJahr, intTag])
        Global.fltTagesMittelTemperaturKW[5, intJahr, 0] += (Global.conHeizGrenzTemperatur - Global.fltTagesMittelTemperaturKW[0, intJahr, intTag])
      Endif
    Next
  Next
End



Public Sub schreibeDWD()
Dim a As Integer
Dim intTag As Integer
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim fltTemperaturMinTemp As Float
Dim fltTemperaturSumme As Float
Dim fltTemperaturMaxTemp As Float 
 
  fltTemperaturSumme = 0
  fltTemperaturMaxTemp = -9999
  fltTemperaturMinTemp = 9999 
 

 'Schreibe rfKlimaDWD.csv
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameKlimaTag & ".csv" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For intTag = 0 To CInt(Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, 0])  'Schleife über alle Tage
    If funLuftTemptoErdTemp(Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, intTag]) < fltTemperaturMinTemp Then 
      fltTemperaturMinTemp = funLuftTemptoErdTemp(Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, intTag])
    Endif
        
    If funLuftTemptoErdTemp(Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, intTag]) > fltTemperaturMaxTemp And Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, intTag] < 300 Then 
      fltTemperaturMaxTemp = funLuftTemptoErdTemp(Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, intTag])
    Endif
        
    fltTemperaturSumme = fltTemperaturSumme + funLuftTemptoErdTemp(Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, intTag])
  Next
  
  
  For intTag = 0 To CInt(Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, 0])  'Schleife über alle Tage
    strZeile = ""
    If intTag = 0 Then
      strZeile &= CStr(Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, intTag]) & Chr$(9)
      strZeile &= CStr(Global.fltTagesMittelTemperatur[1, Global.intKlimadatenAuswahlJahr, intTag]) & Chr$(9)
      strZeile &= CStr(Round(fltTemperaturMinTemp, -2)) & Chr$(9)
      strZeile &= CStr(Round(fltTemperaturSumme / Global.fltTagesMittelTemperatur[0, Global.intKlimadatenAuswahlJahr, 0], -2)) & Chr$(9)
      strZeile &= CStr(Round(fltTemperaturMaxTemp, -2))
    
    Else
      For a = 0 To 3
        strZeile &= CStr(Global.fltTagesMittelTemperatur[a, Global.intKlimadatenAuswahlJahr, intTag]) & Chr$(9)
      Next
      strZeile &= CStr(Global.fltTagesMittelTemperatur[4, Global.intKlimadatenAuswahlJahr, intTag])
    Endif
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
'-------Schreibe Dateien zurück ENDE--------------   
End


Public Sub schreibeDWDKW()
Dim a As Integer
Dim intTag As Integer
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
 
 'Schreibe rfKlimaDWD.csv
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameKlimaTagKW & ".csv" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For intTag = 0 To CInt(Global.fltTagesMittelTemperaturKW[0, Global.intKlimadatenAuswahlJahrKW, 0])  'Schleife über alle Tage
    strZeile = ""
    For a = 0 To 3
      strZeile &= CStr(Global.fltTagesMittelTemperaturKW[a, Global.intKlimadatenAuswahlJahrKW, intTag]) & Chr$(9)
    Next
      strZeile &= CStr(Global.fltTagesMittelTemperaturKW[4, Global.intKlimadatenAuswahlJahrKW, intTag])
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
'-------Schreibe Dateien zurück ENDE--------------   
End



Public Sub lese_Lastprofile(strDateiname As String)
  Dim hsDatei As Stream
  Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
  Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
  Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
  Dim strDatensatzLastprofil As New String[2000]
  Dim strTemp As New String[100]
  Dim intZeilenLastprofil As Integer
  Dim b, i, j, k, l As Integer

  'Lese Datei Lastprofil.csv  
  b = 0
  hsDatei = Open strDateiname For Input 'öffnen das Lastprofil
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strDatensatzLastprofil[b] = Replace$(strZeile, "\r", "")
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenLastprofil = b
  Close #hsDatei  'schließe Datei NetzTrasse.MIF

  'Belege globale Variable LastprofilAusprägung[x,y,z]
  For i = 0 To intZeilenLastprofil - 1
    Select Case i Mod 88 'wenn i/ 88 Rest 0 dann
      Case 0
        For k = 0 To 4
          b = 0
          strGesplittet = Split(strDatensatzLastprofil[i + 2 + k], Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
          For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
            strTemp[b] = Replace$(strElement, "\r", "")
            b += 1
          Next
          For j = 0 To 7
            Global.fltLastprofileAuspraegung[(i / 88), 4 - k, j] = CFloat(strTemp[j + 1])
          Next
        Next
    End Select
  Next
  
  'Belege globale Variable LastprofilWTFaktor[x,y]
  For i = 0 To intZeilenLastprofil - 1
    Select Case i Mod 88 'wenn i/ 88 Rest 0 dann
      Case 0
        b = 0
        strGesplittet = Split(strDatensatzLastprofil[i + 8], Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
        For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
          strTemp[b] = Replace$(strElement, "\r", "")
          b += 1
        Next
        For j = 0 To 6
          Global.fltLastprofileWTFaktor[(i / 88), j] = CFloat(strTemp[j + 1])
        Next
    End Select
  Next
  
  'Belege globale Variable LastprofilhVerteilung[x,y,z,d] x:Profil; y:Tag Mo-So; z:Temperaturzeile; d: Stunde 1-24
  For i = 0 To intZeilenLastprofil - 1
    Select Case i Mod 88 'wenn i/ 88 Rest 0 dann
      Case 0
        For l = 0 To 6
          For k = 0 To 9
            b = 0
            strGesplittet = Split(strDatensatzLastprofil[i + 12 + k + l * 11], Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
            For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
              strTemp[b] = Replace$(strElement, "\r", "")
              b += 1
            Next
            For j = 0 To 23
              Global.fltLastprofilehVerteilung[(i / 88), l, k, j] = CFloat(strTemp[j + 1])
            Next
          Next
        Next
    End Select
  Next
End



Public Sub berechne_KW()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim strDatensatzPunkte As New String[Global.conSpaltenPunkte, Global.conMaxDatensaetze]
Dim fltKW, fltFD, fltTemp As Float
Dim fltSumme_hVFD As Float
Dim intGebLP, intAuspraegung, intWT As Integer
Dim intZeilenPunkte As Integer
Dim fltA, fltB, fltC, fltD, fltmH, fltbH, fltmW, fltbW As Float
Dim a, b, i, j As Integer

 
  
'--------------------Dateien einlesen---------------------------------------------------     
  'Punkte
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Input 'öffnen der Datei Punkte.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzPunkte[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenPunkte = b
  Close #hsDatei  'schließe Datei Punkte.MID


'--------------------Dateien einlesen ENDE---------------------------------------------------     

  'Schleife über alle Punkte
  For i = 0 To intZeilenPunkte - 1
    'wenn Abnehmer (QJahr>0) dann
    If CFloat(strDatensatzPunkte[20, i]) > 0 Then
      'Nullsetzen des Summenwertes h(V)*F(D)
      fltSumme_hVFD = 0
      'Schleife über Klimadatei der Tagesmittelwerte
      For j = 1 To CInt(Global.strDatensatzKlimaTagKW[0, 0]) - 1
        'suche Lastprofil und ermittle FD[j]
        Select Case strDatensatzPunkte[16, i]
          Case "EFH"
            intGebLP = 0
            intAuspraegung = 2
          Case "DHH"
            intGebLP = 0
            intAuspraegung = 2
          Case "RH"
            intGebLP = 0
            intAuspraegung = 2
          Case "MFH"
            intGebLP = 1
            intAuspraegung = 2
          Case "MFH2"
            intGebLP = 1
            intAuspraegung = 2
          Case "HEF"
            intGebLP = 0
            intAuspraegung = 2
          Case "HMF"
            intGebLP = 1
            intAuspraegung = 2
          Case "GKO"
            intGebLP = 2
            intAuspraegung = 2
          Case "GHA"
            intGebLP = 3
            intAuspraegung = 2
          Case "GMK"
            intGebLP = 4
            intAuspraegung = 2
          Case "GBD"
            intGebLP = 5
            intAuspraegung = 2
          Case "GGA"
            intGebLP = 6
            intAuspraegung = 2
          Case "GBH"
            intGebLP = 7
            intAuspraegung = 2
          Case "GBA"
            intGebLP = 8
            intAuspraegung = 2
          Case "GWA"
            intGebLP = 9
            intAuspraegung = 2
          Case "GGB"
            intGebLP = 10
            intAuspraegung = 2
          Case "GPD"
            intGebLP = 11
            intAuspraegung = 2
          Case "GMF"
            intGebLP = 12
            intAuspraegung = 2
          Case "GHD"
            intGebLP = 13
            intAuspraegung = 2
          Case "HEF33"
            intGebLP = 0
            intAuspraegung = 2
          Case "HMF33"
            intGebLP = 1
            intAuspraegung = 2
          Case "GKO33"
            intGebLP = 2
            intAuspraegung = 2
          Case "GHA33"
            intGebLP = 3
            intAuspraegung = 2
          Case "GMK33"
            intGebLP = 4
            intAuspraegung = 2
          Case "GBD33"
            intGebLP = 5
            intAuspraegung = 2
          Case "GGA33"
            intGebLP = 6
            intAuspraegung = 2
          Case "GBH33"
            intGebLP = 7
            intAuspraegung = 2
          Case "GBA33"
            intGebLP = 8
            intAuspraegung = 2
          Case "GWA33"
            intGebLP = 9
            intAuspraegung = 2
          Case "GGB33"
            intGebLP = 10
            intAuspraegung = 2
          Case "GPD33"
            intGebLP = 11
            intAuspraegung = 2
          Case "GMF33"
            intGebLP = 12
            intAuspraegung = 2
          Case "GHD33"
            intGebLP = 13
            intAuspraegung = 2
          Case "HEF34"
            intGebLP = 0
            intAuspraegung = 3
          Case "HMF34"
            intGebLP = 1
            intAuspraegung = 3
          Case "GKO34"
            intGebLP = 2
            intAuspraegung = 3
          Case "GHA34"
            intGebLP = 3
            intAuspraegung = 3
          Case "GMK34"
            intGebLP = 4
            intAuspraegung = 3
          Case "GBD34"
            intGebLP = 5
            intAuspraegung = 3
          Case "GGA34"
            intGebLP = 6
            intAuspraegung = 3
          Case "GBH34"
            intGebLP = 7
            intAuspraegung = 3
          Case "GBA34"
            intGebLP = 8
            intAuspraegung = 3
          Case "GWA34"
            intGebLP = 9
            intAuspraegung = 3
          Case "GGB34"
            intGebLP = 10
            intAuspraegung = 3
          Case "GPD34"
            intGebLP = 11
            intAuspraegung = 3
          Case "GMF34"
            intGebLP = 12
            intAuspraegung = 3
          Case "GHD34"
            intGebLP = 13
            intAuspraegung = 3
          Case Else
            intGebLP = 1
            intAuspraegung = 2
        End Select
        
        fltA = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 0]
        fltB = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 1]
        fltC = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 2]
        fltD = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 3]
        fltmH = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 4]
        fltbH = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 5]
        fltmW = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 6]
        fltbW = Global.fltLastprofileAuspraegung[intGebLP, intAuspraegung, 7]
                
        fltTemp = Global.strDatensatzKlimaTagKW[0, j]
        intWT = funGaussWT(CInt(Global.strDatensatzKlimaTagKW[1, j]), CInt(Global.strDatensatzKlimaTagKW[2, j]), CInt(Global.strDatensatzKlimaTagKW[3, j]), CInt(Global.strDatensatzKlimaTagKW[4, j]))
        fltFD = Global.fltLastprofileWTFaktor[intGebLP, intWT - 1] '[Profil, Wochentag]
        
        fltSumme_hVFD += funSigmoid(fltA, fltB, fltC, fltD, fltmH, fltbH, fltmW, fltbW, fltTemp, 40) * fltFD
      Next
      fltKW = CFloat(strDatensatzPunkte[20, i]) / fltSumme_hVFD
      strDatensatzPunkte[21, i] = CStr(fltKW)
    Endif
  Next
  
  
  'Schreibe Punkte.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenPunkte - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenPunkte - 2
      strZeile &= strDatensatzPunkte[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzPunkte[Global.conSpaltenPunkte - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
End






Public Sub Anschlussgrad_anlegen(intAnschlussgrad As Integer)
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim strDatensatzPunkte As New String[Global.conSpaltenPunkte, Global.conMaxDatensaetze]
Dim intZeilenPunkte As Integer
Dim a, b, i, j, k, z As Integer
Dim intAUS As Integer
Dim intEIN As Integer
   
'--------------------Dateien einlesen---------------------------------------------------     
  'Punkte
  a = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Input 'öffnen der Datei Punkte.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzPunkte[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenPunkte = b
  Close #hsDatei  'schließe Datei Punkte.MID
  
  For k = 1 To 1000
    intEIN = 0
    intAUS = 0
  
    For i = 0 To intZeilenPunkte - 1
      'wenn QJahr > 0 (Abnehmer)
      If CFloat(strDatensatzPunkte[20, i]) > 0 Then
        'Zufallszahl bestimmen zwischen 1 und 100
        If intAnschlussgrad < 100 Then
          z = Int(Rnd(0, 100))
        Else 
          z = 100
        Endif
        
        'ist diese kleiner gleich dem Anschlussgrad, dann setzte die Spalte 39 auf 1 (damit wird der Abnehmer aktiv)
        If z <= intAnschlussgrad Then
          strDatensatzPunkte[39, i] = "1"
          intEIN += 1
       Else
         strDatensatzPunkte[39, i] = "0"
         intAUS += 1
        Endif
      Endif
    Next
    If (intEIN / (intEIN + intAUS)) > (intAnschlussgrad - 1) / 100 And (intEIN / (intEIN + intAUS)) < (intAnschlussgrad + 1) / 100 Then Goto ENDE1
  Next
ENDE1:
  
  'Schreibe Punkte.MID
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilenPunkte - 1  'Schleife über die Bauteile
    strZeile = ""
    For j = 0 To Global.conSpaltenPunkte - 2
      strZeile &= strDatensatzPunkte[j, i] & Chr$(9)
    Next
    strZeile &= strDatensatzPunkte[Global.conSpaltenPunkte - 1, i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  
  Programmcode.loesche_DateiLeerzeilen(Global.strtxbPfad & Global.conDateiNamePunkte & ".MID")
End



Public Sub loesche_DateiLeerzeilen(strDatei As String)
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim strDatensatz As New String[Global.conMaxDatensaetze, Global.conMaxDatensaetze]
Dim intZeilen, intSpalten As Integer
Dim a, b, i, j As Integer

  a = 0
  b = 0
  hsDatei = Open strDatei For Input 'öffnen der Datei Punkte.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatz[a, b] = Replace$(strElement, "\r", "")
      a = a + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    intSpalten = a
    a = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilen = b
  Close #hsDatei  'schließe Datei Punkte.MID
   
  
  'Schreibe Punkte.MID
  hsDatei = Open strDatei For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
  
  For i = 0 To intZeilen - 1  'Schleife über die Bauteile
    strZeile = ""
    If strDatensatz[0, i] <> "" Then
      For j = 0 To intSpalten - 2
        strZeile &= strDatensatz[j, i] & Chr$(9)
      Next
      strZeile &= strDatensatz[intSpalten - 1, i]
      Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
    Endif
  Next
  Close #hsDatei   'Schließe die Datei
End


Public Sub Erzeuge_Jahresdauerlinie()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strDatensatzJDL As New String[10000]
Dim fltDatensatzJDL_IN As New Float[9000]
Dim fltDatensatzJDL_OUT As New Float[9000]
Dim fltDatensatzJDL_Verlust As New Float[9000]
Dim c, i As Integer
Dim fltTemp As Float
Dim intStundenImJahr As Integer
  
  If Global.strDatensatzKlimaTag[0, 0] = "366" Then
    intStundenImJahr = 8784
  Else
    intStundenImJahr = 8760
  Endif

  For i = 0 To intStundenImJahr - 1
    fltDatensatzJDL_IN[i] = CFloat(Global.strDatensatzSimErgebnis[22, i])
    fltDatensatzJDL_OUT[i] = CFloat(Global.strDatensatzSimErgebnis[23, i])
    fltDatensatzJDL_Verlust[i] = CFloat(Global.strDatensatzSimErgebnis[24, i])
  Next
  
  'sortiere die Eingespeiste Energie
  Repeat
    c = 0
    For i = 0 To intStundenImJahr - 1
      If fltDatensatzJDL_IN[i] < fltDatensatzJDL_IN[i + 1] Then
        fltTemp = fltDatensatzJDL_IN[i]
        fltDatensatzJDL_IN[i] = fltDatensatzJDL_IN[i + 1]
        fltDatensatzJDL_IN[i + 1] = fltTemp
        
        fltTemp = fltDatensatzJDL_OUT[i]
        fltDatensatzJDL_OUT[i] = fltDatensatzJDL_OUT[i + 1]
        fltDatensatzJDL_OUT[i + 1] = fltTemp
        
        fltTemp = fltDatensatzJDL_Verlust[i]
        fltDatensatzJDL_Verlust[i] = fltDatensatzJDL_Verlust[i + 1]
        fltDatensatzJDL_Verlust[i + 1] = fltTemp
        c = 1
      Endif
    Next
  Until c = 0
  
  'sortiere die Verkaufte Energie
'  REPEAT 
'    c = 0
'    FOR i = 0 TO intStundenImJahr - 1 
'      IF fltDatensatzJDL_OUT[i] < fltDatensatzJDL_OUT[i + 1] THEN 
'        fltTemp = fltDatensatzJDL_OUT[i] 
'        fltDatensatzJDL_OUT[i] = fltDatensatzJDL_OUT[i + 1]
'        fltDatensatzJDL_OUT[i + 1] = fltTemp 
'        c = 1
'      ENDIF 
'    NEXT 
'  UNTIL c = 0   
  
  'sortiere die Wärmeverluste
'  REPEAT 
'    c = 0
'    FOR i = 0 TO intStundenImJahr - 1
'      IF fltDatensatzJDL_Verlust[i] < fltDatensatzJDL_Verlust[i + 1] THEN 
'        fltTemp = fltDatensatzJDL_Verlust[i] 
'        fltDatensatzJDL_Verlust[i] = fltDatensatzJDL_Verlust[i + 1]
'        fltDatensatzJDL_Verlust[i + 1] = fltTemp 
'        c = 1
'      ENDIF 
'    NEXT 
'  UNTIL c = 0   
  
  strDatensatzJDL[0] = "<?xml version = " & Chr(34) & "1.0" & Chr(34) & "?> "
  strDatensatzJDL[1] = "<!DOCTYPE svg PUBLIC " & Chr(34) & "-//W3C//DTD SVG 1.1//EN" & Chr(34)
  strDatensatzJDL[2] = "  " & Chr(34) & "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" & Chr(34) & ">"
  strDatensatzJDL[3] = "<svg version=" & Chr(34) & "1.1" & Chr(34) & " xmlns=" & Chr(34) & "http://www.w3.org/2000/svg" & Chr(34) & ">"
  
  strDatensatzJDL[4] = "  <polyline points=" & Chr(34) & "0,-600,0,0,438,0" & Chr(34)
  strDatensatzJDL[5] = "       style=" & Chr(34) & "stroke:black;stroke-width:3;fill:none" & Chr(34) & " />"
  For i = 6 To 26
    Select Case i
      Case (0 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:3;" & Chr(34) & " />"
      Case (5 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:2;" & Chr(34) & " />"
      Case (10 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:3;" & Chr(34) & " />"
      Case (15 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:2;" & Chr(34) & " />"
      Case (20 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:3;" & Chr(34) & " />"
      Case Else
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:1;" & Chr(34) & " />"
    End Select
  Next
     
  'Eingespeiste Energie
  strDatensatzJDL[27] = "  <polyline points=" & Chr(34)
  For i = 0 To intStundenImJahr - 1
    strDatensatzJDL[27] &= CStr(i / 20)
    strDatensatzJDL[27] &= ","
    strDatensatzJDL[27] &= CStr((fltDatensatzJDL_IN[i] * -6 / 20) + 1000)
    If i < intStundenImJahr - 1 Then strDatensatzJDL[27] &= ","
  Next
  strDatensatzJDL[27] &= Chr(34)
  strDatensatzJDL[28] = "       style=" & Chr(34) & "stroke:#a3ad00;stroke-width:5;fill:none" & Chr(34) & " />"

    
  'Verluste
  strDatensatzJDL[29] = "  <polyline points=" & Chr(34)
  For i = 0 To intStundenImJahr - 1
    strDatensatzJDL[29] &= CStr(i / 20)
    strDatensatzJDL[29] &= ","
    strDatensatzJDL[29] &= CStr((fltDatensatzJDL_Verlust[i] * -6 / 20) + 1000)
    If i < intStundenImJahr - 1 Then strDatensatzJDL[29] &= ","
  Next
  strDatensatzJDL[29] &= Chr(34)
  strDatensatzJDL[30] = "       style=" & Chr(34) & "stroke: #e37222;stroke-width:5;fill:none" & Chr(34) & " />"

  
  'Verkaufte Energie
  strDatensatzJDL[31] = "  <polyline points=" & Chr(34)
  For i = 0 To intStundenImJahr - 1
    strDatensatzJDL[31] &= CStr(i / 20)
    strDatensatzJDL[31] &= ","
    strDatensatzJDL[31] &= CStr((fltDatensatzJDL_OUT[i] * -6 / 20) + 1000)
    If i < intStundenImJahr - 1 Then strDatensatzJDL[31] &= ","
  Next
  strDatensatzJDL[31] &= Chr(34)
  strDatensatzJDL[32] = "       style=" & Chr(34) & "stroke:#0073cf;stroke-width:5;fill:none" & Chr(34) & " />"

  strDatensatzJDL[33] = "</svg>"
  
  'Schreibe JDLTestdatei
  hsDatei = Open Global.strtxbPfad & "JDL.svg" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
    
  For i = 0 To 33
    strZeile = strDatensatzJDL[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  message("Jahresdauerlinie als JDL.svg gespeichert ")
End



Public Sub Erzeuge_Jahresdauerlinie_Zweileiter()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strDatensatzJDL As New String[10000]
Dim fltDatensatzJDL_IN As New Float[9000]
Dim fltDatensatzJDL_OUT As New Float[9000]
Dim fltDatensatzJDL_Verlust As New Float[9000]
Dim c, i As Integer
Dim fltTemp As Float
Dim intStundenImJahr As Integer
  
  If Global.strDatensatzKlimaTag[0, 0] = "366" Then
    intStundenImJahr = 8784
  Else
    intStundenImJahr = 8760
  Endif

  For i = 0 To intStundenImJahr - 1
    fltDatensatzJDL_IN[i] = CFloat(Global.strDatensatzSimErgebnis[32, i]) + CFloat(Global.strDatensatzSimErgebnis[42, i])
    fltDatensatzJDL_OUT[i] = CFloat(Global.strDatensatzSimErgebnis[33, i]) + CFloat(Global.strDatensatzSimErgebnis[43, i])
    fltDatensatzJDL_Verlust[i] = CFloat(Global.strDatensatzSimErgebnis[24, i]) + CFloat(Global.strDatensatzSimErgebnis[44, i])
  Next
  
  'sortiere die Eingespeiste Energie
  Repeat
    c = 0
    For i = 0 To intStundenImJahr - 1
      If fltDatensatzJDL_IN[i] < fltDatensatzJDL_IN[i + 1] Then
        fltTemp = fltDatensatzJDL_IN[i]
        fltDatensatzJDL_IN[i] = fltDatensatzJDL_IN[i + 1]
        fltDatensatzJDL_IN[i + 1] = fltTemp
        
        fltTemp = fltDatensatzJDL_OUT[i]
        fltDatensatzJDL_OUT[i] = fltDatensatzJDL_OUT[i + 1]
        fltDatensatzJDL_OUT[i + 1] = fltTemp
        
        fltTemp = fltDatensatzJDL_Verlust[i]
        fltDatensatzJDL_Verlust[i] = fltDatensatzJDL_Verlust[i + 1]
        fltDatensatzJDL_Verlust[i + 1] = fltTemp
        c = 1
      Endif
    Next
  Until c = 0
  
  'sortiere die Verkaufte Energie
'  REPEAT 
'    c = 0
'    FOR i = 0 TO intStundenImJahr - 1 
'      IF fltDatensatzJDL_OUT[i] < fltDatensatzJDL_OUT[i + 1] THEN 
'        fltTemp = fltDatensatzJDL_OUT[i] 
'        fltDatensatzJDL_OUT[i] = fltDatensatzJDL_OUT[i + 1]
'        fltDatensatzJDL_OUT[i + 1] = fltTemp 
'        c = 1
'      ENDIF 
'    NEXT 
'  UNTIL c = 0   
  
  'sortiere die Wärmeverluste
'  REPEAT 
'    c = 0
'    FOR i = 0 TO intStundenImJahr - 1 
'      IF fltDatensatzJDL_Verlust[i] < fltDatensatzJDL_Verlust[i + 1] THEN 
'        fltTemp = fltDatensatzJDL_Verlust[i] 
'        fltDatensatzJDL_Verlust[i] = fltDatensatzJDL_Verlust[i + 1]
'        fltDatensatzJDL_Verlust[i + 1] = fltTemp 
'        c = 1
'      ENDIF 
'    NEXT 
'  UNTIL c = 0   
  
  strDatensatzJDL[0] = "<?xml version = " & Chr(34) & "1.0" & Chr(34) & "?> "
  strDatensatzJDL[1] = "<!DOCTYPE svg PUBLIC " & Chr(34) & "-//W3C//DTD SVG 1.1//EN" & Chr(34)
  strDatensatzJDL[2] = "  " & Chr(34) & "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" & Chr(34) & ">"
  strDatensatzJDL[3] = "<svg version=" & Chr(34) & "1.1" & Chr(34) & " xmlns=" & Chr(34) & "http://www.w3.org/2000/svg" & Chr(34) & ">"
  
  strDatensatzJDL[4] = "  <polyline points=" & Chr(34) & "0,-600,0,0,438,0" & Chr(34)
  strDatensatzJDL[5] = "       style=" & Chr(34) & "stroke:black;stroke-width:3;fill:none" & Chr(34) & " />"
  For i = 6 To 26
    Select Case i
      Case (0 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:3;" & Chr(34) & " />"
      Case (5 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:2;" & Chr(34) & " />"
      Case (10 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:3;" & Chr(34) & " />"
      Case (15 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:2;" & Chr(34) & " />"
      Case (20 + 6)
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:3;" & Chr(34) & " />"
      Case Else
        strDatensatzJDL[i] = "<line x1=" & Chr(34) & "-10" & Chr(34) & " y1=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " x2=" & Chr(34) & "438" & Chr(34) & " y2=" & Chr(34) & CStr(((i - 6) * 100 * -6 / 20) + 1000) & Chr(34) & " style=" & Chr(34) & "stroke:#585858;stroke-width:1;" & Chr(34) & " />"
    End Select
  Next
     
  'Eingespeiste Energie
  strDatensatzJDL[27] = "  <polyline points=" & Chr(34)
  For i = 0 To intStundenImJahr - 1
    strDatensatzJDL[27] &= CStr(i / 20)
    strDatensatzJDL[27] &= ","
    strDatensatzJDL[27] &= CStr((fltDatensatzJDL_IN[i] * -6 / 20) + 1000)
    If i < intStundenImJahr - 1 Then strDatensatzJDL[27] &= ","
  Next
  strDatensatzJDL[27] &= Chr(34)
  strDatensatzJDL[28] = "       style=" & Chr(34) & "stroke:#a3ad00;stroke-width:5;fill:none" & Chr(34) & " />"

    
  'Verluste
  strDatensatzJDL[29] = "  <polyline points=" & Chr(34)
  For i = 0 To intStundenImJahr - 1
    strDatensatzJDL[29] &= CStr(i / 20)
    strDatensatzJDL[29] &= ","
    strDatensatzJDL[29] &= CStr((fltDatensatzJDL_Verlust[i] * -6 / 20) + 1000)
    If i < intStundenImJahr - 1 Then strDatensatzJDL[29] &= ","
  Next
  strDatensatzJDL[29] &= Chr(34)
  strDatensatzJDL[30] = "       style=" & Chr(34) & "stroke: #e37222;stroke-width:5;fill:none" & Chr(34) & " />"

  
  'Verkaufte Energie
  strDatensatzJDL[31] = "  <polyline points=" & Chr(34)
  For i = 0 To intStundenImJahr - 1
    strDatensatzJDL[31] &= CStr(i / 20)
    strDatensatzJDL[31] &= ","
    strDatensatzJDL[31] &= CStr((fltDatensatzJDL_OUT[i] * -6 / 20) + 1000)
    If i < intStundenImJahr - 1 Then strDatensatzJDL[31] &= ","
  Next
  strDatensatzJDL[31] &= Chr(34)
  strDatensatzJDL[32] = "       style=" & Chr(34) & "stroke:#0073cf;stroke-width:5;fill:none" & Chr(34) & " />"

  strDatensatzJDL[33] = "</svg>"
  
  'Schreibe JDLTestdatei
  hsDatei = Open Global.strtxbPfad & "JDL2L.svg" For Output Create     'Öffne die Datei zum Schreiben
  hsDatei.EndOfLine = gb.Windows
    
  For i = 0 To 33
    strZeile = strDatensatzJDL[i]
    Print #hsDatei, Conv$(strZeile, "UTF-8", "ASCII")    'schreibe Zeile in Datei
  Next
  Close #hsDatei   'Schließe die Datei
  message("Jahresdauerlinie als JDL2L.svg gespeichert ")
End



Public Sub Wirtschaftlichkeitsberechnung()
Dim hsDatei As Stream
Dim strZeile As String          'Hier wird eine Zeile direkt aus der Datei eingelesen
Dim strElement As String        'Hier wird ein Element aus dem gesplitteten Variablenfeld abgelegt
Dim strGesplittet As String[]   'Dieses Datenfeld nimmt die gesplittete Zeile auf
Dim strDatensatzPunkte As New String[Global.conSpaltenPunkte, Global.conMaxDatensaetze]
Dim strDatensatzNetzTrasse As New String[Global.conSpaltenTrasse, Global.conMaxDatensaetze]
Dim intZeilenNetzTrasse, intZeilenPunkte, intNetzTrasseSpaltenzahl As Integer
Dim strDatensatzRohre As New String[12, Global.conMaxRohre]
Dim c, b, i, j As Integer
Dim QPumpel As Float
Dim QGL, QSPL, QGEL As Float

Dim f1, f2, f3, f4 As Integer
Dim a, q, rK, rB, T, PreisOUT, b_IN, baIN, b_B, baB, AWS, ASPL, ANE, baE, rE, b_E, AN As Float

Dim ANK As New Float[Global.conNAnlagen + 1]
Dim A0 As New Float[Global.conNAnlagen]
Dim A1 As New Float[Global.conNAnlagen]
Dim A2 As New Float[Global.conNAnlagen]
Dim A3 As New Float[Global.conNAnlagen]
Dim A4 As New Float[Global.conNAnlagen]
Dim RW As New Float[Global.conNAnlagen]
Dim rV As New Float[Global.conNAnlagen]
Dim fK As New Float[Global.conNAnlagen]
Dim PreisE As New Float[Global.conNAnlagen]
Dim AV1 As New Float[Global.conNAnlagen]
Dim ANV As New Float[Global.conNAnlagen + 1]
Dim TN As New Float[Global.conNAnlagen]
Dim n As New Integer[Global.conNAnlagen]
Dim baV As New Float[Global.conNAnlagen]
Dim b_V As New Float[Global.conNAnlagen]
Dim AB1 As New Float[Global.conNAnlagen]
Dim ANB As New Float[Global.conNAnlagen + 1]
Dim intStundenImJahr As Integer
  
  If Global.strDatensatzKlimaTag[0, 0] = "366" Then
    intStundenImJahr = 8784
  Else
    intStundenImJahr = 8760
  Endif
  
  c = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameNetzTrasse & ".MID" For Input 'öffnen der Datei NetzTrasse.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzNetzTrasse[c, b] = Replace$(strElement, "\r", "")
      c = c + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    intNetzTrasseSpaltenzahl = c
    c = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenNetzTrasse = b
  Close #hsDatei  'schließe Datei NetzTrasse.MID

  c = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNameBibRohre & ".csv" For Input 'öffnen der Datei Rohre.csv
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzRohre[c, b] = Replace$(strElement, "\r", "")
      c = c + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    c = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  Close #hsDatei  'schließe Datei Rohre.csv

  c = 0
  b = 0
  hsDatei = Open Global.strtxbPfad & Global.conDateiNamePunkte & ".MID" For Input 'öffnen der Datei Punkte.MID
  While Not Eof(hsDatei)
    Line Input #hsDatei, strZeile    'es wird die Zeile an der Position beginnend wo der Pointer steht eingelesen bis zum Zeilenumbruchzeichen
    strGesplittet = Split(strZeile, Chr$(9))    'es wird der gelesenen String (strZeile) in die durch "<TAB>" getrennten Unterstrings unterteilt und an das Stringfeld (strGesplittet) übergebe
    For Each strElement In strGesplittet    'Schleife über alle Elemente im Stringfeld (strGesplittet)
      strDatensatzPunkte[c, b] = Replace$(strElement, "\r", "")
      c = c + 1   'nächste Spalte
    Next    'nächstes Element in strGesplittet
    c = 0   'die Spaltennummer wird zurückgesetzt
    b = b + 1   'die Zeilennummer wird um 1 erhöht
  Wend
  intZeilenPunkte = b
  Close #hsDatei  'schließe Datei Punkte.MID


 QPumpel = 0
 '------------berechne Energiebedarfe-----------------------  
  For i = 0 To intStundenImJahr - 1
    QPumpel += CFloat(Global.strDatensatzSimErgebnis[21, i])
  Next
 
 
 
  '-------Lese Daten aus Eingabeblatt
  q = Global.fltZinssatzKapital + 1
  rK = Global.fltPreissteigerungAllg + 1
  rV[0] = Global.fltPreissteigerungAllg + 1
  rV[1] = Global.fltPreissteigerungStrom + 1
  rV[2] = Global.fltPreissteigerungSPL + 1
  rB = Global.fltPreissteigerungLohn + 1
  
  AWS = Global.fltInvestWS
  ASPL = Global.fltInvestSPL
  PreisE[0] = Global.fltEnergiepreisABW
  PreisE[1] = Global.fltStrompreis
  PreisE[2] = Global.fltEnergiepreisSPL
  T = Global.fltZeitraum
  PreisOUT = Global.fltVerkaufspreis
  
  
  TN[0] = Global.conLaufzeitNetz
  TN[1] = Global.conLaufzeitWS
  TN[2] = Global.conLaufzeitSPL
  
  'Annuitätsfaktor
  a = (q - 1) / (1 - (q ^ (-T)))
  
  'Barwertfaktor Instandhaltung
  If rK = q Then
    b_IN = T / q
  Else
    b_IN = ((1 - ((rK / q) ^ T)) / (q - rK))
  Endif
  baIN = b_IN * a
  
   
  '-------------Annuitäten Investition-------------------------------------------    
  '-Netz----4 Leiter a
  For j = 0 To Global.conMaxRohre - 1
    Global.fltRohrLaengeKosten_a[0, j] = 0
    Global.fltRohrLaengeKosten_a[1, j] = 0
    Global.fltRohrLaengeKosten_a[2, j] = 0
  Next
  
  If Global.intDaemmklasse = 0 Then Message("Keine Dämmklasse angegeben!")
  For i = 0 To intZeilenNetzTrasse - 1
    For j = 0 To Global.conMaxRohre - 1
      If CFloat(strDatensatzNetzTrasse[14, i]) = CFloat(strDatensatzRohre[1, j]) Then
        strDatensatzNetzTrasse[17, i] = CStr(CFloat(strDatensatzNetzTrasse[2, i]) * CFloat(strDatensatzRohre[7 + Global.intDaemmklasse, j]))
        'Durchmesser innen
        Global.fltRohrLaengeKosten_a[0, j] = CFloat(strDatensatzNetzTrasse[14, i])
        'Länge
        Global.fltRohrLaengeKosten_a[1, j] += CFloat(strDatensatzNetzTrasse[2, i])
        'Kosten
        Global.fltRohrLaengeKosten_a[2, j] += CFloat(strDatensatzNetzTrasse[17, i])
      Endif
    Next
  Next

  '-Netz----4 Leiter b
  For j = 0 To Global.conMaxRohre - 1
    Global.fltRohrLaengeKosten_b[0, j] = 0
    Global.fltRohrLaengeKosten_b[1, j] = 0
    Global.fltRohrLaengeKosten_b[2, j] = 0
  Next
  
  If Global.intDaemmklasse = 0 Then Message("Keine Dämmklasse angegeben!")
  For i = 0 To intZeilenNetzTrasse - 1
    For j = 0 To Global.conMaxRohre - 1
      If CFloat(strDatensatzNetzTrasse[25, i]) = CFloat(strDatensatzRohre[1, j]) Then
        strDatensatzNetzTrasse[28, i] = CStr(CFloat(strDatensatzNetzTrasse[2, i]) * (CFloat(strDatensatzRohre[7 + Global.intDaemmklasse, j]) - CFloat(strDatensatzRohre[11, j])))
        'Durchmesser innen
        Global.fltRohrLaengeKosten_b[0, j] = CFloat(strDatensatzNetzTrasse[25, i])
        'Länge
        Global.fltRohrLaengeKosten_b[1, j] += CFloat(strDatensatzNetzTrasse[2, i])
        'Kosten
        Global.fltRohrLaengeKosten_b[2, j] += CFloat(strDatensatzNetzTrasse[28, i])
      Endif
    Next
  Next
  
  '-Netz----2 Leiter
  For j = 0 To Global.conMaxRohre - 1
    Global.fltRohrLaengeKosten[0, j] = 0
    Global.fltRohrLaengeKosten[1, j] = 0
    Global.fltRohrLaengeKosten[2, j] = 0
  Next
  
  If Global.intDaemmklasse = 0 Then Message("Keine Dämmklasse angegeben!")
  For i = 0 To intZeilenNetzTrasse - 1
    For j = 0 To Global.conMaxRohre - 1
      If CFloat(strDatensatzNetzTrasse[3, i]) = CFloat(strDatensatzRohre[1, j]) Then
        strDatensatzNetzTrasse[6, i] = CStr(CFloat(strDatensatzNetzTrasse[2, i]) * CFloat(strDatensatzRohre[7 + Global.intDaemmklasse, j]))
        'Durchmesser innen
        Global.fltRohrLaengeKosten[0, j] = CFloat(strDatensatzNetzTrasse[3, i])
        'Länge
        Global.fltRohrLaengeKosten[1, j] += CFloat(strDatensatzNetzTrasse[2, i])
        'Kosten
        Global.fltRohrLaengeKosten[2, j] += CFloat(strDatensatzNetzTrasse[6, i])
      Endif
    Next
  Next
  
   
  A0[0] = 0
  For i = 0 To Global.conMaxRohre - 1
    A0[0] += Global.fltRohrLaengeKosten[2, i]
  Next
  Global.fltInvestNetz = A0[0]
   
  'Zahl der Ersatzbeschaffungen
  n[0] = Int(T / TN[0])

  '1. Ersatzbeschaffung
  A1[0] = A0[0] * ((rK ^ (1 * TN[0])) / (q ^ (1 * TN[0])))
  '2. Ersatzbeschaffung
  A2[0] = A0[0] * ((rK ^ (2 * TN[0])) / (q ^ (2 * TN[0])))
  '3. Ersatzbeschaffung
  A3[0] = A0[0] * ((rK ^ (3 * TN[0])) / (q ^ (3 * TN[0])))
  '4. Ersatzbeschaffung
  A4[0] = A0[0] * ((rK ^ (4 * TN[0])) / (q ^ (4 * TN[0])))
  'Restwert
  RW[0] = A0[0] * (rK ^ (n[0] * TN[0])) * (((n[0] + 1) * TN[0] - T) / TN[0]) * (1 / (q ^ T))

  'Instandhaltungssatz
  fK[0] = Global.conProzentInstanthaltungNetz
  
  'Auswahl Anzahl der Ersatzinvestitionen
  Select Case n[0]
  Case 0
    f1 = 0
    f2 = 0
    f3 = 0
    f4 = 0
  Case 1
    f1 = 1
    f2 = 0
    f3 = 0
    f4 = 0
  Case 2
    f1 = 1
    f2 = 1
    f3 = 0
    f4 = 0
  Case 3
    f1 = 1
    f2 = 1
    f3 = 1
    f4 = 0
  Case 4
    f1 = 1
    f2 = 1
    f3 = 1
    f4 = 1
  End Select
  ANK[0] = (A0[0] + f1 * A1[0] + f2 * A2[0] + f3 * A3[0] + f4 * A4[0] - RW[0]) * a + fK[0] * A0[0] * baIN
  '-Netz ENDE--------------------------------------------------------------------------------------------
  
  
  
  '-Wärmetauscherstationen-----------------------
  A0[1] = 0
  For i = 0 To intZeilenPunkte - 1
    If strDatensatzPunkte[39, i] = "1" Then
      A0[1] += AWS
    Endif
  Next
  Global.fltInvestWS_SUMME = A0[1]
  
  'Zahl der Ersatzbeschaffungen
  n[1] = Int(T / TN[1])
  '1. Ersatzbeschaffung
  A1[1] = A0[1] * ((rK ^ (1 * TN[1])) / (q ^ (1 * TN[1])))
  '2. Ersatzbeschaffung
  A2[1] = A0[1] * ((rK ^ (2 * TN[1])) / (q ^ (2 * TN[1])))
  '3. Ersatzbeschaffung
  A3[1] = A0[1] * ((rK ^ (3 * TN[1])) / (q ^ (3 * TN[1])))
  '4. Ersatzbeschaffung
  A4[1] = A0[1] * ((rK ^ (4 * TN[1])) / (q ^ (4 * TN[1])))
  'Restwert
  RW[1] = A0[1] * (rK ^ (n[1] * TN[1])) * (((n[1] + 1) * TN[1] - T) / TN[1]) * (1 / (q ^ T))
 
  'Instandhaltungssatz
  fK[1] = Global.conProzentInstanthaltungWS
  
  'Auswahl Anzahl der Ersatzinvestitionen
  Select Case n[1]
  Case 0
    f1 = 0
    f2 = 0
    f3 = 0
    f4 = 0
  Case 1
    f1 = 1
    f2 = 0
    f3 = 0
    f4 = 0
  Case 2
    f1 = 1
    f2 = 1
    f3 = 0
    f4 = 0
  Case 3
    f1 = 1
    f2 = 1
    f3 = 1
    f4 = 0
  Case 4
    f1 = 1
    f2 = 1
    f3 = 1
    f4 = 1
  End Select
  ANK[1] = (A0[1] + f1 * A1[1] + f2 * A2[1] + f3 * A3[1] + f4 * A4[1] - RW[1]) * a + fK[1] * A0[1] * baIN
  '-Wärmetauscherstationen ENDE-----------------------
  
  
  '-Spitzenlastkessel-----------------------
  A0[2] = ASPL
     
  'Zahl der Ersatzbeschaffungen
  n[2] = Int(T / TN[2])
  '1. Ersatzbeschaffung
  A1[2] = A0[2] * ((rK ^ (1 * TN[2])) / (q ^ (1 * TN[2])))
  '2. Ersatzbeschaffung
  A2[2] = A0[2] * ((rK ^ (2 * TN[2])) / (q ^ (2 * TN[2])))
  '3. Ersatzbeschaffung
  A3[2] = A0[2] * ((rK ^ (3 * TN[2])) / (q ^ (3 * TN[2])))
  '4. Ersatzbeschaffung
  A4[2] = A0[2] * ((rK ^ (4 * TN[2])) / (q ^ (4 * TN[2])))
  'Restwert
  RW[2] = A0[2] * (rK ^ (n[2] * TN[2])) * (((n[2] + 1) * TN[2] - T) / TN[2]) * (1 / (q ^ T))
 
  'Instandhaltungssatz
  fK[2] = Global.conProzentInstanthaltungSPL
  
  'Auswahl Anzahl der Ersatzinvestitionen
  Select Case n[2]
  Case 0
    f1 = 0
    f2 = 0
    f3 = 0
    f4 = 0
  Case 1
    f1 = 1
    f2 = 0
    f3 = 0
    f4 = 0
  Case 2
    f1 = 1
    f2 = 1
    f3 = 0
    f4 = 0
  Case 3
    f1 = 1
    f2 = 1
    f3 = 1
    f4 = 0
  Case 4
    f1 = 1
    f2 = 1
    f3 = 1
    f4 = 1
  End Select
  ANK[2] = (A0[2] + f1 * A1[2] + f2 * A2[2] + f3 * A3[2] + f4 * A4[2] - RW[2]) * a + fK[2] * A0[2] * baIN
  '-Spitzenlastkessel ENDE-----------------------
  
  ANK[3] = ANK[0] + ANK[1] + ANK[2]
  '-------------Annuitäten Investition ENDE-------------------------------------------  
  
  
  '-------------Annuitäten Verbrauch-------------------------------------------  
  '-------------Abwärme---------------------------------------------------------
  If rV[0] = q Then
    b_V[0] = T / q
  Else
    b_V[0] = ((1 - ((rV[0] / q) ^ T)) / (q - rV[0]))
  Endif
  baV[0] = b_V[0] * a
  
  QGEL = 0
  QGL = 0
  QSPL = 0
  For i = 0 To intStundenImJahr - 1
    QGEL += CFloat(Global.strDatensatzSimErgebnis[23, i])
    If CFloat(Global.strDatensatzSimErgebnis[22, i]) >= Global.fltLeistungGL Then
      'wenn der Stundenwert größer gleich der Grundlastleistung (22 ist Qin)
      QGL += Global.fltLeistungGL
      QSPL += CFloat(Global.strDatensatzSimErgebnis[22, i]) - Global.fltLeistungGL
      
    Else
      'wenn der Stundenwert klener als die Grundlastleistung
      QGL += CFloat(Global.strDatensatzSimErgebnis[22, i])
    Endif
  Next
  
  AV1[0] = QGL * PreisE[0]
  ANV[0] = AV1[0] * baV[0]
  '-------------Abwärme ENDE---------------------------------------------------------
  
  '-------------Strom---------------------------------------------------------
  If rV[1] = q Then
    b_V[1] = T / q
  Else
    b_V[1] = ((1 - ((rV[1] / q) ^ T)) / (q - rV[1]))
  Endif
  baV[1] = b_V[1] * a
  AV1[1] = QPumpel * PreisE[1]
  ANV[1] = AV1[1] * baV[1]
  '-------------Strom ENDE---------------------------------------------------------

  '-------------Spitzenlastenergieträger---------------------------------------------------------
  If rV[2] = q Then
    b_V[2] = T / q
  Else
    b_V[2] = ((1 - ((rV[2] / q) ^ T)) / (q - rV[2]))
  Endif
  baV[2] = b_V[2] * a
    
  If Global.fltetaSPL > 0 Then
    AV1[2] = (QSPL / Global.fltetaSPL) * PreisE[2]
  Else
    AV1[2] = (QSPL / 0.000001) * PreisE[2]
  Endif
  ANV[2] = AV1[2] * baV[2]
  '-------------Spitzenlastenergieträger ENDE---------------------------------------------------------
 
  ANV[3] = ANV[0] + ANV[1] + ANV[2]
  '-------------Annuitäten Verbrauch ENDE-------------------------------------------  

  '-------------Annuitäten Betrieb-------------------------------------------  
  'Barwertfaktor Betrieb
  If rB = q Then
    b_B = T / q
  Else
    b_B = ((1 - ((rB / q) ^ T)) / (q - rB))
  Endif
  baB = b_B * a
  
  '------------Netz--------------------------
  AB1[0] = Global.conProzentWartungNetz * A0[0]
  ANB[0] = AB1[0] * baB
  '------------Netz ENDE--------------------------

  '------------Wärmetauscherstationen--------------------------
  AB1[1] = Global.conProzentWartungWS * A0[1]
  ANB[1] = AB1[1] * baB
  '------------Wärmetauscherstationen ENDE--------------------------
  
    '------------Wärmetauscherstationen--------------------------
  AB1[2] = Global.conProzentWartungSPL * A0[2]
  ANB[2] = AB1[2] * baB
  '------------Wärmetauscherstationen ENDE--------------------------
  ANB[3] = ANB[0] + ANB[1] + ANB[2]
  '-------------Annuitäten Betrieb ENDE-------------------------------------------  
  
  '-------------Annuitäten Einzahlung-------------------------------------------  
  rE = (QGL * rV[0] + QPumpel * rV[1] + QSPL * rV[2]) / (QGL + QPumpel + QSPL)
  If rE = q Then
    b_E = T / q
  Else
    b_E = ((1 - ((rE / q) ^ T)) / (q - rE))
  Endif
  baE = b_E * a
  ANE = PreisOUT * QGEL * baE
  '-------------Annuitäten ENDE-------------------------------------------  
  'Gesamtannuität
  AN = ANE - (ANK[3] + ANV[3] + ANB[3])
  
  Global.fltAnnuitaet[0] = ANK[3]
  Global.fltAnnuitaet[1] = ANV[3]
  Global.fltAnnuitaet[2] = ANB[3]
  Global.fltAnnuitaet[3] = ANE
  Global.fltQGL = QGL
  Global.fltQSPL = QSPL
End
